<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#0f172a">
  <title>Planung</title>
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icon-32x32.png" sizes="32x32" type="image/png">
  <link rel="apple-touch-icon" href="icon-192x192.png">
  <style>
:root {
  --bg-start: #0b111b;
  --bg-mid: #111a28;
  --bg-end: #0a1220;
  --panel: rgba(18, 24, 34, 0.72);
  --panel-strong: rgba(20, 26, 36, 0.75);
  --line: rgba(255, 255, 255, 0.1);
  --line-soft: rgba(255, 255, 255, 0.06);
  --text: #e5edf7;
  --muted: #9fb0c7;
  --accent: #5296ff;
  --accent-soft: rgba(82, 150, 255, 0.2);
  --control-bg: rgba(28, 36, 48, 0.85);
  --control-bg-focus: rgba(34, 42, 54, 0.95);
  --btn-top: rgba(34, 42, 54, 0.95);
  --btn-bottom: rgba(24, 30, 40, 0.8);
  --btn-top-hover: rgba(40, 50, 64, 1);
  --btn-bottom-hover: rgba(28, 36, 48, 0.9);
  --danger: #ff8a8a;
  --warn: #facc15;
  --dropdown-bg: #1c2430;
  --week-header-scale: 1;
  --week-table-scale: 1;
}

* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  font-family: "SF Pro Display", "SF Pro Text", "Avenir Next", "Helvetica Neue", "Segoe UI Variable", "Segoe UI", sans-serif;
  color: var(--text);
  background:
    radial-gradient(1400px 950px at 50% -8%, rgba(35, 48, 66, 0.7) 0%, transparent 62%),
    radial-gradient(1200px 800px at -12% 108%, rgba(20, 34, 54, 0.56) 0%, transparent 64%),
    radial-gradient(1200px 800px at 112% 112%, rgba(20, 34, 54, 0.56) 0%, transparent 64%),
    linear-gradient(165deg, var(--bg-start), var(--bg-mid) 45%, var(--bg-end));
  min-height: 100vh;
  height: 100vh;
  overflow: hidden;
  -webkit-touch-callout: none;
}

*:not(input):not(textarea):not(select):not(option):not([contenteditable="true"]) {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}

input,
textarea,
select,
[contenteditable="true"] {
  -webkit-user-select: text;
  user-select: text;
}

h1,
h2,
h3,
p {
  margin: 0;
}

button,
input,
select,
textarea {
  font: inherit;
  color: inherit;
}

input,
select,
textarea {
  background-color: var(--control-bg);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 0.5rem 0.62rem;
  transition: background-color 0.14s ease, border-color 0.14s ease, box-shadow 0.14s ease;
}

select {
  color-scheme: dark;
}

select option,
select optgroup {
  background-color: var(--dropdown-bg) !important;
}

input:hover,
select:hover,
textarea:hover {
  border-color: rgba(82, 150, 255, 0.45);
}

input:focus,
select:focus,
textarea:focus,
button:focus {
  outline: none;
  background-color: var(--control-bg-focus);
  border-color: rgba(82, 150, 255, 0.9);
  box-shadow: 0 0 0 2px rgba(82, 150, 255, 0.25);
}

button {
  cursor: pointer;
  background: linear-gradient(180deg, var(--btn-top), var(--btn-bottom));
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 12px;
  padding: 0.45rem 0.72rem;
  color: #e9eef5;
  transition: background 0.14s ease, border-color 0.14s ease, color 0.14s ease, box-shadow 0.14s ease;
}

button:hover {
  background: linear-gradient(180deg, var(--btn-top-hover), var(--btn-bottom-hover));
}

button:active {
  background: rgba(22, 28, 38, 0.95);
}

button:disabled {
  cursor: default;
  opacity: 0.55;
  filter: grayscale(20%);
}

[hidden] {
  display: none !important;
}

input[type="number"] {
  appearance: textfield;
  -moz-appearance: textfield;
}

input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
  margin: 0;
  appearance: none;
  -webkit-appearance: none;
}

input[type="date"] {
  color-scheme: dark;
}

input[type="date"]::-webkit-calendar-picker-indicator {
  color: currentColor;
  opacity: 1;
  filter: none;
}

.number-stepper {
  position: relative;
  display: inline-block;
  width: fit-content;
  max-width: 100%;
}

.number-stepper > input[type="number"] {
  padding-left: 1.65rem;
  padding-right: 1.65rem;
  text-align: center;
}

.number-stepper-btn {
  position: absolute;
  top: 50%;
  width: 20px;
  height: 20px;
  transform: translateY(-50%);
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.14);
  background: rgba(40, 50, 64, 0.92);
  color: #e9eef5;
  font-size: 0.95rem;
  font-weight: 600;
  line-height: 1;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-shadow: none;
}

.number-stepper-btn.minus {
  left: 3px;
}

.number-stepper-btn.plus {
  right: 3px;
}

.number-stepper-btn:hover:not(:disabled) {
  background: rgba(52, 64, 80, 0.95);
  border-color: rgba(82, 150, 255, 0.55);
}

.number-stepper-btn:active:not(:disabled) {
  background: rgba(30, 38, 50, 1);
}

.number-stepper-btn:disabled {
  background: rgba(30, 36, 48, 0.6);
  border-color: rgba(255, 255, 255, 0.08);
  color: rgba(210, 220, 235, 0.35);
  opacity: 1;
  filter: none;
}

button.ghost {
  background: rgba(28, 34, 44, 0.75);
}

button.ghost:hover:not(:disabled) {
  background: linear-gradient(180deg, var(--btn-top-hover), var(--btn-bottom-hover));
  border-color: rgba(82, 150, 255, 0.7);
  color: #ffffff;
}

button.small {
  padding: 0.2rem 0.5rem;
  border-radius: 8px;
  font-size: 0.78rem;
}

.app-context-menu {
  position: fixed;
  inset: auto;
  margin: 0;
  min-width: 220px;
  max-width: min(340px, calc(100vw - 16px));
  display: grid;
  gap: 2px;
  padding: 6px;
  border-radius: 10px;
  background: rgba(18, 24, 34, 0.97);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 18px 44px rgba(0, 0, 0, 0.36);
  z-index: 2000;
}

.app-context-menu[hidden],
.app-context-menu:not([open]) {
  display: none;
}

.app-context-menu::backdrop {
  background: transparent;
}

.app-context-menu .context-item {
  width: 100%;
  text-align: left;
  border-radius: 8px;
  border: 1px solid transparent;
  background: transparent;
  padding: 0.38rem 0.56rem;
  color: #e9eef5;
  box-shadow: none;
  font-size: 0.86rem;
}

.app-context-menu .context-item:hover {
  background: rgba(82, 150, 255, 0.24);
  border-color: rgba(82, 150, 255, 0.5);
}

.app-context-menu .context-item:disabled {
  color: rgba(210, 220, 235, 0.4);
  background: transparent;
  border-color: transparent;
  filter: none;
  opacity: 1;
}

.app-context-menu .context-item.separator-before {
  margin-top: 4px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  padding-top: 0.58rem;
}

.app-dialog {
  width: min(520px, calc(100vw - 24px));
  max-width: 520px;
  max-height: calc(100vh - 24px);
  overflow: auto;
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 14px;
  background: rgba(18, 24, 34, 0.98);
  color: var(--text);
  padding: 0;
}

#course-dialog.app-dialog {
  width: min(280px, calc(100vw - 24px));
  max-width: 280px;
}

#course-dialog .dialog-actions {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 0.4rem;
  align-items: stretch;
}

#course-dialog .dialog-actions > button {
  width: 100%;
}

#course-dialog .dialog-actions .dialog-grow {
  display: none;
}

#slot-dialog.app-dialog {
  width: min(360px, calc(100vw - 24px));
  max-width: 360px;
}

#slot-dialog-course option,
#slot-course option {
  background-color: var(--dropdown-bg) !important;
}

#slot-dialog-form .slot-dialog-row {
  display: grid;
  grid-template-columns: 108px minmax(0, 1fr);
  align-items: center;
  column-gap: 0.55rem;
  row-gap: 0;
}

#slot-dialog-form .slot-dialog-row > span {
  color: var(--muted);
  font-size: 0.89rem;
}

.app-dialog::backdrop {
  background: rgba(5, 10, 18, 0.62);
}

.app-dialog form {
  margin: 0;
  padding: 0.9rem;
}

.app-dialog .dialog-actions {
  align-items: center;
  margin-top: 0.28rem;
}

.app-dialog .dialog-grow {
  flex: 1 1 auto;
}

#message-dialog.app-dialog {
  width: min(440px, calc(100vw - 24px));
  max-width: 440px;
}

.message-dialog-text {
  margin: 0;
  line-height: 1.45;
  white-space: pre-line;
  color: #dbe4ef;
}

.message-dialog-input-row {
  display: grid;
  gap: 0.36rem;
}

.message-dialog-input-row > span {
  color: var(--muted);
  font-size: 0.89rem;
}

.week-calendar-dialog {
  width: min(368px, calc(100vw - 16px));
  max-width: 368px;
  max-height: min(430px, calc(100vh - 16px));
  margin: 0;
  padding: 8px;
  position: fixed;
  inset: auto;
  border-radius: 12px;
  border-color: rgba(255, 255, 255, 0.08);
  background: rgba(18, 24, 34, 0.98);
  overflow: hidden;
}

.week-calendar-dialog::backdrop {
  background: transparent;
}

.week-calendar-shell {
  display: grid;
  gap: 8px;
}

.week-calendar-header {
  display: grid;
  grid-template-columns: 30px minmax(0, 1fr) 30px;
  gap: 6px;
  align-items: center;
  padding: 6px 8px;
  border-radius: 10px;
  background: rgba(22, 28, 38, 0.85);
}

.week-calendar-header > button {
  width: 30px;
  height: 30px;
  border-radius: 8px;
  padding: 0;
  font-size: 1rem;
  line-height: 1;
  background: rgba(28, 34, 44, 0.8);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.week-calendar-header > button:hover {
  background: rgba(36, 44, 56, 0.9);
}

.week-calendar-header > button:disabled {
  background: rgba(28, 34, 44, 0.45);
  border-color: rgba(255, 255, 255, 0.06);
  color: rgba(200, 210, 225, 0.35);
  opacity: 1;
  filter: none;
}

#week-calendar-month {
  background-color: rgba(26, 34, 46, 0.95);
  border: 1px solid rgba(82, 150, 255, 0.35);
  border-radius: 10px;
  padding: 0.35rem 0.5rem;
  text-align: center;
  font-weight: 600;
}

#week-calendar-month:hover {
  background-color: rgba(34, 42, 56, 0.98);
  border-color: rgba(82, 150, 255, 0.6);
}

.week-calendar-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 4px;
  table-layout: fixed;
}

.week-calendar-table th {
  padding: 0.16rem 0.1rem;
  border: none;
  text-align: center;
  font-size: 0.76rem;
  font-weight: 600;
  color: rgba(210, 220, 235, 0.7);
}

.week-calendar-table th:first-child {
  font-style: italic;
  color: rgba(210, 220, 235, 0.6);
}

.week-calendar-table td {
  border: none;
  padding: 0;
  border-radius: 8px;
}

.week-calendar-row td {
  background: transparent;
  transition: background-color 0.12s ease, border-color 0.12s ease;
}

.week-calendar-row:hover td,
.week-calendar-row.hovered td {
  background: rgba(82, 150, 255, 0.12);
}

.week-calendar-row.active td {
  background: rgba(82, 150, 255, 0.2);
}

.week-calendar-row.active:hover td,
.week-calendar-row.active.hovered td {
  background: rgba(82, 150, 255, 0.26);
}

.week-calendar-row.out-of-range td {
  background: transparent;
}

.week-calendar-week-btn,
.week-calendar-day-btn {
  width: 100%;
  min-height: 30px;
  padding: 0.25rem 0;
  border: 1px solid transparent;
  border-radius: 8px;
  background: transparent;
  box-shadow: none;
  color: #e9eef5;
  text-align: center;
  font-size: 0.86rem;
}

.week-calendar-week-btn {
  font-style: italic;
  color: rgba(210, 220, 235, 0.62);
}

.week-calendar-week-btn:hover,
.week-calendar-day-btn:hover,
.week-calendar-week-btn:active,
.week-calendar-day-btn:active {
  background: transparent;
}

.week-calendar-day-btn.outside-month {
  color: rgba(210, 220, 235, 0.45);
}

.week-calendar-day-btn.today {
  border-color: rgba(82, 150, 255, 0.45);
}

.week-calendar-row.today-week .week-calendar-week-btn,
.week-calendar-row.today-week .week-calendar-day-btn {
  font-weight: 700;
}

.week-calendar-week-btn:disabled,
.week-calendar-day-btn:disabled {
  color: rgba(200, 210, 225, 0.22);
  opacity: 1;
  filter: none;
}

.app-window {
  max-width: 1700px;
  margin: 0 auto;
  min-height: 100vh;
  height: 100vh;
  padding: 18px;
  display: grid;
  grid-template-columns: 168px minmax(0, 1fr);
  gap: 18px;
  overflow: hidden;
}

.sidebar-panel,
.header-glass,
.stack-glass {
  background-color: var(--panel);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 18px;
  backdrop-filter: blur(8px);
}

.sidebar-panel {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-width: 0;
  min-height: calc(100vh - 36px);
  overflow: hidden;
}

.sidebar-controls {
  display: grid;
  gap: 0.42rem;
}

.settings-nav-btn {
  width: 60px;
  height: 44px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  align-self: center;
  margin-top: auto;
  border-radius: 12px;
  padding: 0;
  font-size: 1.7rem;
  line-height: 1;
  background: rgba(28, 34, 44, 0.75);
}

.settings-nav-btn.active {
  background: rgba(82, 150, 255, 0.25);
  border-color: rgba(82, 150, 255, 0.7);
  color: #eef3f8;
}

.settings-nav-btn:hover {
  background: rgba(60, 72, 92, 0.98);
  border-color: rgba(130, 190, 255, 0.95);
  color: #ffffff;
}

.nav-btn {
  width: 100%;
  text-align: center;
  background: rgba(28, 34, 44, 0.75);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.nav-btn.active {
  background: rgba(82, 150, 255, 0.25);
  border-color: rgba(82, 150, 255, 0.7);
  color: #eef3f8;
}

#sidebarPanel .nav-btn:hover {
  background: rgba(60, 72, 92, 0.98);
  border-color: rgba(130, 190, 255, 0.95);
  color: #ffffff;
}

.sidebar-section {
  padding-top: 4px;
  min-height: 0;
  display: flex;
  flex-direction: column;
  flex: 1;
}

.sidebar-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: grid;
  gap: 0.38rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.sidebar-list::-webkit-scrollbar {
  width: 0;
  height: 0;
  display: none;
}

.sidebar-list.empty-pulse {
  animation: none;
}

.sidebar-list li button {
  width: 100%;
  min-width: 0;
  text-align: left;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  padding: 0.56rem 0.7rem;
  font-weight: 700;
}

.sidebar-list li[data-course-id] button .course-name {
  flex: 1 1 auto;
  min-width: 0;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.sidebar-list li[data-course-id] button:hover {
  filter: brightness(1.03);
}

.sidebar-list li[data-course-id] button {
  cursor: pointer;
}

.sidebar-list li {
  border-radius: 12px;
}

.sidebar-list li[data-course-id] {
  transition: transform 0.12s ease, opacity 0.12s ease, filter 0.12s ease;
}

.sidebar-list li.dragging {
  opacity: 0.2;
  filter: saturate(0.6);
}

.sidebar-list li.sidebar-drag-placeholder {
  min-height: 42px;
  border: 2px dashed rgba(130, 190, 255, 0.8);
  background: rgba(82, 150, 255, 0.12);
  border-radius: 12px;
  box-sizing: border-box;
  pointer-events: none;
}

.sidebar-list li.sidebar-drag-placeholder.at-origin {
  min-height: 0;
  height: 0 !important;
  border: 0;
  background: transparent;
}

.sidebar-list li button.active {
  border-color: rgba(255, 255, 255, 0.98) !important;
  box-shadow:
    inset 0 0 0 2px rgba(255, 255, 255, 0.7),
    0 8px 18px rgba(0, 0, 0, 0.34);
  filter: saturate(1.15) brightness(1.06);
}

.sidebar-list li button.active .course-name {
  font-weight: 800;
}

.sidebar-list li button.disabled-course {
  opacity: 0.82;
  cursor: not-allowed;
  pointer-events: none;
}

.sidebar-list li[data-add-item="1"] {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 36px;
  height: 36px;
  padding: 0;
  margin: 4px auto 0;
  border-radius: 0;
}

.sidebar-add-btn {
  width: 36px !important;
  height: 36px !important;
  min-width: 36px;
  max-width: 36px;
  min-height: 36px;
  max-height: 36px;
  aspect-ratio: 1 / 1;
  flex: 0 0 36px;
  border-radius: 50%;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  isolation: isolate;
  overflow: visible;
  color: #d7e0ea;
  background: rgba(36, 44, 56, 0.78);
  border: 1px solid rgba(255, 255, 255, 0.47);
  box-shadow: none;
  line-height: 1;
}

.sidebar-add-btn::before {
  content: "";
  position: absolute;
  inset: -6px;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
  transform: scale(0.93);
  background: radial-gradient(
    circle at center,
    rgba(255, 255, 255, 0.24) 0%,
    rgba(255, 255, 255, 0.1) 36%,
    rgba(255, 255, 255, 0) 72%
  );
  z-index: 0;
}

.sidebar-add-btn:hover {
  background: rgba(36, 44, 56, 0.78);
  border-color: rgba(82, 150, 255, 0.78);
}

.sidebar-add-btn:disabled {
  background: rgba(26, 32, 42, 0.55);
  border-color: rgba(210, 220, 235, 0.35);
  color: rgba(210, 220, 235, 0.35);
  box-shadow: none;
}

.sidebar-add-btn .sidebar-add-plus {
  width: 100%;
  height: 100%;
  display: block;
  position: relative;
  z-index: 1;
}

.sidebar-add-btn .sidebar-add-plus::before,
.sidebar-add-btn .sidebar-add-plus::after {
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  background: currentColor;
  border-radius: 999px;
  transform: translate(-50%, -50%);
}

.sidebar-add-btn .sidebar-add-plus::before {
  width: 14px;
  height: 2px;
}

.sidebar-add-btn .sidebar-add-plus::after {
  width: 2px;
  height: 14px;
}

.sidebar-list.empty-pulse .sidebar-add-btn {
  animation: addButtonPulse 0.75s linear infinite;
}

.sidebar-list.empty-pulse .sidebar-add-btn::before {
  animation: addButtonGlow 0.75s linear infinite;
}

@keyframes addButtonPulse {
  0%,
  100% {
    color: #d7e0ea;
    background: rgba(50, 58, 72, 0.82);
    border-color: rgba(255, 255, 255, 0.47);
  }
  50% {
    color: #ffffff;
    background: rgba(235, 242, 255, 0.9);
    border-color: rgba(255, 255, 255, 0.86);
  }
}

@keyframes addButtonGlow {
  0%,
  100% {
    opacity: 0.24;
    transform: scale(0.93);
  }
  50% {
    opacity: 0.71;
    transform: scale(1);
  }
}

.color-dot {
  width: 11px;
  height: 11px;
  border-radius: 50%;
  flex: 0 0 11px;
  border: 1px solid rgba(0, 0, 0, 0.25);
}

.main-pane {
  display: grid;
  grid-template-rows: auto 1fr;
  gap: 12px;
  min-width: 0;
  min-height: 0;
  height: 100%;
  overflow: hidden;
}

.header-glass {
  padding: calc(10px * var(--week-header-scale, 1)) calc(12px * var(--week-header-scale, 1));
  display: flex;
  align-items: center;
  gap: calc(10px * var(--week-header-scale, 1));
  background-color: var(--panel-strong);
}

.round-btn {
  width: 54px;
  height: 54px;
  border-radius: 26px;
  padding: 0;
  text-align: center;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.week-nav-btn {
  width: calc(54px * var(--week-header-scale, 1));
  min-width: calc(54px * var(--week-header-scale, 1));
  height: calc(54px * var(--week-header-scale, 1));
  min-height: calc(54px * var(--week-header-scale, 1));
  border-radius: calc(26px * var(--week-header-scale, 1));
  padding: 0;
  text-align: center;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(
    180deg,
    rgba(34, 42, 54, 0.95) 0%,
    rgba(24, 30, 40, 0.8) 100%
  );
  border: 1px solid rgba(255, 255, 255, 0.12);
  color: #e9eef5;
  box-shadow: none;
  user-select: none;
}

.week-nav-btn:hover {
  background: linear-gradient(
    180deg,
    rgba(40, 50, 64, 1) 0%,
    rgba(28, 36, 48, 0.9) 100%
  );
}

.week-nav-btn:active {
  background: rgba(22, 28, 38, 0.95);
}

.week-nav-btn:focus,
.week-nav-btn:focus-visible {
  border-color: rgba(255, 255, 255, 0.12);
  box-shadow: none;
}

.week-nav-btn:disabled {
  background: rgba(26, 32, 42, 0.6);
  color: rgba(210, 220, 235, 0.35);
  border-color: rgba(255, 255, 255, 0.08);
  opacity: 1;
  filter: none;
}

.week-nav-icon {
  width: calc(54px * var(--week-header-scale, 1));
  height: calc(54px * var(--week-header-scale, 1));
  display: block;
}

.week-nav-icon path {
  fill: none;
  stroke: currentColor;
  stroke-width: 3;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.week-center {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: calc(10px * var(--week-header-scale, 1));
  flex: 1;
  min-width: 0;
}

.kw-label {
  background-color: rgba(82, 150, 255, 0.12);
  border-color: rgba(82, 150, 255, 0.35);
  min-width: calc(112px * var(--week-header-scale, 1));
  min-height: calc(40px * var(--week-header-scale, 1));
  padding: calc(0.45rem * var(--week-header-scale, 1)) calc(0.72rem * var(--week-header-scale, 1));
  font-size: calc(1.4rem * var(--week-header-scale, 1));
  font-weight: 700;
  text-align: center;
  cursor: pointer;
}

.kw-label:hover {
  background-color: rgba(82, 150, 255, 0.25);
  border-color: rgba(82, 150, 255, 0.7);
  color: #ffffff;
}

.kw-label:active {
  background-color: rgba(82, 150, 255, 0.33);
}

.calendar-btn {
  width: calc(50px * var(--week-header-scale, 1));
  min-width: calc(50px * var(--week-header-scale, 1));
  height: calc(36px * var(--week-header-scale, 1));
  border-radius: 0;
  padding: 0;
  background: transparent;
  border-color: transparent;
  box-shadow: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.calendar-btn:hover {
  background: transparent;
  border-color: transparent;
}

.calendar-btn:active {
  background: transparent;
  border-color: transparent;
}

.calendar-btn:disabled {
  background: transparent;
  border-color: transparent;
  color: inherit;
  opacity: 1;
  filter: none;
  cursor: default;
}

.current-week-icon {
  width: calc(50px * var(--week-header-scale, 1));
  height: calc(36px * var(--week-header-scale, 1));
  display: block;
  pointer-events: none;
}

.calendar-btn:disabled .current-week-icon {
  opacity: 0.35;
}

#week-date {
  position: absolute;
  left: -9999px;
  width: 1px;
  height: 1px;
  opacity: 0;
}

.inline-field {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.88rem;
  color: var(--muted);
}

.stack-glass {
  padding: 12px;
  min-height: 0;
  display: grid;
}

#stackGlass {
  background: transparent;
  border: none;
  border-radius: 0;
  backdrop-filter: none;
  padding: 0;
}

.view-panel {
  min-height: 0;
}

.view-panel[hidden] {
  display: none;
}

#view-week {
  min-height: 0;
  height: 100%;
  display: flex;
  flex-direction: column;
}

#view-course {
  min-height: 0;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#view-week[hidden],
#view-course[hidden],
#view-settings[hidden] {
  display: none !important;
}

#view-settings {
  overflow: hidden;
  min-height: 0;
  display: flex;
  flex-direction: column;
}

.settings-head {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  margin: 0 0 0.55rem;
}

.settings-main-title {
  margin: 0;
  flex: 1 1 auto;
  text-align: center;
  font-size: 1.28rem;
  font-weight: 700;
}

.settings-tabs-shell {
  min-height: 0;
  flex: 1 1 auto;
  display: grid;
  grid-template-rows: auto minmax(0, 1fr) auto;
  gap: 0;
}

.settings-tab-bar {
  display: flex;
  flex-wrap: wrap;
  align-items: flex-end;
  gap: 6px;
  padding: 0;
}

.settings-tab {
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-bottom: none;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  background: rgba(30, 36, 46, 0.75);
  color: #cbd5e1;
  font-weight: 700;
  font-size: 0.94rem;
  padding: 0.45rem 0.82rem;
  min-height: 28px;
}

.settings-tab:hover:not(.active) {
  background: rgba(82, 150, 255, 0.18);
  border-color: rgba(82, 150, 255, 0.45);
  color: #f1f5f9;
}

.settings-tab.active {
  background: rgba(82, 150, 255, 0.25);
  border-color: rgba(82, 150, 255, 0.7);
  color: #e8eef6;
}

.settings-tab-content {
  min-height: 0;
  overflow: auto;
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-top-left-radius: 0;
  border-top-right-radius: 12px;
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
  background: rgba(20, 26, 34, 0.65);
  padding: 8px;
}

#view-settings button:hover:not(:disabled):not(.danger-action):not(.delete):not(.settings-tab) {
  background: linear-gradient(
    180deg,
    rgba(54, 68, 86, 1) 0%,
    rgba(36, 46, 60, 0.95) 100%
  );
  border-color: rgba(82, 150, 255, 0.7);
  color: #ffffff;
}

.settings-tab-content > .settings-panel {
  margin-bottom: 0;
  border: none;
  border-radius: 0;
  background: transparent;
  padding: 0;
}

.settings-actions-row {
  margin-top: 0.6rem;
  display: flex;
  flex-wrap: wrap;
  gap: 0.45rem;
  justify-content: flex-end;
}

.week-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 12px;
  min-height: 0;
}

#view-week .week-grid {
  flex: 1 1 auto;
  height: 100%;
  min-height: 0;
  grid-template-rows: minmax(0, 1fr);
}

.table-panel {
  background: rgba(18, 24, 34, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 14px;
  padding: 8px;
  overflow: auto;
}

#view-week .table-panel {
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 0;
  height: 100%;
  min-height: 0;
  overflow-y: hidden;
  overflow-x: hidden;
}

#view-course .table-panel {
  background: transparent;
  border: none;
  border-radius: 0;
  padding: 0;
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
}

body[data-view="course"] .sidebar-list {
  overflow: hidden;
}

#week-table,
#course-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  min-width: 0;
  table-layout: fixed;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.12);
  outline: 0;
  box-shadow: none;
  background: transparent;
}

#week-table {
  min-width: 0;
}

#view-week #week-table {
  height: 100%;
  box-sizing: border-box;
  --week-block-font-scale: 1;
  --week-table-scale: 1;
}

#week-table th,
#week-table td,
#course-table th,
#course-table td {
  border: none;
  border-right: 1px solid rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  padding: calc(0.34rem * var(--week-table-scale, 1));
  vertical-align: middle;
}

#week-table th,
#week-table td {
  font-size: calc(1rem * var(--week-table-scale, 1));
}

#week-table tr > *:last-child,
#course-table tr > *:last-child {
  border-right: none;
}

#week-table tbody tr:last-child > td,
#course-table tbody tr:last-child > td {
  border-bottom: none;
}

#week-table th,
#course-table th {
  background-color: rgba(30, 36, 46, 0.7);
  color: #dbe4ef;
  text-align: center;
  position: sticky;
  top: 0;
  z-index: 1;
}

#course-table tr.next-lesson-row td {
  background: rgba(82, 150, 255, 0.13);
  font-weight: 700;
}

#course-table tr.course-row-canceled td {
  color: #8b96a8;
}

#course-table tr.course-row-entfall td {
  color: #8b96a8;
}

#course-table tr.course-row-canceled td:nth-child(4),
#course-table tr.course-row-entfall td:nth-child(4) {
  font-style: italic;
}

#course-table tr.course-row-written td {
  color: #b91c1c;
}

#course-table td:nth-child(1),
#course-table td:nth-child(2),
#course-table td:nth-child(3) {
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#course-table th:nth-child(1),
#course-table td:nth-child(1),
#course-table th:nth-child(2),
#course-table td:nth-child(2),
#course-table th:nth-child(3),
#course-table td:nth-child(3) {
  padding-left: 0.42rem;
  padding-right: 0.42rem;
}

#course-table th:nth-child(1),
#course-table td:nth-child(1) {
  width: 17%;
}

#course-table th:nth-child(2),
#course-table td:nth-child(2) {
  width: 8%;
}

#course-table th:nth-child(3),
#course-table td:nth-child(3) {
  width: 9%;
}

#course-table td:nth-child(4) {
  vertical-align: top;
}

#week-table td.hour {
  width: calc(34px * var(--week-table-scale, 1));
  min-width: calc(34px * var(--week-table-scale, 1));
  max-width: calc(34px * var(--week-table-scale, 1));
  font-weight: 700;
  text-align: center;
  background: rgba(24, 31, 43, 0.65);
  padding-left: 0.12rem;
  padding-right: 0.12rem;
}

#view-week #week-table tbody tr {
  height: var(--week-row-height, auto);
  min-height: var(--week-row-height, auto);
  max-height: var(--week-row-height, auto);
}

#view-week #week-table tbody td:not([rowspan]) {
  height: var(--week-row-height, auto);
  min-height: var(--week-row-height, auto);
  max-height: var(--week-row-height, auto);
}

#week-table th:first-child {
  width: calc(34px * var(--week-table-scale, 1));
  min-width: calc(34px * var(--week-table-scale, 1));
  max-width: calc(34px * var(--week-table-scale, 1));
  padding-left: 0.12rem;
  padding-right: 0.12rem;
}

.day-cell {
  min-height: 64px;
}

#view-week #week-table .day-cell {
  min-height: 0;
}

.day-head .day-name,
.day-head .day-date {
  display: block;
  line-height: 1.15;
}

.day-head .day-name {
  font-weight: 700;
}

.day-head .day-date {
  color: rgba(219, 228, 239, 0.85);
  font-size: calc(0.79rem * var(--week-table-scale, 1));
}

.day-head.today .day-name {
  font-weight: 800;
}

.day-off-head.holiday {
  background: rgba(54, 95, 145, 0.25);
}

.day-off-head.special {
  background: rgba(111, 88, 42, 0.25);
}

.day-off-column {
  text-align: center;
  padding: 0;
}

.day-off-column.holiday {
  background: rgba(74, 131, 197, 0.2);
}

.day-off-column.special {
  background: rgba(173, 139, 52, 0.2);
}

.day-off-label {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  transform: rotate(180deg);
  display: inline-block;
  font-weight: 700;
  font-style: italic;
  letter-spacing: 0.03em;
}

.day-off-column.holiday .day-off-label {
  color: #9fceff;
}

.day-off-column.special .day-off-label {
  color: #ffe1a1;
}

.week-block-cell {
  padding: calc(0.16rem * var(--week-table-scale, 1));
  overflow: hidden;
}

.day-cell.empty {
  background: rgba(24, 31, 43, 0.24);
}

#week-table td.day-cell.empty:hover {
  background: rgba(82, 150, 255, 0.18);
  box-shadow: inset 0 0 0 1px rgba(82, 150, 255, 0.45);
}

.lesson-block {
  border: 1px solid rgba(0, 0, 0, 0.18);
  border-radius: calc(8px * var(--week-table-scale, 1));
  padding: calc(0.24rem * var(--week-table-scale, 1)) calc(0.28rem * var(--week-table-scale, 1));
  width: 100%;
  position: relative;
  display: grid;
  grid-template-rows: auto minmax(0, 1fr);
  justify-items: center;
  align-items: center;
  row-gap: calc(0.12rem * var(--week-table-scale, 1));
  text-align: center;
  height: 100%;
  min-height: 0;
  max-height: 100%;
  background: rgba(102, 153, 222, 0.82);
  font-weight: 700;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18);
  overflow: hidden;
  transition:
    transform 0.12s ease,
    border-color 0.14s ease,
    box-shadow 0.14s ease,
    filter 0.14s ease;
}

.lesson-block:hover:not(:disabled):not(.not-selectable),
.lesson-block:focus-visible:not(:disabled):not(.not-selectable) {
  transform: translateY(-1px);
  border-color: rgba(255, 255, 255, 0.32);
  box-shadow:
    0 4px 10px rgba(6, 12, 20, 0.22),
    inset 0 1px 0 rgba(255, 255, 255, 0.24);
  filter: saturate(1.03) brightness(1.02);
}

.lesson-block:active:not(:disabled):not(.not-selectable) {
  transform: translateY(0);
}

.lesson-block.not-selectable {
  cursor: default;
}

.lesson-block:disabled {
  opacity: 1;
  filter: none;
  cursor: default;
}

.lesson-block.selected {
  box-shadow:
    0 0 0 2px rgba(255, 255, 255, 0.88),
    0 0 0 4px rgba(82, 150, 255, 0.25),
    inset 0 1px 0 rgba(255, 255, 255, 0.18);
}

.lesson-block.canceled,
.lesson-block.entfall {
  font-style: italic;
}

.lesson-block .title {
  display: block;
  position: static;
  width: 100%;
  max-width: 100%;
  text-align: center;
  pointer-events: none;
  font-size: calc(1rem * var(--week-table-scale, 1) * var(--week-block-font-scale, 1));
  line-height: 1.1;
  font-weight: 700;
}

.lesson-block .line {
  display: block;
  width: 100%;
  max-width: 100%;
  text-align: center;
  font-size: calc(1.3rem * var(--week-table-scale, 1) * var(--week-block-font-scale, 1));
  line-height: 1.12;
  opacity: 0.95;
}

.lesson-block .title,
.lesson-block .line {
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  text-overflow: clip;
}

.lesson-block.inline-editing {
  cursor: text;
  grid-template-rows: auto minmax(0, 1fr);
  align-content: stretch;
  justify-content: stretch;
}

.lesson-block.inline-editing .title {
  align-self: start;
}

.lesson-block .week-inline-topic-input {
  width: 100%;
  min-width: 0;
  min-height: 0;
  height: 100%;
  max-height: 100%;
  margin: 0;
  align-self: stretch;
  resize: none;
  overflow: hidden;
  scrollbar-width: none;
  -ms-overflow-style: none;
  white-space: pre-wrap;
  overflow-wrap: anywhere;
  word-break: break-word;
  border-radius: calc(6px * var(--week-table-scale, 1));
  border: 1px solid rgba(255, 255, 255, 0.35);
  background: rgba(10, 16, 24, 0.22);
  color: inherit;
  text-align: center;
  text-align-last: center;
  font-size: calc(1.3rem * var(--week-table-scale, 1) * var(--week-block-font-scale, 1));
  line-height: 1.12;
  font-weight: 700;
  padding: 0;
}

.lesson-block .week-inline-topic-input::-webkit-scrollbar {
  width: 0;
  height: 0;
  display: none;
}

.lesson-block .week-inline-topic-input::placeholder {
  color: rgba(0, 0, 0, 0.55);
}

.lesson-block .week-inline-topic-input:focus {
  outline: none;
  border-color: rgba(255, 255, 255, 0.72);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28);
}

.form-grid {
  display: grid;
  gap: 0.52rem;
}

.form-grid > div#slot-edit-tools,
.form-grid > div#slot-dialog-edit-tools {
  border: 1px solid var(--line-soft);
  border-radius: 10px;
  padding: 0.5rem;
  background: rgba(22, 29, 40, 0.55);
  display: grid;
  gap: 0.5rem;
}

.form-grid.compact {
  max-width: 340px;
}

label {
  display: grid;
  gap: 0.2rem;
  color: var(--muted);
  font-size: 0.89rem;
}

.field-label {
  display: grid;
  gap: 0.2rem;
  color: var(--muted);
  font-size: 0.89rem;
}

.checkbox-line {
  grid-template-columns: 18px 1fr;
  align-items: center;
  gap: 0.4rem;
}

.course-color-panel {
  border: 1px solid var(--line-soft);
  border-radius: 10px;
  padding: 0.5rem;
  background: rgba(22, 29, 40, 0.55);
  transition: opacity 0.12s ease;
}

.course-color-panel.disabled {
  opacity: 0.35;
  pointer-events: none;
}

.course-color-palette {
  display: grid;
  grid-template-columns: repeat(5, 26px);
  gap: 8px;
  align-content: start;
}

.course-color-btn {
  width: 26px;
  height: 26px;
  min-width: 26px;
  min-height: 26px;
  border-radius: 6px;
  padding: 0;
  border: 1px solid rgba(255, 255, 255, 0.35);
  background: transparent;
  box-shadow: none;
  position: relative;
}

.course-color-btn:hover,
.course-color-btn:active {
  box-shadow: none;
  filter: none;
}

.course-color-btn:not(.used):hover {
  border-color: rgba(255, 255, 255, 0.45);
}

.course-color-btn:disabled {
  opacity: 1;
  filter: none;
}

.course-color-btn .swatch-fill {
  position: absolute;
  inset: 2px;
  border-radius: 4px;
}

.course-color-btn.selected {
  border: 2px solid rgba(255, 255, 255, 0.75);
}

.course-color-btn.selected .swatch-fill {
  inset: 3px;
}

.course-color-btn.used {
  border: 1px solid rgba(255, 255, 255, 0.35);
  cursor: default;
}

.course-color-btn.used::after {
  content: "";
  position: absolute;
  left: 3px;
  right: 3px;
  top: 12px;
  height: 2px;
  border-radius: 99px;
  background: rgba(0, 0, 0, 0.72);
  transform: rotate(-45deg);
}

.button-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
}

.settings-panel {
  border: 1px solid var(--line-soft);
  border-radius: 12px;
  padding: 0.75rem;
  background: rgba(16, 22, 32, 0.46);
  margin-bottom: 0.75rem;
}

.settings-panel:last-child {
  margin-bottom: 0;
}

.settings-panel-title {
  font-size: 1rem;
  margin-bottom: 0.55rem;
}

.settings-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.settings-column {
  min-width: 0;
}

.settings-extra-section {
  margin-top: 0.75rem;
  border-top: 1px solid var(--line-soft);
  padding-top: 0.75rem;
}

#settings-tab-database .settings-extra-section {
  margin-top: 0;
  border-top: none;
  padding-top: 0;
}

#settings-tab-database .settings-extra-section + .settings-extra-section {
  margin-top: 0.75rem;
}

#settings-tab-database .button-row + .settings-extra-section {
  margin-top: 1.25rem;
}

.settings-link-hint {
  margin: 0 0 0.52rem;
  font-size: 0.88rem;
  color: var(--muted);
}

.settings-link-hint a {
  color: #dbeafe;
}

.settings-link-hint a:hover {
  color: #ffffff;
}

.settings-form-table {
  display: grid;
  gap: 0.54rem;
  max-width: 560px;
}

.settings-form-row {
  display: grid;
  grid-template-columns: minmax(220px, 1fr) auto;
  align-items: center;
  gap: 0.7rem;
}

.settings-form-label {
  display: block;
  color: var(--muted);
  font-size: 0.89rem;
}

.settings-number-input {
  width: 90px;
  justify-self: start;
}

.settings-inline-checkbox.checkbox-line {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  grid-template-columns: none;
  margin: 0;
}

.required-hint {
  margin-bottom: 0.72rem;
  border: 1px solid rgba(250, 204, 21, 0.44);
  border-radius: 10px;
  background: rgba(250, 204, 21, 0.12);
  padding: 0.58rem 0.62rem;
  display: grid;
  gap: 0.24rem;
}

.required-hint-title {
  font-weight: 700;
  color: #fff2c2;
}

.required-hint-missing {
  color: #fde68a;
}

.required-hint-link {
  font-size: 0.84rem;
}

.required-hint-link a {
  color: #dbeafe;
}

.required-hint-link a:hover {
  color: #ffffff;
}

.list {
  list-style: none;
  margin: 0.65rem 0 0;
  padding: 0;
  display: grid;
  gap: 0.45rem;
  max-height: 280px;
  overflow-y: auto;
  overflow-x: hidden;
}

.list li {
  border: 1px solid var(--line-soft);
  border-radius: 10px;
  padding: 0.45rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.45rem;
  background: rgba(22, 29, 40, 0.72);
}

.list .main {
  min-width: 0;
}

.list .meta {
  color: var(--muted);
  font-size: 0.82rem;
}

.item-actions {
  display: flex;
  gap: 0.3rem;
}

.item-actions button {
  padding: 0.25rem 0.45rem;
  font-size: 0.78rem;
}

.item-actions .delete {
  border-color: rgba(255, 138, 138, 0.6);
  color: #ffe9e9;
  background: rgba(255, 106, 106, 0.32);
}

#settings-tab-dayoff .settings-grid {
  grid-template-columns: 1fr 1fr;
}

#settings-tab-dayoff .list {
  max-height: none;
}

#settings-tab-dayoff #special-day-list {
  max-height: none !important;
  overflow: visible !important;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

#settings-tab-dayoff #special-day-list::-webkit-scrollbar {
  display: none;
}

#settings-tab-dayoff .list li {
  flex-direction: column;
  align-items: stretch;
}

#settings-tab-dayoff #special-day-list li[data-add-item="1"] {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  min-width: 36px;
  max-width: 36px;
  min-height: 36px;
  max-height: 36px;
  padding: 0;
  margin: 4px auto 0;
  gap: 0;
  border-radius: 0;
  border: 0;
  background: transparent;
  box-shadow: none;
}

#settings-tab-dayoff .item-actions {
  justify-content: flex-end;
  flex-wrap: wrap;
}

#settings-tab-dayoff .list li[data-clickable="1"] {
  cursor: pointer;
}

#settings-tab-dayoff .list li[data-clickable="1"]:hover {
  border-color: rgba(82, 150, 255, 0.45);
  background: rgba(28, 38, 52, 0.78);
}

.danger-action {
  border-color: rgba(255, 138, 138, 0.6) !important;
  color: #ffe9e9 !important;
  background: rgba(255, 106, 106, 0.32) !important;
}

.slot-edit-info {
  border: 1px solid var(--line-soft);
  border-radius: 10px;
  background: rgba(24, 31, 43, 0.52);
  padding: 0.48rem 0.56rem;
  font-size: 0.84rem;
  color: var(--muted);
}

.muted {
  color: var(--muted);
}

.course-head {
  margin-bottom: 0.7rem;
}

#course-title {
  margin: 0 auto;
  min-height: 36px;
  padding: 0.34rem 1.35rem;
  border-radius: 12px;
  border: 1px solid transparent;
  color: #000000;
  text-align: center;
  font-size: 1.22rem;
  font-weight: 700;
  min-width: min(280px, 100%);
  width: fit-content;
  max-width: 100%;
}

.course-date-link {
  display: inline-block;
  max-width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border: none;
  background: transparent;
  box-shadow: none;
  padding: 0.08rem 0.26rem;
  color: inherit;
  text-decoration: none;
  border-radius: 6px;
  transition: background-color 0.14s ease, color 0.14s ease, box-shadow 0.14s ease;
}

.course-date-link:hover {
  background: rgba(82, 150, 255, 0.18);
  color: #eef6ff;
  box-shadow: inset 0 0 0 1px rgba(82, 150, 255, 0.45);
  text-decoration: none;
}

.course-date-link:focus-visible {
  background: rgba(82, 150, 255, 0.22);
  color: #ffffff;
  box-shadow: inset 0 0 0 1px rgba(82, 150, 255, 0.65);
}

.course-topic-wrap {
  display: flex;
  align-items: center;
  gap: 0.32rem;
}

.course-topic-wrap > * {
  min-width: 0;
}

.course-topic-input {
  width: 100%;
  border-radius: 8px;
  border: 1px solid transparent;
  background: transparent;
  padding: 0.28rem 0.42rem;
}

.course-topic-input:hover {
  background: rgba(28, 36, 48, 0.42);
}

.course-topic-input:focus {
  background: rgba(28, 36, 48, 0.88);
  border-color: rgba(82, 150, 255, 0.58);
}

.course-topic-input:disabled {
  background: transparent;
  border-color: transparent;
  color: inherit;
  opacity: 1;
  cursor: default;
}

#course-table tr.course-row-canceled .course-topic-input:disabled,
#course-table tr.course-row-entfall .course-topic-input:disabled {
  font-style: italic;
}

.course-topic-wrap .course-topic-input {
  flex: 1 1 auto;
  min-width: 0;
}

.db-path-grid {
  display: grid;
  gap: 0.55rem;
}

.db-path-row {
  display: grid;
  grid-template-columns: 90px minmax(0, 1fr);
  gap: 0.9rem;
  align-items: center;
}

.db-path-name {
  min-width: 0;
  color: var(--text);
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#backup-hint.backup-due {
  color: #fde68a;
}

.attention-pulse {
  animation: requiredActionPulse 1.1s linear infinite;
}

@keyframes requiredActionPulse {
  0%,
  100% {
    border-color: rgba(250, 204, 21, 0.55);
    box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.34);
  }
  50% {
    border-color: rgba(250, 204, 21, 0.95);
    box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.18);
  }
}

.next-lesson-arrow {
  flex: 0 0 auto;
  color: #dbeafe;
  font-weight: 900;
  font-size: 0.98rem;
  line-height: 1;
}

@media (max-width: 1200px) {
  .app-window {
    grid-template-columns: 168px minmax(0, 1fr);
    padding: 10px;
    gap: 10px;
  }

  .sidebar-panel {
    min-height: calc(100vh - 20px);
  }

  .week-grid {
    grid-template-columns: 1fr;
  }

  .settings-grid {
    grid-template-columns: 1fr;
  }

  .settings-form-row {
    grid-template-columns: 1fr;
    align-items: stretch;
  }

  .header-glass {
    flex-wrap: nowrap;
  }

  .week-center {
    order: 0;
    flex: 1 1 auto;
  }
}

  </style>
</head>
<body>
  <div class="app-window">
    <aside id="sidebarPanel" class="sidebar-panel">
      <div class="sidebar-controls">
        <button id="view-week-btn" class="nav-btn active" type="button">Wochenansicht</button>
      </div>

      <div class="sidebar-section">
        <ul id="sidebar-course-list" class="sidebar-list"></ul>
      </div>

      <button id="view-settings-btn" class="settings-nav-btn" type="button" aria-label="Einstellungen" title="Einstellungen">⚙️</button>
    </aside>

    <main class="main-pane">
      <header id="headerGlass" class="header-glass">
        <button id="week-prev" class="round-btn week-nav-btn" type="button" aria-label="Vorherige Woche" title="Woche zurück">
          <svg class="week-nav-icon" viewBox="0 0 54 54" aria-hidden="true">
            <path d="M33.5 15.2L20.5 27L33.5 38.8"></path>
          </svg>
        </button>

        <div class="week-center">
          <button
            id="kw-label"
            class="kw-label"
            type="button"
            aria-label="Minikalender öffnen"
            title="Minikalender öffnen"
          >KW 00</button>
          <button id="week-picker-btn" class="calendar-btn" type="button" aria-label="Aktuelle Woche" title="Aktuelle Woche">
            <svg class="current-week-icon" viewBox="0 0 38 28" aria-hidden="true">
              <rect x="2" y="1" width="26" height="26" rx="3" fill="#ffffff" stroke="#e9eef5" stroke-width="2"></rect>
              <path d="M2 1H28V6.72H2Z" fill="#d63c2f"></path>
              <line x1="2" y1="6.72" x2="28" y2="6.72" stroke="#e9eef5" stroke-width="2"></line>
              <circle cx="15" cy="16.86" r="2" fill="#5f5f5f"></circle>
              <path d="M36 16.86H20" stroke="#5f5f5f" stroke-width="4" stroke-linecap="round"></path>
              <path d="M20 16.86L22.65 14.27M20 16.86L22.65 19.45" stroke="#5f5f5f" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path>
            </svg>
          </button>
          <input id="week-date" type="date" aria-label="Wochenstart">
          <select id="school-year-select" hidden aria-hidden="true"></select>
        </div>

        <button id="week-next" class="round-btn week-nav-btn" type="button" aria-label="Nächste Woche" title="Woche vor">
          <svg class="week-nav-icon" viewBox="0 0 54 54" aria-hidden="true">
            <path d="M20.5 15.2L33.5 27L20.5 38.8"></path>
          </svg>
        </button>
      </header>

      <section id="stackGlass" class="stack-glass">
        <section id="view-week" class="view-panel active">
          <div class="week-grid">
            <div class="table-panel">
              <table id="week-table"></table>
            </div>
          </div>
        </section>

        <section id="view-course" class="view-panel" hidden>
          <div class="course-head">
            <h2 id="course-title"></h2>
          </div>
          <div class="table-panel">
            <table id="course-table"></table>
          </div>
        </section>

        <section id="view-settings" class="view-panel" hidden>
          <div class="settings-head">
            <h2 class="settings-main-title">Einstellungen</h2>
          </div>
          <div class="settings-tabs-shell">
            <div class="settings-tab-bar" role="tablist" aria-label="Einstellungen">
              <button class="settings-tab active" type="button" role="tab" data-tab="dayoff" aria-controls="settings-tab-dayoff" aria-selected="true">Ferien & Unterrichtsfreie Tage</button>
              <button class="settings-tab" type="button" role="tab" data-tab="display" aria-controls="settings-tab-display" aria-selected="false">Anzeige</button>
              <button class="settings-tab" type="button" role="tab" data-tab="database" aria-controls="settings-tab-database" aria-selected="false">Datenbank</button>
              <button class="settings-tab" type="button" role="tab" data-tab="version" aria-controls="settings-tab-version" aria-selected="false">Version</button>
            </div>
            <div class="settings-tab-content">
              <div id="settings-courses-hidden" hidden>
                <h3 class="settings-panel-title">Kurse</h3>
                <div class="button-row">
                  <button type="button" id="course-settings-add">Kurs hinzufügen</button>
                </div>
                <ul id="course-list" class="list"></ul>
              </div>

              <div id="settings-slots-hidden" hidden>
                <h3 class="settings-panel-title">Stundenplan</h3>
                <form id="slot-form" class="form-grid">
                  <input type="hidden" id="slot-id">
                  <label>
                    Kurs
                    <select id="slot-course" required></select>
                  </label>
                  <label>
                    Wochentag
                    <select id="slot-day" required>
                      <option value="1">Montag</option>
                      <option value="2">Dienstag</option>
                      <option value="3">Mittwoch</option>
                      <option value="4">Donnerstag</option>
                      <option value="5">Freitag</option>
                    </select>
                  </label>
                  <label>
                    Startstunde
                    <input id="slot-hour" type="number" min="1" max="12" value="1" required>
                  </label>
                  <label>
                    Dauer
                    <input id="slot-duration" type="number" min="1" max="4" value="1" required>
                  </label>
                  <label>
                    Von (optional)
                    <input id="slot-start" type="date">
                  </label>
                  <label>
                    Bis (optional)
                    <input id="slot-end" type="date">
                  </label>
                  <label>
                    Woche
                    <select id="slot-parity">
                      <option value="0">Jede Woche</option>
                      <option value="-1">Keine</option>
                      <option value="1">Ungerade KW</option>
                      <option value="2">Gerade KW</option>
                    </select>
                  </label>
                  <div id="slot-edit-tools" hidden>
                    <label>
                      Änderungsumfang
                      <select id="slot-edit-scope">
                        <option value="all">Gesamte Serie</option>
                        <option value="from">Ab Datum</option>
                      </select>
                    </label>
                    <label>
                      Änderungen ab
                      <input id="slot-edit-from-date" type="date">
                    </label>
                  </div>
                  <div class="button-row">
                    <button type="submit">Slot speichern</button>
                    <button type="button" id="slot-reset" class="ghost">Zurücksetzen</button>
                    <button type="button" id="slot-delete" class="ghost danger-action" hidden>Löschen</button>
                  </div>
                </form>
                <ul id="slot-list" class="list"></ul>
              </div>

              <div id="settings-tab-dayoff" class="settings-panel active" role="tabpanel">
                <div id="dayoff-required-hint" class="required-hint" hidden>
                  <p class="required-hint-title">Pflicht-Ferien sind noch unvollständig.</p>
                  <p id="dayoff-required-missing" class="required-hint-missing"></p>
                </div>
                <p class="settings-link-hint"><em>Überprüfe die Daten anhand der <a href="https://www.schure.de/theme/sr3131.htm" target="_blank" rel="noopener noreferrer">Niedersächsischen Ferienordnung</a>.</em></p>
                <div class="settings-grid">
                  <div class="settings-column">
                    <h3 class="settings-panel-title">Ferien</h3>
                    <ul id="free-range-list" class="list"></ul>
                  </div>

                  <div class="settings-column">
                    <h3 class="settings-panel-title">Unterrichtsfreie Tage</h3>
                    <datalist id="special-day-options">
                      <option value="Tag der Arbeit"></option>
                      <option value="Tag der Deutschen Einheit"></option>
                      <option value="Karfreitag"></option>
                      <option value="Ostermontag"></option>
                      <option value="Christi Himmelfahrt"></option>
                      <option value="Tag nach Himmelfahrt"></option>
                      <option value="Pfingstdienstag"></option>
                      <option value="Pfingstmontag"></option>
                      <option value="Reformationstag"></option>
                    </datalist>
                    <ul id="special-day-list" class="list"></ul>
                  </div>
                </div>
              </div>

              <div id="settings-tab-display" class="settings-panel" role="tabpanel" hidden>
                <form class="settings-form-table" autocomplete="off">
                  <div class="settings-form-row">
                    <label class="settings-form-label" for="hours-per-day">Maximale Unterrichtsstunden pro Tag</label>
                    <input id="hours-per-day" class="settings-number-input" type="number" min="1" max="12" value="8">
                  </div>
                  <div class="settings-form-row">
                    <span class="settings-form-label">Randleiste</span>
                    <label class="checkbox-line settings-inline-checkbox">
                      <input id="show-hidden-sidebar-courses" type="checkbox">
                      Ausgeblendete Kurse in Randleiste anzeigen
                    </label>
                  </div>
                </form>
              </div>

              <div id="settings-tab-database" class="settings-panel" role="tabpanel" hidden>
                <div class="settings-extra-section">
                  <h3 class="settings-panel-title">Datenbankdatei</h3>
                  <p id="sync-file-name" class="muted"></p>
                </div>
                <div class="button-row" style="margin-top: 0.6rem;">
                  <button id="db-select-existing-btn" type="button">Bestehende Datenbank auswählen</button>
                  <button id="db-create-new-btn" type="button">Neue Datenbank anlegen</button>
                </div>
                <div class="settings-extra-section">
                  <h3 class="settings-panel-title">Backups</h3>
                  <p id="backup-dir-name" class="muted"></p>
                  <div class="button-row" style="margin-top: 0.45rem; margin-bottom: 1rem;">
                    <button id="backup-dir-change-btn" type="button">Backup-Ordner auswählen</button>
                  </div>
                  <div class="settings-form-table">
                    <div class="settings-form-row">
                      <span class="settings-form-label">Automatisches Backup</span>
                      <label class="checkbox-line settings-inline-checkbox">
                        <input id="db-backup-auto-enabled" type="checkbox">
                        aktiviert
                      </label>
                    </div>
                    <div class="settings-form-row">
                      <label class="settings-form-label" for="db-backup-interval-days">Intervall (Tage)</label>
                      <input id="db-backup-interval-days" class="settings-number-input" type="number" min="1" max="30" value="7">
                    </div>
                  </div>
                  <div class="button-row" style="margin-top: 0.5rem;">
                    <button id="db-backup-now-btn" type="button">Backup jetzt erstellen</button>
                  </div>
                </div>
              </div>

              <div id="settings-tab-version" class="settings-panel" role="tabpanel" hidden>
                <p class="muted">App-Version: <strong id="app-version"></strong></p>
              </div>
            </div>
            <div class="settings-actions-row">
              <button id="settings-reset-all" type="button" class="ghost">Standardwerte</button>
              <button id="settings-save-all" type="button">Bestätigen</button>
              <button id="settings-cancel-all" type="button" class="ghost">Abbrechen</button>
            </div>
          </div>
        </section>
      </section>
    </main>
  </div>
  <dialog id="app-context-menu" class="app-context-menu" hidden></dialog>

  <dialog id="course-dialog" class="app-dialog" aria-label="Kursdialog">
    <form id="course-dialog-form" class="form-grid" method="dialog">
      <h3 id="course-dialog-title" class="settings-panel-title">Kurs</h3>
      <input type="hidden" id="course-dialog-id">
      <label>
        Kursname
        <input id="course-dialog-name" required maxlength="80" placeholder="z. B. Ma 8a" autocomplete="off">
      </label>
      <label class="checkbox-line">
        <input id="course-dialog-no-lesson" type="checkbox">
        Termin ohne Unterricht
      </label>
      <div class="field-label">
        <span id="course-dialog-color-label">Farbe</span>
        <div id="course-dialog-color-panel" class="course-color-panel">
          <div id="course-dialog-color-palette" class="course-color-palette" role="group" aria-labelledby="course-dialog-color-label"></div>
        </div>
      </div>
      <div class="button-row dialog-actions">
        <button type="button" id="course-dialog-toggle-sidebar" class="ghost" hidden>Ausblenden</button>
        <button type="button" id="course-dialog-delete" class="ghost danger-action" hidden>Löschen</button>
        <span class="dialog-grow"></span>
        <button type="button" id="course-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="entfall-dialog" class="app-dialog" aria-label="Entfalldialog">
    <form id="entfall-dialog-form" class="form-grid" method="dialog">
      <h3 class="settings-panel-title">Entfall eintragen</h3>
      <label>
        Entfallgrund (optional)
        <input id="entfall-dialog-reason" maxlength="160" placeholder="z. B. Exkursion">
      </label>
      <div class="button-row dialog-actions">
        <span class="dialog-grow"></span>
        <button type="button" id="entfall-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="topic-dialog" class="app-dialog" aria-label="Themadialog">
    <form id="topic-dialog-form" class="form-grid" method="dialog">
      <h3 class="settings-panel-title">Thema bearbeiten</h3>
      <input id="topic-dialog-lesson" type="hidden">
      <input id="topic-dialog-input" maxlength="240" placeholder="Thema" aria-label="Thema">
      <div class="button-row dialog-actions">
        <span class="dialog-grow"></span>
        <button type="button" id="topic-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="slot-dialog" class="app-dialog" aria-label="Unterrichtsstundendialog">
    <form id="slot-dialog-form" class="form-grid" method="dialog">
      <h3 id="slot-dialog-title" class="settings-panel-title">Unterrichtsstunde</h3>
      <input type="hidden" id="slot-dialog-id">
      <label class="slot-dialog-row">
        <span>Kurs</span>
        <select id="slot-dialog-course" required></select>
      </label>
      <label class="slot-dialog-row">
        <span>Wochentag</span>
        <select id="slot-dialog-day" required>
          <option value="1">Mo</option>
          <option value="2">Di</option>
          <option value="3">Mi</option>
          <option value="4">Do</option>
          <option value="5">Fr</option>
        </select>
      </label>
      <label class="slot-dialog-row">
        <span>Startstunde</span>
        <input id="slot-dialog-hour" type="number" min="1" max="12" value="1" required>
      </label>
      <label class="slot-dialog-row">
        <span>Endstunde</span>
        <input id="slot-dialog-end-hour" type="number" min="1" max="12" value="2" required>
      </label>
      <label class="slot-dialog-row">
        <span>Wiederholung</span>
        <select id="slot-dialog-parity">
          <option value="0">Jede Woche</option>
          <option value="-1">Keine</option>
          <option value="1">Nur ungerade Wochen</option>
          <option value="2">Nur gerade Wochen</option>
        </select>
      </label>
      <label class="slot-dialog-row">
        <span>Startdatum</span>
        <input id="slot-dialog-start" type="date" required>
      </label>
      <label class="slot-dialog-row">
        <span>Enddatum</span>
        <input id="slot-dialog-end" type="date" required>
      </label>
      <div id="slot-dialog-edit-info" class="slot-edit-info" hidden></div>
      <div id="slot-dialog-edit-tools" hidden>
        <input id="slot-dialog-edit-scope" type="hidden" value="all">
        <input id="slot-dialog-edit-from-date" type="hidden">
      </div>
      <div class="button-row dialog-actions">
        <button type="button" id="slot-dialog-delete" class="ghost danger-action" hidden>Löschen</button>
        <span class="dialog-grow"></span>
        <button type="button" id="slot-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="free-range-dialog" class="app-dialog" aria-label="Ferienzeitraumdialog">
    <form id="free-range-dialog-form" class="form-grid" method="dialog">
      <h3 id="free-range-dialog-title" class="settings-panel-title">Ferienzeitraum</h3>
      <input type="hidden" id="free-range-dialog-id">
      <label>
        Bezeichnung
        <input id="free-range-dialog-label" required placeholder="z. B. Herbstferien" maxlength="80" autocomplete="off">
      </label>
      <label>
        Von
        <input id="free-range-dialog-start" type="date" required>
      </label>
      <label>
        Bis
        <input id="free-range-dialog-end" type="date" required>
      </label>
      <div class="button-row dialog-actions">
        <span class="dialog-grow"></span>
        <button type="button" id="free-range-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="special-day-dialog" class="app-dialog" aria-label="Unterrichtsfreier-Tag-Dialog">
    <form id="special-day-dialog-form" class="form-grid" method="dialog">
      <h3 id="special-day-dialog-title" class="settings-panel-title">Unterrichtsfreier Tag</h3>
      <input type="hidden" id="special-day-dialog-id">
      <label>
        Name
        <input id="special-day-dialog-name" list="special-day-options" required maxlength="80" placeholder="z. B. Tag der Arbeit" autocomplete="off">
      </label>
      <label>
        Datum
        <input id="special-day-dialog-date" type="date" required>
      </label>
      <div class="button-row dialog-actions">
        <button type="button" id="special-day-dialog-delete" class="ghost danger-action" hidden>Löschen</button>
        <span class="dialog-grow"></span>
        <button type="button" id="special-day-dialog-cancel" class="ghost">Abbrechen</button>
        <button type="submit">Speichern</button>
      </div>
    </form>
  </dialog>

  <dialog id="message-dialog" class="app-dialog" aria-label="Meldungsdialog">
    <form id="message-dialog-form" class="form-grid" method="dialog">
      <h3 id="message-dialog-title" class="settings-panel-title">Hinweis</h3>
      <p id="message-dialog-text" class="message-dialog-text"></p>
      <label id="message-dialog-input-row" class="message-dialog-input-row" hidden>
        <span id="message-dialog-input-label">Eingabe</span>
        <input id="message-dialog-input" type="text" maxlength="4000" autocomplete="off">
      </label>
      <div class="button-row dialog-actions">
        <button type="button" id="message-dialog-cancel" class="ghost" hidden>Abbrechen</button>
        <span class="dialog-grow"></span>
        <button type="submit" id="message-dialog-ok">OK</button>
      </div>
    </form>
  </dialog>

  <dialog id="week-calendar-dialog" class="app-dialog week-calendar-dialog" aria-label="Wochenkalender">
    <div class="week-calendar-shell">
      <div class="week-calendar-header">
        <button id="week-calendar-prev" type="button" class="ghost small" aria-label="Vorheriger Monat" title="Monat zurück">‹</button>
        <select id="week-calendar-month"></select>
        <button id="week-calendar-next" type="button" class="ghost small" aria-label="Nächster Monat" title="Monat vor">›</button>
      </div>
      <table class="week-calendar-table">
        <thead>
          <tr>
            <th>KW</th>
            <th>Mo</th>
            <th>Di</th>
            <th>Mi</th>
            <th>Do</th>
            <th>Fr</th>
          </tr>
        </thead>
        <tbody id="week-calendar-grid"></tbody>
      </table>
    </div>
  </dialog>

  <script type="module">
const STORAGE_KEY = "planung-pwa-state-v1";
const DAYS_SHORT = ["Mo", "Di", "Mi", "Do", "Fr"];
const REQUIRED_HOLIDAYS = [
  "Herbstferien",
  "Weihnachtsferien",
  "Halbjahresferien",
  "Osterferien",
  "Sommerferien"
];
const HOURS_PER_DAY_DEFAULT = 8;
const ENTFALL_TOPIC_DEFAULT = "Entfall laut Plan";
const WRITTEN_EXAM_TOPIC = "Schriftliche Arbeit";
const DEFAULT_COURSE_COLOR = "#60A5FA";
const NO_LESSON_COLOR = "#787878";
const BACKUP_ENABLED_DEFAULT = true;
const BACKUP_INTERVAL_DEFAULT_DAYS = 7;
const BACKUP_INTERVAL_MIN_DAYS = 1;
const BACKUP_INTERVAL_MAX_DAYS = 30;
const SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT = false;
const WEB_BACKUP_LATEST_KEY = "planung-pwa-web-backup-latest-v1";
const BACKUP_DAY_MS = 24 * 60 * 60 * 1000;
const SYNC_META_KEY = "planung-pwa-sync-meta-v1";
const SYNC_ENVELOPE_SCHEMA = "planung-pwa-sync-v1";
const SYNC_HANDLE_DB_NAME = "planung-pwa-sync-handle-db-v1";
const SYNC_HANDLE_STORE_NAME = "handles";
const SYNC_HANDLE_FILE_KEY = "sync-file";
const SYNC_HANDLE_BACKUP_DIR_KEY = "backup-dir";
const SYNC_SAVE_DEBOUNCE_MS = 700;
const COLOR_PALETTE = [
  "#60A5FA",
  "#22D3EE",
  "#1E40AF",
  "#34D399",
  "#A3E635",
  "#FACC15",
  "#8B5E34",
  "#EA580C",
  "#F87171",
  "#B91C1C",
  "#F472B6",
  "#DB2777",
  "#A78BFA",
  "#7C3AED",
  "#4A044E"
];

function randomId() {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return `device-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
}

function hashStringFNV1a(input) {
  let hash = 0x811c9dc5;
  for (let i = 0; i < input.length; i += 1) {
    hash ^= input.charCodeAt(i);
    hash = Math.imul(hash, 0x01000193);
  }
  return (hash >>> 0).toString(16).padStart(8, "0");
}

function hashStateObject(value) {
  try {
    return hashStringFNV1a(JSON.stringify(value));
  } catch (_error) {
    return "";
  }
}

function supportsExternalFileSync() {
  return window.isSecureContext
    && (
      typeof window.showSaveFilePicker === "function"
      || typeof window.showOpenFilePicker === "function"
    )
    && typeof window.indexedDB !== "undefined";
}

function clearLegacyBrowserStorage() {
  try {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(WEB_BACKUP_LATEST_KEY);
  } catch (_error) {
  }
}

function openSyncHandleDb() {
  return new Promise((resolve, reject) => {
    if (typeof window.indexedDB === "undefined") {
      resolve(null);
      return;
    }
    const request = window.indexedDB.open(SYNC_HANDLE_DB_NAME, 1);
    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains(SYNC_HANDLE_STORE_NAME)) {
        db.createObjectStore(SYNC_HANDLE_STORE_NAME);
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error || new Error("IndexedDB nicht verfügbar."));
  });
}

async function getStoredHandle(key) {
  try {
    const db = await openSyncHandleDb();
    if (!db) {
      return null;
    }
    return await new Promise((resolve) => {
      const tx = db.transaction(SYNC_HANDLE_STORE_NAME, "readonly");
      const store = tx.objectStore(SYNC_HANDLE_STORE_NAME);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => resolve(null);
      tx.oncomplete = () => db.close();
      tx.onabort = () => db.close();
      tx.onerror = () => db.close();
    });
  } catch (_error) {
    return null;
  }
}

async function storeHandle(key, handle) {
  try {
    const db = await openSyncHandleDb();
    if (!db) {
      return false;
    }
    return await new Promise((resolve) => {
      const tx = db.transaction(SYNC_HANDLE_STORE_NAME, "readwrite");
      tx.objectStore(SYNC_HANDLE_STORE_NAME).put(handle, key);
      tx.oncomplete = () => {
        db.close();
        resolve(true);
      };
      tx.onerror = () => {
        db.close();
        resolve(false);
      };
      tx.onabort = () => {
        db.close();
        resolve(false);
      };
    });
  } catch (_error) {
    return false;
  }
}

async function clearStoredHandle(key) {
  try {
    const db = await openSyncHandleDb();
    if (!db) {
      return false;
    }
    return await new Promise((resolve) => {
      const tx = db.transaction(SYNC_HANDLE_STORE_NAME, "readwrite");
      tx.objectStore(SYNC_HANDLE_STORE_NAME).delete(key);
      tx.oncomplete = () => {
        db.close();
        resolve(true);
      };
      tx.onerror = () => {
        db.close();
        resolve(false);
      };
      tx.onabort = () => {
        db.close();
        resolve(false);
      };
    });
  } catch (_error) {
    return false;
  }
}

function normalizeSyncEnvelope(payload) {
  if (!payload || typeof payload !== "object") {
    return null;
  }
  if (payload.schema === SYNC_ENVELOPE_SCHEMA && payload.payload) {
    return {
      schema: SYNC_ENVELOPE_SCHEMA,
      revision: Math.max(0, Number(payload.revision) || 0),
      updatedAt: String(payload.updatedAt || ""),
      deviceId: String(payload.deviceId || ""),
      payload: payload.payload
    };
  }
  if (payload.schema === "planung-pwa-backup-v1" || payload.state) {
    return {
      schema: SYNC_ENVELOPE_SCHEMA,
      revision: 0,
      updatedAt: String(payload.exportedAt || ""),
      deviceId: "",
      payload
    };
  }
  if (
    Array.isArray(payload.schoolYears)
    && Array.isArray(payload.courses)
    && Array.isArray(payload.slots)
    && Array.isArray(payload.freeRanges)
    && Array.isArray(payload.specialDays)
    && Array.isArray(payload.lessons)
  ) {
    return {
      schema: SYNC_ENVELOPE_SCHEMA,
      revision: 0,
      updatedAt: "",
      deviceId: "",
      payload: {
        schema: "planung-pwa-backup-v1",
        exportedAt: "",
        state: payload
      }
    };
  }
  return null;
}

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

function parseIsoDate(iso) {
  if (!iso) {
    return null;
  }
  const [year, month, day] = String(iso).split("-").map(Number);
  if (!year || !month || !day) {
    return null;
  }
  return new Date(year, month - 1, day);
}

function toIsoDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function addDays(iso, days) {
  const value = parseIsoDate(iso);
  value.setDate(value.getDate() + days);
  return toIsoDate(value);
}

function formatDate(iso) {
  const value = parseIsoDate(iso);
  if (!value) {
    return "";
  }
  return value.toLocaleDateString("de-DE", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric"
  });
}

function dayOfWeekIso(iso) {
  const value = parseIsoDate(iso);
  const weekday = value.getDay();
  return weekday === 0 ? 7 : weekday;
}

function isSchoolWeekdayIso(iso) {
  const weekday = dayOfWeekIso(iso);
  return weekday >= 1 && weekday <= 5;
}

function normalizeIsoToSchoolWeekday(iso, direction = "forward") {
  if (!iso) {
    return iso;
  }
  let current = iso;
  const step = direction === "backward" ? -1 : 1;
  let guard = 0;
  while (!isSchoolWeekdayIso(current) && guard < 7) {
    current = addDays(current, step);
    guard += 1;
  }
  return current;
}

function weekStartFor(iso) {
  const value = parseIsoDate(iso);
  const weekday = dayOfWeekIso(iso);
  value.setDate(value.getDate() - (weekday - 1));
  return toIsoDate(value);
}

function currentWeekStartForDisplay(now = new Date()) {
  const weekday = now.getDay() === 0 ? 7 : now.getDay();
  const dateIso = toIsoDate(now);
  let start = weekStartFor(dateIso);
  if (weekday > 5 || (weekday === 5 && now.getHours() >= 18)) {
    start = addDays(start, 7);
  }
  return start;
}

function iterIsoDates(startIso, endIso, callback) {
  let current = startIso;
  while (current <= endIso) {
    callback(current);
    current = addDays(current, 1);
  }
}

function isoWeekNumber(iso) {
  const d = parseIsoDate(iso);
  const utc = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const day = utc.getUTCDay() || 7;
  utc.setUTCDate(utc.getUTCDate() + 4 - day);
  const yearStart = new Date(Date.UTC(utc.getUTCFullYear(), 0, 1));
  return Math.ceil((((utc - yearStart) / 86400000) + 1) / 7);
}

function schoolYearLabel(today = new Date()) {
  const startYear = today.getMonth() >= 6 ? today.getFullYear() : today.getFullYear() - 1;
  const endYear = startYear + 1;
  return `${startYear}/${endYear}`;
}

function easterDate(year) {
  const a = year % 19;
  const b = Math.floor(year / 100);
  const c = year % 100;
  const d = Math.floor(b / 4);
  const e = b % 4;
  const f = Math.floor((b + 8) / 25);
  const g = Math.floor((b - f + 1) / 3);
  const h = (19 * a + b - d - g + 15) % 30;
  const i = Math.floor(c / 4);
  const k = c % 4;
  const l = (32 + 2 * e + 2 * i - h - k) % 7;
  const m = Math.floor((a + 11 * h + 22 * l) / 451);
  const month = Math.floor((h + l - 7 * m + 114) / 31);
  const day = ((h + l - 7 * m + 114) % 31) + 1;
  return toIsoDate(new Date(year, month - 1, day));
}

function defaultSpecialDays(startYear) {
  const springYear = startYear + 1;
  const easter = parseIsoDate(easterDate(springYear));
  const fromEaster = (delta) => {
    const value = new Date(easter);
    value.setDate(value.getDate() + delta);
    return toIsoDate(value);
  };
  return [
    { name: "Tag der Arbeit", dayDate: toIsoDate(new Date(springYear, 4, 1)) },
    { name: "Tag der Deutschen Einheit", dayDate: toIsoDate(new Date(startYear, 9, 3)) },
    { name: "Karfreitag", dayDate: fromEaster(-2) },
    { name: "Ostermontag", dayDate: fromEaster(1) },
    { name: "Christi Himmelfahrt", dayDate: fromEaster(39) },
    { name: "Tag nach Himmelfahrt", dayDate: fromEaster(40) },
    { name: "Pfingstdienstag", dayDate: fromEaster(51) },
    { name: "Pfingstmontag", dayDate: fromEaster(50) },
    { name: "Reformationstag", dayDate: toIsoDate(new Date(startYear, 9, 31)) }
  ].sort((a, b) => a.dayDate.localeCompare(b.dayDate));
}

function defaultSpecialDayDateForName(name, startYear) {
  const cleanName = String(name || "").trim().toLowerCase();
  if (!cleanName) {
    return null;
  }
  const match = defaultSpecialDays(Number(startYear)).find(
    (item) => String(item.name || "").trim().toLowerCase() === cleanName
  );
  return match ? match.dayDate : null;
}

function defaultHolidayRangesForYear(startYear) {
  const year = Number(startYear);
  if (year === 2024) {
    return {
      Sommerferien: ["2024-06-24", "2024-08-02"],
      Herbstferien: ["2024-10-04", "2024-10-19"],
      Weihnachtsferien: ["2024-12-23", "2025-01-04"],
      Halbjahresferien: ["2025-02-03", "2025-02-04"],
      Osterferien: ["2025-04-07", "2025-04-19"]
    };
  }
  if (year === 2025) {
    return {
      Sommerferien: ["2025-07-03", "2025-08-13"],
      Herbstferien: ["2025-10-13", "2025-10-25"],
      Weihnachtsferien: ["2025-12-22", "2026-01-05"],
      Halbjahresferien: ["2026-02-02", "2026-02-03"],
      Osterferien: ["2026-03-23", "2026-04-07"]
    };
  }
  if (year === 2026) {
    return {
      Sommerferien: ["2026-07-02", "2026-08-12"],
      Herbstferien: ["2026-10-12", "2026-10-24"],
      Weihnachtsferien: ["2026-12-23", "2027-01-09"],
      Halbjahresferien: ["2027-02-01", "2027-02-02"],
      Osterferien: ["2027-03-22", "2027-04-03"]
    };
  }
  if (year === 2027) {
    return {
      Sommerferien: ["2027-07-08", "2027-08-18"],
      Herbstferien: ["2027-10-16", "2027-10-30"],
      Weihnachtsferien: ["2027-12-23", "2028-01-08"],
      Halbjahresferien: ["2028-01-31", "2028-02-01"],
      Osterferien: ["2028-04-10", "2028-04-22"]
    };
  }
  if (year === 2028) {
    return {
      Sommerferien: ["2028-07-20", "2028-08-30"],
      Herbstferien: ["2028-10-23", "2028-11-04"],
      Weihnachtsferien: ["2028-12-27", "2029-01-06"],
      Halbjahresferien: ["2029-02-01", "2029-02-02"],
      Osterferien: ["2029-03-19", "2029-04-03"]
    };
  }
  if (year === 2029) {
    return {
      Sommerferien: ["2029-07-19", "2029-08-29"],
      Herbstferien: ["2029-10-22", "2029-11-02"],
      Weihnachtsferien: ["2029-12-21", "2030-01-05"],
      Halbjahresferien: ["2030-01-31", "2030-02-01"],
      Osterferien: ["2030-04-08", "2030-04-23"]
    };
  }
  if (year === 2030) {
    return {
      Sommerferien: ["2030-07-11", "2030-08-21"]
    };
  }
  return {};
}

function requiredHolidayRowSpecs() {
  return [
    { label: "Sommerferien", occurrence: 0 },
    { label: "Herbstferien", occurrence: 0 },
    { label: "Weihnachtsferien", occurrence: 0 },
    { label: "Halbjahresferien", occurrence: 0 },
    { label: "Osterferien", occurrence: 0 },
    { label: "Sommerferien", occurrence: 1 }
  ];
}

function _requiredHolidayRowsByLabel(ranges) {
  const byLabel = new Map();
  for (const item of ranges || []) {
    const normalized = String(item && item.label ? item.label : "").trim().toLowerCase();
    if (!normalized) {
      continue;
    }
    if (!byLabel.has(normalized)) {
      byLabel.set(normalized, []);
    }
    byLabel.get(normalized).push(item);
  }
  for (const rows of byLabel.values()) {
    rows.sort((a, b) =>
      String(a.startDate || a.endDate || "").localeCompare(String(b.startDate || b.endDate || ""))
    );
  }
  return byLabel;
}

function computeRequiredHolidayMissingDetails(ranges) {
  const details = [];
  const byLabel = _requiredHolidayRowsByLabel(ranges);
  for (const spec of requiredHolidayRowSpecs()) {
    const normalized = String(spec.label || "").toLowerCase();
    const rows = byLabel.get(normalized) || [];
    const row = rows[Number(spec.occurrence) || 0] || null;
    if (normalized === "sommerferien") {
      if (Number(spec.occurrence) === 0) {
        if (!row || !row.endDate) {
          details.push("Sommerferien oben: Enddatum fehlt");
        }
      } else if (!row || !row.startDate) {
        details.push("Sommerferien unten: Startdatum fehlt");
      }
      continue;
    }
    if (!row || !row.startDate || !row.endDate) {
      details.push(`${spec.label}: Start- oder Enddatum fehlt`);
    }
  }
  return details;
}

function computeRequiredHolidayMissingLabels(ranges) {
  const missing = new Set();
  const details = computeRequiredHolidayMissingDetails(ranges);
  for (const detail of details) {
    const text = String(detail || "");
    if (text.toLowerCase().startsWith("sommerferien")) {
      missing.add("Sommerferien");
    } else {
      const [label] = text.split(":");
      if (label) {
        missing.add(label.trim());
      }
    }
  }
  return [...missing];
}

function defaultHolidayRangeForRow(startYear, label, occurrence = 0) {
  const currentDefaults = defaultHolidayRangesForYear(startYear);
  if (String(label || "").toLowerCase() !== "sommerferien") {
    const range = currentDefaults[label];
    if (!Array.isArray(range) || range.length !== 2) {
      return [null, null];
    }
    return [range[0] || null, range[1] || null];
  }

  if (occurrence === 0) {
    const currentSummer = currentDefaults.Sommerferien;
    if (!Array.isArray(currentSummer) || currentSummer.length !== 2) {
      return [null, null];
    }
    return [currentSummer[0] || null, currentSummer[1] || null];
  }
  if (occurrence === 1) {
    const nextDefaults = defaultHolidayRangesForYear(Number(startYear) + 1);
    const nextSummer = nextDefaults.Sommerferien;
    if (!Array.isArray(nextSummer) || nextSummer.length !== 2) {
      return [null, null];
    }
    return [nextSummer[0] || null, nextSummer[1] || null];
  }

  const fallback = currentDefaults.Sommerferien;
  if (!Array.isArray(fallback) || fallback.length !== 2) {
    return [null, null];
  }
  return [fallback[0] || null, fallback[1] || null];
}

function overrideTopicForFlags(topic, isEntfall, isWrittenExam) {
  const text = String(topic || "").trim();
  const lowered = text.toLowerCase();
  if (isEntfall) {
    return lowered.startsWith("entfall") ? text : ENTFALL_TOPIC_DEFAULT;
  }
  if (isWrittenExam) {
    return lowered.startsWith(WRITTEN_EXAM_TOPIC.toLowerCase()) ? text : WRITTEN_EXAM_TOPIC;
  }
  return text;
}

function isoInDateRange(targetIso, startIso, endIso) {
  if (!targetIso || !startIso || !endIso) {
    return false;
  }
  if (startIso <= endIso) {
    return targetIso >= startIso && targetIso <= endIso;
  }
  return targetIso >= startIso || targetIso <= endIso;
}

function suggestColor(existingColors) {
  const existing = new Set(
    existingColors
      .map((item) => canonicalHexColor(item))
      .filter(Boolean)
      .map((item) => item.toLowerCase())
  );
  for (const color of COLOR_PALETTE) {
    const normalized = normalizeHexColor(color, DEFAULT_COURSE_COLOR);
    if (!existing.has(normalized.toLowerCase())) {
      return normalized;
    }
  }
  return normalizeHexColor(
    COLOR_PALETTE[existing.size % COLOR_PALETTE.length],
    DEFAULT_COURSE_COLOR
  );
}

function canonicalHexColor(color) {
  const value = String(color || "").trim();
  const match = value.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if (!match) {
    return null;
  }
  const hex = match[1].toUpperCase();
  if (hex.length === 3) {
    return `#${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`;
  }
  return `#${hex}`;
}

function normalizeHexColor(color, fallback = DEFAULT_COURSE_COLOR) {
  const normalized = canonicalHexColor(color);
  if (normalized) {
    return normalized;
  }
  const fallbackColor = canonicalHexColor(fallback);
  return fallbackColor || DEFAULT_COURSE_COLOR;
}

function normalizeCourseColor(color, noLesson = false) {
  if (noLesson) {
    return NO_LESSON_COLOR;
  }
  return normalizeHexColor(color, DEFAULT_COURSE_COLOR);
}

function hexToRgb(color) {
  const normalized = canonicalHexColor(color);
  if (!normalized) {
    return null;
  }
  const hex = normalized.slice(1);
  return {
    r: parseInt(hex.slice(0, 2), 16),
    g: parseInt(hex.slice(2, 4), 16),
    b: parseInt(hex.slice(4, 6), 16)
  };
}

function colorToRgba(color, alpha) {
  const rgb = hexToRgb(color) || hexToRgb(DEFAULT_COURSE_COLOR);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${clamp(Number(alpha) || 1, 0, 1)})`;
}

function lightenHex(color, amount = 0.1) {
  const rgb = hexToRgb(color) || hexToRgb(DEFAULT_COURSE_COLOR);
  const factor = clamp(Number(amount) || 0, 0, 1);
  const blend = (value) => Math.round(value + ((255 - value) * factor));
  const r = blend(rgb.r);
  const g = blend(rgb.g);
  const b = blend(rgb.b);
  const toHex = (value) => value.toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function readableTextColor(color) {
  const rgb = hexToRgb(color) || hexToRgb(DEFAULT_COURSE_COLOR);
  const luminance = ((0.2126 * rgb.r) + (0.7152 * rgb.g) + (0.0722 * rgb.b)) / 255;
  return luminance > 0.62 ? "#0f1216" : "#f8fafc";
}

function formatPartialDisplay(text, partial) {
  const value = String(text || "").trim();
  if (!partial) {
    return value;
  }
  if (!value) {
    return "(teilweise entfaellt)";
  }
  return `${value}\n(teilweise entfaellt)`;
}

function createInitialState() {
  return {
    version: 1,
    counters: {
      schoolYear: 1,
      course: 1,
      slot: 1,
      freeRange: 1,
      specialDay: 1,
      lesson: 1
    },
    settings: {
      activeSchoolYearId: null,
      hoursPerDay: HOURS_PER_DAY_DEFAULT,
      showHiddenSidebarCourses: SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT,
      backupEnabled: BACKUP_ENABLED_DEFAULT,
      backupIntervalDays: BACKUP_INTERVAL_DEFAULT_DAYS,
      lastAutoBackupAt: null,
      lastWebBackupAt: null,
      lastWebBackupMode: null
    },
    schoolYears: [],
    courses: [],
    slots: [],
    freeRanges: [],
    specialDays: [],
    lessons: []
  };
}

class PlannerStore {
  constructor() {
    this.onAfterSave = null;
    this.state = this._load();
    this.normalizeCourseColors();
    this.ensureDefaultSchoolYear();
    for (const year of this.state.schoolYears) {
      const startYear = Number(String(year.startDate).slice(0, 4));
      this.seedHolidayDefaults(year.id, startYear);
    }
    const active = this.getActiveSchoolYear();
    if (active && this.state.specialDays.length === 0) {
      const startYear = Number(String(active.startDate).slice(0, 4));
      this.resetSpecialDays(startYear);
    }
    this._save();
  }

  _load() {
    return createInitialState();
  }

  _save() {
    if (typeof this.onAfterSave === "function") {
      try {
        this.onAfterSave(this.state);
      } catch (_error) {
      }
    }
  }

  setAfterSaveHook(handler) {
    this.onAfterSave = typeof handler === "function" ? handler : null;
  }

  _nextId(type) {
    const value = this.state.counters[type] || 1;
    this.state.counters[type] = value + 1;
    return value;
  }

  normalizeCourseColors() {
    if (!Array.isArray(this.state.courses)) {
      return;
    }
    for (const course of this.state.courses) {
      if (!course || typeof course !== "object") {
        continue;
      }
      const isNoLesson = Boolean(course.noLesson);
      course.noLesson = isNoLesson;
      course.hiddenInSidebar = Boolean(course.hiddenInSidebar);
      course.color = normalizeCourseColor(course.color, isNoLesson);
    }
  }

  seedHolidayDefaults(schoolYearId, startYear) {
    const yearId = Number(schoolYearId);
    if (!yearId) {
      return;
    }
    const byLabel = new Map();
    for (const item of this.state.freeRanges.filter((row) => Number(row.schoolYearId) === yearId)) {
      const normalized = String(item.label || "").trim().toLowerCase();
      if (!byLabel.has(normalized)) {
        byLabel.set(normalized, []);
      }
      byLabel.get(normalized).push(item);
    }
    for (const rows of byLabel.values()) {
      rows.sort((a, b) => String(a.startDate || a.endDate || "").localeCompare(String(b.startDate || b.endDate || "")));
    }

    let changed = false;
    for (const spec of requiredHolidayRowSpecs()) {
      const label = spec.label;
      const rows = byLabel.get(label.toLowerCase()) || [];
      if (rows[spec.occurrence]) {
        continue;
      }
      const [startDate, endDate] = defaultHolidayRangeForRow(startYear, label, spec.occurrence);
      if (!startDate && !endDate) {
        continue;
      }
      this.state.freeRanges.push({
        id: this._nextId("freeRange"),
        schoolYearId: yearId,
        label,
        startDate,
        endDate
      });
      changed = true;
    }
    if (changed) {
      this.applyDayOffs(yearId);
    }
  }

  getSetting(key, fallback = null) {
    const value = this.state.settings[key];
    return value === undefined || value === null ? fallback : value;
  }

  setSetting(key, value) {
    this.state.settings[key] = value;
    this._save();
  }

  getHoursPerDay() {
    const value = Number(this.getSetting("hoursPerDay", HOURS_PER_DAY_DEFAULT));
    return clamp(Number.isNaN(value) ? HOURS_PER_DAY_DEFAULT : value, 1, 12);
  }

  setHoursPerDay(value) {
    const hours = clamp(Number(value) || HOURS_PER_DAY_DEFAULT, 1, 12);
    this.state.settings.hoursPerDay = hours;
    const active = this.getActiveSchoolYear();
    if (active) {
      this.generateLessonsForYear(active.id);
    }
    this._save();
    return hours;
  }

  getBackupEnabled() {
    const value = this.getSetting("backupEnabled", BACKUP_ENABLED_DEFAULT);
    if (typeof value === "string") {
      return !["0", "false", "off", "no"].includes(value.trim().toLowerCase());
    }
    return Boolean(value);
  }

  setBackupEnabled(enabled) {
    this.state.settings.backupEnabled = Boolean(enabled);
    this._save();
    return this.getBackupEnabled();
  }

  getBackupIntervalDays() {
    const raw = Number(this.getSetting("backupIntervalDays", BACKUP_INTERVAL_DEFAULT_DAYS));
    const value = Number.isNaN(raw) ? BACKUP_INTERVAL_DEFAULT_DAYS : raw;
    return clamp(value, BACKUP_INTERVAL_MIN_DAYS, BACKUP_INTERVAL_MAX_DAYS);
  }

  setBackupIntervalDays(days) {
    const value = clamp(
      Number(days) || BACKUP_INTERVAL_DEFAULT_DAYS,
      BACKUP_INTERVAL_MIN_DAYS,
      BACKUP_INTERVAL_MAX_DAYS
    );
    this.state.settings.backupIntervalDays = value;
    this._save();
    return value;
  }

  getLastAutoBackupAt() {
    const value = this.getSetting("lastAutoBackupAt", null);
    return value ? String(value) : null;
  }

  setLastAutoBackupAt(isoDateTime) {
    this.state.settings.lastAutoBackupAt = isoDateTime ? String(isoDateTime) : null;
    this._save();
  }

  setLastWebBackupMeta(createdAt, mode) {
    this.state.settings.lastWebBackupAt = createdAt ? String(createdAt) : null;
    this.state.settings.lastWebBackupMode = mode ? String(mode) : null;
    this._save();
  }

  listSchoolYears() {
    return [...this.state.schoolYears].sort((a, b) => a.startDate.localeCompare(b.startDate));
  }

  getSchoolYear(id) {
    return this.state.schoolYears.find((item) => item.id === Number(id)) || null;
  }

  getSchoolYearForDate(isoDate) {
    const sorted = [...this.state.schoolYears].sort((a, b) => b.startDate.localeCompare(a.startDate));
    return sorted.find((item) => item.startDate <= isoDate && item.endDate >= isoDate) || null;
  }

  getLatestSchoolYear() {
    const sorted = [...this.state.schoolYears].sort((a, b) => b.startDate.localeCompare(a.startDate));
    return sorted[0] || null;
  }

  ensureDefaultSchoolYear() {
    if (this.state.schoolYears.length > 0) {
      const active = this.getActiveSchoolYear();
      if (!active) {
        const latest = this.getLatestSchoolYear();
        if (latest) {
          this.state.settings.activeSchoolYearId = latest.id;
          this._save();
        }
      }
      return null;
    }
    const now = new Date();
    const startYear = now.getMonth() >= 6 ? now.getFullYear() : now.getFullYear() - 1;
    const startDate = `${startYear}-08-01`;
    const endDate = `${startYear + 1}-07-31`;
    const year = {
      id: this._nextId("schoolYear"),
      name: `${startYear}/${startYear + 1}`,
      startDate,
      endDate
    };
    this.state.schoolYears.push(year);
    this.state.settings.activeSchoolYearId = year.id;
    this._save();
    return year;
  }

  createSchoolYear(startYear) {
    const year = Number(startYear);
    if (!year || Number.isNaN(year)) {
      return null;
    }
    const startDate = `${year}-08-01`;
    const endDate = `${year + 1}-07-31`;
    const existing = this.state.schoolYears.find((item) => item.startDate === startDate);
    if (existing) {
      return null;
    }
    const created = {
      id: this._nextId("schoolYear"),
      name: `${year}/${year + 1}`,
      startDate,
      endDate
    };
    this.state.schoolYears.push(created);
    this.state.settings.activeSchoolYearId = created.id;
    this.seedHolidayDefaults(created.id, year);
    this._save();
    return created;
  }

  getActiveSchoolYear() {
    const stored = Number(this.getSetting("activeSchoolYearId"));
    if (stored) {
      const found = this.getSchoolYear(stored);
      if (found) {
        return found;
      }
    }
    const forToday = this.getSchoolYearForDate(toIsoDate(new Date()));
    if (forToday) {
      return forToday;
    }
    return this.getLatestSchoolYear();
  }

  setActiveSchoolYear(schoolYearId) {
    const year = this.getSchoolYear(schoolYearId);
    if (year) {
      this.state.settings.activeSchoolYearId = year.id;
      this._save();
    }
    return year;
  }

  listCourses(schoolYearId) {
    const yearId = Number(schoolYearId);
    return this.state.courses
      .filter((item) => item.schoolYearId === yearId)
      .sort((a, b) => {
        const orderA = Number(a.sortOrder || 0);
        const orderB = Number(b.sortOrder || 0);
        if (orderA !== orderB) {
          return orderA - orderB;
        }
        return String(a.name).localeCompare(String(b.name), "de");
      });
  }

  createCourse(schoolYearId, name, color, noLesson = false) {
    const yearId = Number(schoolYearId);
    const cleanName = String(name || "").trim();
    if (!cleanName) {
      return null;
    }
    const duplicate = this.state.courses.find(
      (item) => item.schoolYearId === yearId && item.name === cleanName
    );
    if (duplicate) {
      return null;
    }
    const courseNoLesson = Boolean(noLesson);
    const existingColors = this.listCourses(yearId).map((item) => item.color);
    const resolvedColor = courseNoLesson
      ? NO_LESSON_COLOR
      : (color || suggestColor(existingColors));
    const course = {
      id: this._nextId("course"),
      schoolYearId: yearId,
      name: cleanName,
      color: normalizeCourseColor(resolvedColor, courseNoLesson),
      noLesson: courseNoLesson,
      hiddenInSidebar: false,
      sortOrder: this.listCourses(yearId).length + 1
    };
    this.state.courses.push(course);
    this.generateLessonsForYear(yearId);
    this._save();
    return course.id;
  }

  updateCourse(schoolYearId, courseId, name, color, noLesson = false) {
    const yearId = Number(schoolYearId);
    const id = Number(courseId);
    const cleanName = String(name || "").trim();
    const duplicate = this.state.courses.find(
      (item) => item.schoolYearId === yearId && item.id !== id && item.name === cleanName
    );
    if (duplicate) {
      return false;
    }
    const course = this.state.courses.find((item) => item.id === id);
    if (!course) {
      return false;
    }
    const courseNoLesson = Boolean(noLesson);
    course.name = cleanName;
    course.noLesson = courseNoLesson;
    course.hiddenInSidebar = Boolean(course.hiddenInSidebar);
    course.color = normalizeCourseColor(color || course.color, courseNoLesson);
    this._save();
    return true;
  }

  setCourseSidebarHidden(schoolYearId, courseId, hiddenInSidebar = true) {
    const yearId = Number(schoolYearId);
    const id = Number(courseId);
    const course = this.state.courses.find((item) => item.id === id && item.schoolYearId === yearId);
    if (!course) {
      return false;
    }
    course.hiddenInSidebar = Boolean(hiddenInSidebar);
    this._save();
    return true;
  }

  updateCourseOrder(schoolYearId, orderedIds) {
    const yearId = Number(schoolYearId);
    const normalized = orderedIds.map((id) => Number(id)).filter((id) => id > 0);
    if (normalized.length === 0) {
      return;
    }
    const orderMap = new Map();
    normalized.forEach((id, index) => {
      orderMap.set(id, index + 1);
    });

    let nextOrder = normalized.length + 1;
    for (const course of this.state.courses) {
      if (course.schoolYearId !== yearId) {
        continue;
      }
      if (orderMap.has(course.id)) {
        course.sortOrder = orderMap.get(course.id);
      } else {
        course.sortOrder = nextOrder;
        nextOrder += 1;
      }
    }
    this._save();
  }

  deleteCourse(courseId) {
    const id = Number(courseId);
    const course = this.state.courses.find((item) => item.id === id);
    if (!course) {
      return;
    }
    const slotIds = new Set(this.state.slots.filter((slot) => slot.courseId === id).map((slot) => slot.id));
    this.state.courses = this.state.courses.filter((item) => item.id !== id);
    this.state.slots = this.state.slots.filter((slot) => slot.courseId !== id);
    this.state.lessons = this.state.lessons.filter(
      (lesson) => lesson.courseId !== id && !slotIds.has(lesson.slotId)
    );
    this._save();
  }

  listSlotsForYear(schoolYearId) {
    const yearId = Number(schoolYearId);
    const courseIds = new Set(this.listCourses(yearId).map((item) => item.id));
    return this.state.slots
      .filter((slot) => courseIds.has(slot.courseId))
      .sort((a, b) => {
        if (a.dayOfWeek !== b.dayOfWeek) {
          return a.dayOfWeek - b.dayOfWeek;
        }
        return a.startHour - b.startHour;
      });
  }

  getSlot(slotId) {
    return this.state.slots.find((item) => item.id === Number(slotId)) || null;
  }

  createSlot(courseId, dayOfWeek, startHour, duration, startDate = null, endDate = null, weekParity = 0) {
    const course = this.state.courses.find((item) => item.id === Number(courseId));
    if (!course) {
      return null;
    }
    const slot = {
      id: this._nextId("slot"),
      courseId: course.id,
      dayOfWeek: Number(dayOfWeek),
      startHour: Number(startHour),
      duration: Math.max(1, Number(duration)),
      startDate: startDate || null,
      endDate: endDate || null,
      weekParity: Number(weekParity) || 0
    };
    this.state.slots.push(slot);
    this.generateLessonsForYear(course.schoolYearId);
    this._save();
    return slot.id;
  }

  updateSlot(slotId, courseId, dayOfWeek, startHour, duration, startDate = null, endDate = null, weekParity = 0) {
    const slot = this.getSlot(slotId);
    const targetCourse = this.state.courses.find((item) => item.id === Number(courseId));
    if (!slot || !targetCourse) {
      return false;
    }
    const oldCourse = this.state.courses.find((item) => item.id === slot.courseId);
    slot.courseId = targetCourse.id;
    slot.dayOfWeek = Number(dayOfWeek);
    slot.startHour = Number(startHour);
    slot.duration = Math.max(1, Number(duration));
    slot.startDate = startDate || null;
    slot.endDate = endDate || null;
    slot.weekParity = Number(weekParity) || 0;

    if (oldCourse) {
      this.generateLessonsForYear(oldCourse.schoolYearId);
    }
    this.generateLessonsForYear(targetCourse.schoolYearId);
    this._save();
    return true;
  }

  deleteSlot(slotId) {
    const slot = this.getSlot(slotId);
    if (!slot) {
      return;
    }
    const course = this.state.courses.find((item) => item.id === slot.courseId);
    this.state.slots = this.state.slots.filter((item) => item.id !== slot.id);
    this.state.lessons = this.state.lessons.filter((item) => item.slotId !== slot.id);
    if (course) {
      this.generateLessonsForYear(course.schoolYearId);
    }
    this._save();
  }

  _slotParityMatches(parity, dayIso) {
    if (Number(parity) === 1) {
      return isoWeekNumber(dayIso) % 2 === 1;
    }
    if (Number(parity) === 2) {
      return isoWeekNumber(dayIso) % 2 === 0;
    }
    return true;
  }

  _slotDatesOverlap(parityA, parityB, startIso, endIso, dayOfWeek) {
    if (!startIso || !endIso || !dayOfWeek) {
      return false;
    }
    const offset = (Number(dayOfWeek) - dayOfWeekIso(startIso) + 7) % 7;
    let current = addDays(startIso, offset);
    while (current <= endIso) {
      if (this._slotParityMatches(parityA, current) && this._slotParityMatches(parityB, current)) {
        return true;
      }
      current = addDays(current, 7);
    }
    return false;
  }

  findSlotConflicts(
    schoolYearId,
    courseId,
    dayOfWeek,
    startHour,
    duration,
    startDate = null,
    endDate = null,
    weekParity = 0,
    excludeSlotId = null
  ) {
    const year = this.getSchoolYear(schoolYearId);
    if (!year) {
      return [];
    }
    const yearStart = year.startDate;
    const yearEnd = year.endDate;
    let candidateStart = startDate || yearStart;
    let candidateEnd = endDate || yearEnd;
    if (candidateStart < yearStart) {
      candidateStart = yearStart;
    }
    if (candidateEnd > yearEnd) {
      candidateEnd = yearEnd;
    }
    if (candidateEnd < candidateStart) {
      return [];
    }
    const beginHour = Number(startHour);
    const endHour = beginHour + Math.max(1, Number(duration)) - 1;

    const slots = this.listSlotsForYear(schoolYearId);
    const conflicts = [];
    for (const slot of slots) {
      if (excludeSlotId && slot.id === Number(excludeSlotId)) {
        continue;
      }
      if (Number(slot.dayOfWeek) !== Number(dayOfWeek)) {
        continue;
      }
      const slotBegin = Number(slot.startHour);
      const slotEnd = slotBegin + Math.max(1, Number(slot.duration)) - 1;
      if (endHour < slotBegin || slotEnd < beginHour) {
        continue;
      }
      let slotStart = slot.startDate || yearStart;
      let slotEndDate = slot.endDate || yearEnd;
      if (slotStart < yearStart) {
        slotStart = yearStart;
      }
      if (slotEndDate > yearEnd) {
        slotEndDate = yearEnd;
      }
      const overlapStart = slotStart > candidateStart ? slotStart : candidateStart;
      const overlapEnd = slotEndDate < candidateEnd ? slotEndDate : candidateEnd;
      if (overlapEnd < overlapStart) {
        continue;
      }
      if (
        this._slotDatesOverlap(
          Number(weekParity),
          Number(slot.weekParity || 0),
          overlapStart,
          overlapEnd,
          dayOfWeek
        )
      ) {
        const c = this.state.courses.find((item) => item.id === slot.courseId);
        conflicts.push({ ...slot, courseName: c ? c.name : `Kurs ${slot.courseId}` });
      }
    }
    return conflicts;
  }

  listFreeRanges(schoolYearId) {
    const order = new Map(REQUIRED_HOLIDAYS.map((label, index) => [label.toLowerCase(), index]));
    return this.state.freeRanges
      .filter((item) => item.schoolYearId === Number(schoolYearId))
      .sort((a, b) => {
        const labelA = String(a.label || "").trim().toLowerCase();
        const labelB = String(b.label || "").trim().toLowerCase();
        const orderA = order.has(labelA) ? order.get(labelA) : 999;
        const orderB = order.has(labelB) ? order.get(labelB) : 999;
        if (orderA !== orderB) {
          return orderA - orderB;
        }
        if (a.startDate !== b.startDate) {
          return a.startDate.localeCompare(b.startDate);
        }
        return String(a.label || "").localeCompare(String(b.label || ""), "de");
      });
  }

  upsertFreeRange(id, schoolYearId, label, startDate, endDate) {
    const cleanLabel = String(label || "").trim();
    const yearId = Number(schoolYearId);
    const normalized = cleanLabel.toLowerCase();
    const isSummerHoliday = normalized === "sommerferien";
    const hasDates = Boolean(startDate) && Boolean(endDate);
    const hasSummerPartial = isSummerHoliday && (Boolean(startDate) || Boolean(endDate));
    if (!cleanLabel || !yearId || (!hasDates && !hasSummerPartial)) {
      return null;
    }
    if (id) {
      const row = this.state.freeRanges.find((item) => item.id === Number(id));
      if (!row) {
        return null;
      }
      if (!isSummerHoliday) {
        const existing = this.state.freeRanges.find(
          (item) =>
            Number(item.schoolYearId) === yearId &&
            item.id !== Number(id) &&
            String(item.label || "").trim().toLowerCase() === normalized
        );
        if (existing) {
          existing.label = cleanLabel;
          existing.startDate = startDate;
          existing.endDate = endDate;
          this.state.freeRanges = this.state.freeRanges.filter((item) => item.id !== Number(id));
        } else {
          row.label = cleanLabel;
          row.startDate = startDate;
          row.endDate = endDate;
        }
      } else {
        row.label = cleanLabel;
        row.startDate = startDate;
        row.endDate = endDate;
      }
    } else {
      if (!isSummerHoliday) {
        const existing = this.state.freeRanges.find(
          (item) =>
            Number(item.schoolYearId) === yearId &&
            String(item.label || "").trim().toLowerCase() === normalized
        );
        if (existing) {
          existing.label = cleanLabel;
          existing.startDate = startDate;
          existing.endDate = endDate;
        } else {
          this.state.freeRanges.push({
            id: this._nextId("freeRange"),
            schoolYearId: yearId,
            label: cleanLabel,
            startDate,
            endDate
          });
        }
      } else {
        this.state.freeRanges.push({
          id: this._nextId("freeRange"),
          schoolYearId: yearId,
          label: cleanLabel,
          startDate,
          endDate
        });
      }
    }
    this.applyDayOffs(yearId);
    this._save();
    return true;
  }

  deleteFreeRange(id) {
    const row = this.state.freeRanges.find((item) => item.id === Number(id));
    if (!row) {
      return;
    }
    this.state.freeRanges = this.state.freeRanges.filter((item) => item.id !== Number(id));
    this.applyDayOffs(row.schoolYearId);
    this._save();
  }

  applyHolidayDefaultsForYear(schoolYearId, overwrite = false) {
    const year = this.getSchoolYear(schoolYearId);
    if (!year) {
      return { ok: false, changed: false };
    }
    const startYear = Number(String(year.startDate).slice(0, 4));
    const yearId = Number(year.id);
    const specs = requiredHolidayRowSpecs();
    let changed = false;
    const allYearRows = this.state.freeRanges.filter((item) => Number(item.schoolYearId) === yearId);
    const byLabel = new Map();
    for (const item of allYearRows) {
      const normalized = String(item.label || "").trim().toLowerCase();
      if (!byLabel.has(normalized)) {
        byLabel.set(normalized, []);
      }
      byLabel.get(normalized).push(item);
    }
    for (const rows of byLabel.values()) {
      rows.sort((a, b) => String(a.startDate || a.endDate || "").localeCompare(String(b.startDate || b.endDate || "")));
    }

    for (const spec of specs) {
      const label = spec.label;
      const [startDate, endDate] = defaultHolidayRangeForRow(startYear, label, spec.occurrence);
      if (!startDate && !endDate) {
        continue;
      }
      const matches = byLabel.get(label.toLowerCase()) || [];
      const existing = matches[spec.occurrence] || null;
      if (existing) {
        existing.label = label;
        if (!overwrite) {
          continue;
        }
        if (existing.startDate === startDate && existing.endDate === endDate) {
          continue;
        }
        existing.startDate = startDate;
        existing.endDate = endDate;
        changed = true;
        continue;
      }
      const created = {
        id: this._nextId("freeRange"),
        schoolYearId: yearId,
        label,
        startDate,
        endDate
      };
      this.state.freeRanges.push(created);
      if (!byLabel.has(label.toLowerCase())) {
        byLabel.set(label.toLowerCase(), []);
      }
      byLabel.get(label.toLowerCase()).push(created);
      byLabel.get(label.toLowerCase()).sort(
        (a, b) => String(a.startDate || a.endDate || "").localeCompare(String(b.startDate || b.endDate || ""))
      );
      changed = true;
    }

    const expectedCountByLabel = new Map();
    for (const spec of specs) {
      const key = spec.label.toLowerCase();
      expectedCountByLabel.set(key, (expectedCountByLabel.get(key) || 0) + 1);
    }
    for (const [label, count] of expectedCountByLabel.entries()) {
      const rows = (byLabel.get(label) || []).slice().sort(
        (a, b) => String(a.startDate || a.endDate || "").localeCompare(String(b.startDate || b.endDate || ""))
      );
      if (rows.length <= count) {
        continue;
      }
      const removeIds = new Set(rows.slice(count).map((item) => item.id));
      this.state.freeRanges = this.state.freeRanges.filter((item) => !removeIds.has(item.id));
      changed = true;
    }
    if (changed) {
      this.applyDayOffs(yearId);
      this._save();
    }
    return { ok: true, changed };
  }

  listSpecialDays() {
    return [...this.state.specialDays].sort((a, b) => a.dayDate.localeCompare(b.dayDate));
  }

  upsertSpecialDay(id, name, dayDate) {
    const cleanName = String(name || "").trim();
    if (!cleanName || !dayDate) {
      return false;
    }
    const normalizedName = cleanName.toLowerCase();
    const duplicate = this.state.specialDays.find(
      (item) => String(item.name || "").trim().toLowerCase() === normalizedName && item.id !== Number(id)
    );
    if (duplicate) {
      return false;
    }
    if (id) {
      const row = this.state.specialDays.find((item) => item.id === Number(id));
      if (!row) {
        return false;
      }
      row.name = cleanName;
      row.dayDate = dayDate;
    } else {
      this.state.specialDays.push({
        id: this._nextId("specialDay"),
        name: cleanName,
        dayDate
      });
    }
    this.reapplyDayOffsAllYears();
    this._save();
    return true;
  }

  deleteSpecialDay(id) {
    this.state.specialDays = this.state.specialDays.filter((item) => item.id !== Number(id));
    this.reapplyDayOffsAllYears();
    this._save();
  }

  resetSpecialDays(startYear) {
    this.state.specialDays = [];
    for (const item of defaultSpecialDays(Number(startYear))) {
      this.state.specialDays.push({
        id: this._nextId("specialDay"),
        name: item.name,
        dayDate: item.dayDate
      });
    }
    this.reapplyDayOffsAllYears();
    this._save();
  }

  reapplyDayOffsAllYears() {
    const yearIds = new Set(this.state.schoolYears.map((item) => item.id));
    for (const yearId of yearIds) {
      this.applyDayOffs(yearId);
    }
  }

  generateLessonsForYear(schoolYearId) {
    const yearId = Number(schoolYearId);
    const year = this.getSchoolYear(yearId);
    if (!year) {
      return;
    }
    const slots = this.listSlotsForYear(yearId);
    const previous = this.state.lessons.filter((item) => item.schoolYearId === yearId);
    const previousByKey = new Map(previous.map((item) => [`${item.slotId}|${item.lessonDate}|${item.hour}`, item]));
    const hoursPerDay = this.getHoursPerDay();

    const byDay = new Map();
    for (const slot of slots) {
      const key = Number(slot.dayOfWeek);
      if (!byDay.has(key)) {
        byDay.set(key, []);
      }
      byDay.get(key).push(slot);
    }

    const generated = [];
    iterIsoDates(year.startDate, year.endDate, (currentDate) => {
      const day = dayOfWeekIso(currentDate);
      if (day > 5) {
        return;
      }
      const daySlots = byDay.get(day) || [];
      for (const slot of daySlots) {
        if (slot.startDate && currentDate < slot.startDate) {
          continue;
        }
        if (slot.endDate && currentDate > slot.endDate) {
          continue;
        }
        if (!this._slotParityMatches(slot.weekParity, currentDate)) {
          continue;
        }
        for (let offset = 0; offset < Number(slot.duration); offset += 1) {
          const hour = Number(slot.startHour) + offset;
          if (hour > hoursPerDay) {
            continue;
          }
          const key = `${slot.id}|${currentDate}|${hour}`;
          const old = previousByKey.get(key);
          generated.push({
            id: old ? old.id : this._nextId("lesson"),
            schoolYearId: yearId,
            slotId: slot.id,
            courseId: slot.courseId,
            lessonDate: currentDate,
            dayOfWeek: day,
            hour,
            topic: old ? old.topic : "",
            canceled: false,
            cancelLabel: "",
            isEntfall: old ? Boolean(old.isEntfall) : false,
            isWrittenExam: old ? Boolean(old.isWrittenExam) : false
          });
        }
      }
    });

    this.state.lessons = this.state.lessons.filter((item) => item.schoolYearId !== yearId).concat(generated);
    this.applyDayOffs(yearId);
    this._save();
  }

  applyDayOffs(schoolYearId) {
    const yearId = Number(schoolYearId);
    const ranges = this.listFreeRanges(yearId);
    const specialByDate = new Map(this.state.specialDays.map((item) => [item.dayDate, item.name]));

    for (const lesson of this.state.lessons) {
      if (lesson.schoolYearId !== yearId) {
        continue;
      }
      lesson.canceled = false;
      lesson.cancelLabel = "";
      let freeLabel = "";
      for (const range of ranges) {
        if (isoInDateRange(lesson.lessonDate, range.startDate, range.endDate)) {
          freeLabel = range.label || "Unterrichtsfrei";
          break;
        }
      }
      const specialLabel = specialByDate.get(lesson.lessonDate) || "";
      const cancelLabel = freeLabel || specialLabel;
      if (cancelLabel) {
        lesson.canceled = true;
        lesson.cancelLabel = cancelLabel;
      }
    }
  }

  listLessonsForWeek(schoolYearId, weekStartIso, weekEndIso, courseId = null) {
    const yearId = Number(schoolYearId);
    const coursesById = new Map(this.listCourses(yearId).map((item) => [item.id, item]));
    return this.state.lessons
      .filter((lesson) => lesson.schoolYearId === yearId)
      .filter((lesson) => lesson.lessonDate >= weekStartIso && lesson.lessonDate <= weekEndIso)
      .filter((lesson) => !courseId || lesson.courseId === Number(courseId))
      .map((lesson) => {
        const course = coursesById.get(lesson.courseId);
        return {
          ...lesson,
          courseName: course ? course.name : `Kurs ${lesson.courseId}`,
          color: course
            ? normalizeCourseColor(course.color, Boolean(course.noLesson))
            : "#94A3B8",
          noLesson: course ? Boolean(course.noLesson) : false
        };
      })
      .sort((a, b) => {
        if (a.lessonDate !== b.lessonDate) {
          return a.lessonDate.localeCompare(b.lessonDate);
        }
        return a.hour - b.hour;
      });
  }

  getLessonById(lessonId) {
    const found = this.state.lessons.find((item) => item.id === Number(lessonId));
    if (!found) {
      return null;
    }
    const course = this.state.courses.find((item) => item.id === found.courseId);
    return {
      ...found,
      courseName: course ? course.name : `Kurs ${found.courseId}`,
      color: course
        ? normalizeCourseColor(course.color, Boolean(course.noLesson))
        : "#94A3B8",
      noLesson: course ? Boolean(course.noLesson) : false
    };
  }

  getLessonBlock(lessonId) {
    const selected = this.state.lessons.find((item) => item.id === Number(lessonId));
    if (!selected) {
      return [];
    }
    return this.state.lessons
      .filter((item) => item.slotId === selected.slotId && item.lessonDate === selected.lessonDate)
      .sort((a, b) => a.hour - b.hour);
  }

  updateLessonBlock(lessonId, topic, isEntfall, isWrittenExam) {
    const block = this.getLessonBlock(lessonId);
    if (block.length === 0) {
      return false;
    }
    const normalizedTopic = overrideTopicForFlags(topic, isEntfall, isWrittenExam);
    for (const lesson of block) {
      lesson.topic = normalizedTopic;
      lesson.isEntfall = Boolean(isEntfall);
      lesson.isWrittenExam = Boolean(isWrittenExam);
    }
    this._save();
    return true;
  }

  clearLessonBlock(lessonId) {
    const block = this.getLessonBlock(lessonId);
    if (block.length === 0) {
      return;
    }
    for (const lesson of block) {
      lesson.topic = "";
      lesson.isEntfall = false;
      lesson.isWrittenExam = false;
    }
    this._save();
  }

  requiredHolidaysComplete(schoolYearId) {
    const ranges = this.listFreeRanges(schoolYearId);
    return computeRequiredHolidayMissingDetails(ranges).length === 0;
  }
}

PlannerStore.prototype._buildCourseBlocks = function (lessons) {
  const lessonsByDate = new Map();
  for (const lesson of lessons) {
    if (!lessonsByDate.has(lesson.lessonDate)) {
      lessonsByDate.set(lesson.lessonDate, []);
    }
    lessonsByDate.get(lesson.lessonDate).push(lesson);
  }

  const blocks = [];
  const orderedDates = [...lessonsByDate.keys()].sort((a, b) => a.localeCompare(b));
  for (const lessonDate of orderedDates) {
    const dayLessons = lessonsByDate.get(lessonDate).sort((a, b) => a.hour - b.hour);
    let currentBlock = [];
    let lastHour = null;

    for (const lesson of dayLessons) {
      if (lastHour === null || lesson.hour === lastHour + 1) {
        currentBlock.push(lesson);
      } else {
        if (currentBlock.length > 0) {
          blocks.push(currentBlock);
        }
        currentBlock = [lesson];
      }
      lastHour = lesson.hour;
    }

    if (currentBlock.length > 0) {
      blocks.push(currentBlock);
    }
  }
  return blocks;
};

PlannerStore.prototype.shiftCourseTopicsForward = function (schoolYearId, courseId, startLessonId) {
  const year = this.getSchoolYear(schoolYearId);
  if (!year) {
    return { success: false, message: "Kein aktives Schuljahr." };
  }

  const lessons = this.listLessonsForWeek(year.id, year.startDate, year.endDate, courseId).filter(
    (lesson) => !lesson.canceled
  );
  if (lessons.length === 0) {
    return { success: false, message: "Für diesen Kurs gibt es keine verfügbaren Stunden." };
  }

  const blocks = this._buildCourseBlocks(lessons);
  const startIndex = blocks.findIndex((block) => block.some((lesson) => lesson.id === Number(startLessonId)));
  if (startIndex < 0) {
    return { success: false, message: "Die ausgewählte Stunde ist nicht verfügbar." };
  }

  const blockTopics = [];
  const blockLessonIds = [];
  const blockEntfallFlags = [];
  const blockWrittenFlags = [];
  const blockHasContent = [];

  for (const block of blocks) {
    const ids = block.map((lesson) => lesson.id);
    const firstTopicLesson = block.find((lesson) => String(lesson.topic || "").trim());
    const topic = firstTopicLesson ? String(firstTopicLesson.topic || "") : "";
    const isEntfall = block.some((lesson) => Boolean(lesson.isEntfall));
    const isWritten = block.some((lesson) => Boolean(lesson.isWrittenExam));
    blockLessonIds.push(ids);
    blockTopics.push(topic);
    blockEntfallFlags.push(isEntfall);
    blockWrittenFlags.push(isWritten);
    blockHasContent.push(Boolean(topic.trim()) || isEntfall || isWritten);
  }

  if (!blockHasContent[startIndex]) {
    return { success: false, message: null };
  }

  let emptyIndex = -1;
  for (let idx = startIndex + 1; idx < blockHasContent.length; idx += 1) {
    if (!blockHasContent[idx]) {
      emptyIndex = idx;
      break;
    }
  }

  if (emptyIndex < 0) {
    return {
      success: false,
      message:
        "Diese Verschiebung würde die Verschiebung einer Stunde zur Folge haben, für die es im Kurs keinen freien Termin mehr gibt."
    };
  }

  for (let idx = startIndex + 1; idx < emptyIndex; idx += 1) {
    if (blockWrittenFlags[idx]) {
      return {
        success: false,
        message:
          "Diese Verschiebung würde auch eine Verschiebung einer schriftlichen Arbeit bedeuten. Eine schriftliche Arbeit kann jedoch nur dann verschoben werden, wenn sie selbst ausgewählt wurde."
      };
    }
    if (blockEntfallFlags[idx]) {
      return {
        success: false,
        message:
          "Diese Verschiebung würde auch eine Verschiebung einer Entfall-Stunde bedeuten. Eine Entfall-Stunde kann jedoch nur dann verschoben werden, wenn sie selbst ausgewählt wurde."
      };
    }
  }

  const byId = new Map(this.state.lessons.map((lesson) => [lesson.id, lesson]));

  for (let idx = emptyIndex; idx > startIndex; idx -= 1) {
    const topic = blockTopics[idx - 1];
    const entfall = blockEntfallFlags[idx - 1];
    const written = blockWrittenFlags[idx - 1];
    for (const lessonId of blockLessonIds[idx]) {
      const lesson = byId.get(lessonId);
      if (!lesson) {
        continue;
      }
      lesson.topic = overrideTopicForFlags(topic, entfall, written);
      lesson.isEntfall = Boolean(entfall);
      lesson.isWrittenExam = Boolean(written);
    }
  }

  for (const lessonId of blockLessonIds[startIndex]) {
    const lesson = byId.get(lessonId);
    if (!lesson) {
      continue;
    }
    lesson.topic = "";
    lesson.isEntfall = false;
    lesson.isWrittenExam = false;
  }

  this._save();
  return { success: true, message: null };
};

PlannerStore.prototype.shiftCourseTopicsBackward = function (schoolYearId, courseId, startLessonId) {
  const year = this.getSchoolYear(schoolYearId);
  if (!year) {
    return { success: false, message: "Kein aktives Schuljahr." };
  }

  const lessons = this.listLessonsForWeek(year.id, year.startDate, year.endDate, courseId).filter(
    (lesson) => !lesson.canceled
  );
  if (lessons.length === 0) {
    return { success: false, message: "Für diesen Kurs gibt es keine verfügbaren Stunden." };
  }

  const blocks = this._buildCourseBlocks(lessons);
  const startIndex = blocks.findIndex((block) => block.some((lesson) => lesson.id === Number(startLessonId)));
  if (startIndex < 0) {
    return { success: false, message: "Die ausgewählte Stunde ist nicht verfügbar." };
  }

  const blockTopics = [];
  const blockLessonIds = [];
  const blockEntfallFlags = [];
  const blockWrittenFlags = [];
  const blockHasContent = [];

  for (const block of blocks) {
    const ids = block.map((lesson) => lesson.id);
    const firstTopicLesson = block.find((lesson) => String(lesson.topic || "").trim());
    const topic = firstTopicLesson ? String(firstTopicLesson.topic || "") : "";
    const isEntfall = block.some((lesson) => Boolean(lesson.isEntfall));
    const isWritten = block.some((lesson) => Boolean(lesson.isWrittenExam));
    blockLessonIds.push(ids);
    blockTopics.push(topic);
    blockEntfallFlags.push(isEntfall);
    blockWrittenFlags.push(isWritten);
    blockHasContent.push(Boolean(topic.trim()) || isEntfall || isWritten);
  }

  if (!blockHasContent[startIndex]) {
    return { success: false, message: null };
  }

  let emptyIndex = -1;
  for (let idx = startIndex - 1; idx >= 0; idx -= 1) {
    if (!blockHasContent[idx]) {
      emptyIndex = idx;
      break;
    }
  }

  if (emptyIndex < 0) {
    return {
      success: false,
      message:
        "Diese Verschiebung würde die Verschiebung einer Stunde zur Folge haben, für die es im Kurs keinen freien Termin mehr gibt."
    };
  }

  for (let idx = emptyIndex + 1; idx < startIndex; idx += 1) {
    if (blockWrittenFlags[idx]) {
      return {
        success: false,
        message:
          "Diese Verschiebung würde auch eine Verschiebung einer schriftlichen Arbeit bedeuten. Eine schriftliche Arbeit kann jedoch nur dann verschoben werden, wenn sie selbst ausgewählt wurde."
      };
    }
    if (blockEntfallFlags[idx]) {
      return {
        success: false,
        message:
          "Diese Verschiebung würde auch eine Verschiebung einer Entfall-Stunde bedeuten. Eine Entfall-Stunde kann jedoch nur dann verschoben werden, wenn sie selbst ausgewählt wurde."
      };
    }
  }

  const byId = new Map(this.state.lessons.map((lesson) => [lesson.id, lesson]));

  for (let idx = emptyIndex; idx < startIndex; idx += 1) {
    const topic = blockTopics[idx + 1];
    const entfall = blockEntfallFlags[idx + 1];
    const written = blockWrittenFlags[idx + 1];
    for (const lessonId of blockLessonIds[idx]) {
      const lesson = byId.get(lessonId);
      if (!lesson) {
        continue;
      }
      lesson.topic = overrideTopicForFlags(topic, entfall, written);
      lesson.isEntfall = Boolean(entfall);
      lesson.isWrittenExam = Boolean(written);
    }
  }

  for (const lessonId of blockLessonIds[startIndex]) {
    const lesson = byId.get(lessonId);
    if (!lesson) {
      continue;
    }
    lesson.topic = "";
    lesson.isEntfall = false;
    lesson.isWrittenExam = false;
  }

  this._save();
  return { success: true, message: null };
};

PlannerStore.prototype.splitSlotFromDate = function (
  schoolYearId,
  slotId,
  fromDate,
  courseId,
  dayOfWeek,
  startHour,
  duration,
  endDate,
  weekParity
) {
  const year = this.getSchoolYear(schoolYearId);
  const oldSlot = this.getSlot(slotId);
  const targetCourse = this.state.courses.find((item) => item.id === Number(courseId));
  if (!year || !oldSlot || !fromDate) {
    return { ok: false, message: "Ungültige Eingabe für Teiländerung." };
  }
  if (!targetCourse || Number(targetCourse.schoolYearId) !== Number(year.id)) {
    return { ok: false, message: "Der gewählte Kurs gehört nicht zum aktiven Schuljahr." };
  }

  const oldStart = oldSlot.startDate || year.startDate;
  const oldEnd = oldSlot.endDate || year.endDate;
  if (fromDate > oldEnd) {
    return { ok: false, message: "Das Datum liegt außerhalb des bestehenden Slot-Zeitraums." };
  }

  if (fromDate <= oldStart) {
    this.updateSlot(
      slotId,
      courseId,
      dayOfWeek,
      startHour,
      duration,
      oldSlot.startDate || null,
      endDate || oldSlot.endDate || null,
      weekParity
    );
    return { ok: true, mode: "all" };
  }

  const targetEnd = endDate || oldSlot.endDate || year.endDate;
  if (targetEnd < fromDate) {
    return { ok: false, message: "Das Enddatum muss nach dem Startdatum liegen." };
  }

  const sourceRows = this.state.lessons
    .filter((lesson) => lesson.schoolYearId === Number(schoolYearId))
    .filter((lesson) => lesson.slotId === Number(slotId))
    .filter((lesson) => lesson.lessonDate >= fromDate)
    .filter((lesson) => !lesson.canceled)
    .sort((a, b) => {
      if (a.lessonDate !== b.lessonDate) {
        return a.lessonDate.localeCompare(b.lessonDate);
      }
      return a.hour - b.hour;
    })
    .map((lesson) => ({
      topic: lesson.topic || "",
      isEntfall: Boolean(lesson.isEntfall),
      isWrittenExam: Boolean(lesson.isWrittenExam)
    }));

  oldSlot.endDate = addDays(fromDate, -1);

  const newSlot = {
    id: this._nextId("slot"),
    courseId: targetCourse.id,
    dayOfWeek: Number(dayOfWeek),
    startHour: Number(startHour),
    duration: Math.max(1, Number(duration)),
    startDate: fromDate,
    endDate: targetEnd || null,
    weekParity: Number(weekParity) || 0
  };
  this.state.slots.push(newSlot);

  this.generateLessonsForYear(Number(schoolYearId));

  const targetRows = this.state.lessons
    .filter((lesson) => lesson.schoolYearId === Number(schoolYearId))
    .filter((lesson) => lesson.slotId === newSlot.id)
    .filter((lesson) => lesson.lessonDate >= fromDate)
    .filter((lesson) => !lesson.canceled)
    .sort((a, b) => {
      if (a.lessonDate !== b.lessonDate) {
        return a.lessonDate.localeCompare(b.lessonDate);
      }
      return a.hour - b.hour;
    });

  const maxLen = Math.min(sourceRows.length, targetRows.length);
  for (let idx = 0; idx < maxLen; idx += 1) {
    targetRows[idx].topic = sourceRows[idx].topic;
    targetRows[idx].isEntfall = sourceRows[idx].isEntfall;
    targetRows[idx].isWrittenExam = sourceRows[idx].isWrittenExam;
  }

  this._save();
  return { ok: true, mode: "split", newSlotId: newSlot.id };
};

PlannerStore.prototype.exportBackupPayload = function () {
  return {
    schema: "planung-pwa-backup-v1",
    exportedAt: new Date().toISOString(),
    state: JSON.parse(JSON.stringify(this.state))
  };
};

PlannerStore.prototype.importBackupPayload = function (payload) {
  const rawState = payload && payload.state ? payload.state : payload;
  if (!rawState || typeof rawState !== "object") {
    return { ok: false, message: "Ungültiges Backup-Format." };
  }
  if (
    !Array.isArray(rawState.schoolYears) ||
    !Array.isArray(rawState.courses) ||
    !Array.isArray(rawState.slots) ||
    !Array.isArray(rawState.freeRanges) ||
    !Array.isArray(rawState.specialDays) ||
    !Array.isArray(rawState.lessons)
  ) {
    return { ok: false, message: "Backup enthält unvollständige Daten." };
  }
  const asObject = (value) => (value && typeof value === "object" ? value : {});

  const base = createInitialState();
  const normalized = {
    ...base,
    settings: { ...base.settings, ...(rawState.settings || {}) },
    counters: { ...base.counters, ...(rawState.counters || {}) },
    schoolYears: rawState.schoolYears.map((raw) => {
      const item = asObject(raw);
      return {
      id: Number(item.id),
      name: String(item.name || ""),
      startDate: String(item.startDate || ""),
      endDate: String(item.endDate || "")
      };
    }),
    courses: rawState.courses.map((raw) => {
      const item = asObject(raw);
      const noLesson = Boolean(item.noLesson);
      return {
      id: Number(item.id),
      schoolYearId: Number(item.schoolYearId),
      name: String(item.name || ""),
      color: normalizeCourseColor(item.color, noLesson),
      noLesson,
      hiddenInSidebar: Boolean(item.hiddenInSidebar),
      sortOrder: Number(item.sortOrder || 0)
      };
    }),
    slots: rawState.slots.map((raw) => {
      const item = asObject(raw);
      return {
      id: Number(item.id),
      courseId: Number(item.courseId),
      dayOfWeek: Number(item.dayOfWeek),
      startHour: Number(item.startHour),
      duration: Math.max(1, Number(item.duration || 1)),
      startDate: item.startDate || null,
      endDate: item.endDate || null,
      weekParity: Number(item.weekParity || 0)
      };
    }),
    freeRanges: rawState.freeRanges.map((raw) => {
      const item = asObject(raw);
      return {
      id: Number(item.id),
      schoolYearId: Number(item.schoolYearId),
      label: String(item.label || ""),
      startDate: String(item.startDate || ""),
      endDate: String(item.endDate || "")
      };
    }),
    specialDays: rawState.specialDays.map((raw) => {
      const item = asObject(raw);
      return {
      id: Number(item.id),
      name: String(item.name || ""),
      dayDate: String(item.dayDate || "")
      };
    }),
    lessons: rawState.lessons.map((raw) => {
      const item = asObject(raw);
      return {
      id: Number(item.id),
      schoolYearId: Number(item.schoolYearId),
      slotId: Number(item.slotId),
      courseId: Number(item.courseId),
      lessonDate: String(item.lessonDate || ""),
      dayOfWeek: Number(item.dayOfWeek),
      hour: Number(item.hour),
      topic: String(item.topic || ""),
      canceled: Boolean(item.canceled),
      cancelLabel: String(item.cancelLabel || ""),
      isEntfall: Boolean(item.isEntfall),
      isWrittenExam: Boolean(item.isWrittenExam)
      };
    })
  };

  normalized.schoolYears = normalized.schoolYears.filter(
    (item) => item.id > 0 && item.name && item.startDate && item.endDate
  );
  normalized.courses = normalized.courses.filter(
    (item) => item.id > 0 && item.schoolYearId > 0 && item.name
  );
  normalized.slots = normalized.slots.filter(
    (item) => item.id > 0 && item.courseId > 0 && item.dayOfWeek >= 1 && item.dayOfWeek <= 5
  );
  normalized.freeRanges = normalized.freeRanges.filter(
    (item) => {
      if (!(item.id > 0 && item.schoolYearId > 0 && item.label)) {
        return false;
      }
      const normalizedLabel = String(item.label || "").trim().toLowerCase();
      if (normalizedLabel === "sommerferien") {
        return Boolean(item.startDate) || Boolean(item.endDate);
      }
      return Boolean(item.startDate) && Boolean(item.endDate);
    }
  );
  normalized.specialDays = normalized.specialDays.filter(
    (item) => item.id > 0 && item.name && item.dayDate
  );
  normalized.lessons = normalized.lessons.filter(
    (item) => item.id > 0 && item.schoolYearId > 0 && item.slotId > 0 && item.courseId > 0
  );

  const maxBy = (rows) => rows.reduce((max, row) => Math.max(max, Number(row.id) || 0), 0);
  normalized.counters = {
    schoolYear: Math.max(Number(normalized.counters.schoolYear) || 1, maxBy(normalized.schoolYears) + 1),
    course: Math.max(Number(normalized.counters.course) || 1, maxBy(normalized.courses) + 1),
    slot: Math.max(Number(normalized.counters.slot) || 1, maxBy(normalized.slots) + 1),
    freeRange: Math.max(Number(normalized.counters.freeRange) || 1, maxBy(normalized.freeRanges) + 1),
    specialDay: Math.max(Number(normalized.counters.specialDay) || 1, maxBy(normalized.specialDays) + 1),
    lesson: Math.max(Number(normalized.counters.lesson) || 1, maxBy(normalized.lessons) + 1)
  };

  this.state = normalized;
  this.ensureDefaultSchoolYear();
  for (const year of this.state.schoolYears) {
    const startYear = Number(String(year.startDate).slice(0, 4));
    this.seedHolidayDefaults(year.id, startYear);
  }
  if (this.state.specialDays.length === 0) {
    const active = this.getActiveSchoolYear();
    if (active) {
      const startYear = Number(String(active.startDate).slice(0, 4));
      this.resetSpecialDays(startYear);
    }
  }

  const yearIds = this.state.schoolYears.map((item) => item.id);
  for (const yearId of yearIds) {
    this.generateLessonsForYear(yearId);
  }

  this._save();
  return { ok: true };
};

class PlannerApp {
  constructor() {
    clearLegacyBrowserStorage();
    this.store = new PlannerStore();
    this.weekStartIso = currentWeekStartForDisplay();
    this.selectedLessonId = null;
    this.selectedCourseId = null;
    this.currentView = "week";
    this.activeSettingsTab = "dayoff";
    this.locked = false;
    this.lockReason = "";
    this.scrollCourseNextIntoView = false;
    this.dragCourseId = null;
    this.dragSourceRow = null;
    this.dragPlaceholder = null;
    this.dragDropCommitted = false;
    this.slotDialogStartMinIso = null;
    this.slotDialogEndDateBackup = null;

    this.refs = {
      schoolYearSelect: document.querySelector("#school-year-select"),
      kwLabel: document.querySelector("#kw-label"),
      weekPickerBtn: document.querySelector("#week-picker-btn"),
      weekDate: document.querySelector("#week-date"),
      weekPrev: document.querySelector("#week-prev"),
      weekNext: document.querySelector("#week-next"),

      viewWeekBtn: document.querySelector("#view-week-btn"),
      viewSettingsBtn: document.querySelector("#view-settings-btn"),
      viewWeek: document.querySelector("#view-week"),
      viewCourse: document.querySelector("#view-course"),
      viewSettings: document.querySelector("#view-settings"),
      mainPane: document.querySelector(".main-pane"),
      stackGlass: document.querySelector("#stackGlass"),
      settingsShell: document.querySelector("#settings-shell"),
      headerGlass: document.querySelector("#headerGlass"),

      sidebarCourseList: document.querySelector("#sidebar-course-list"),

      settingsTabs: [...document.querySelectorAll(".settings-tab")],
      settingsPanels: {
        dayoff: document.querySelector("#settings-tab-dayoff"),
        display: document.querySelector("#settings-tab-display"),
        database: document.querySelector("#settings-tab-database"),
        version: document.querySelector("#settings-tab-version")
      },
      settingsResetAll: document.querySelector("#settings-reset-all"),
      settingsSaveAll: document.querySelector("#settings-save-all"),
      settingsCancelAll: document.querySelector("#settings-cancel-all"),
      settingsActionsRow: document.querySelector(".settings-actions-row"),

      courseTitle: document.querySelector("#course-title"),
      courseTable: document.querySelector("#course-table"),

      weekTable: document.querySelector("#week-table"),
      contextMenu: document.querySelector("#app-context-menu"),
      messageDialog: document.querySelector("#message-dialog"),
      messageDialogForm: document.querySelector("#message-dialog-form"),
      messageDialogTitle: document.querySelector("#message-dialog-title"),
      messageDialogText: document.querySelector("#message-dialog-text"),
      messageDialogInputRow: document.querySelector("#message-dialog-input-row"),
      messageDialogInput: document.querySelector("#message-dialog-input"),
      messageDialogCancel: document.querySelector("#message-dialog-cancel"),
      messageDialogOk: document.querySelector("#message-dialog-ok"),

      courseDialog: document.querySelector("#course-dialog"),
      courseDialogForm: document.querySelector("#course-dialog-form"),
      courseDialogTitle: document.querySelector("#course-dialog-title"),
      courseDialogId: document.querySelector("#course-dialog-id"),
      courseDialogName: document.querySelector("#course-dialog-name"),
      courseDialogColorPanel: document.querySelector("#course-dialog-color-panel"),
      courseDialogColorPalette: document.querySelector("#course-dialog-color-palette"),
      courseDialogNoLesson: document.querySelector("#course-dialog-no-lesson"),
      courseDialogToggleSidebar: document.querySelector("#course-dialog-toggle-sidebar"),
      courseDialogCancel: document.querySelector("#course-dialog-cancel"),
      courseDialogDelete: document.querySelector("#course-dialog-delete"),

      entfallDialog: document.querySelector("#entfall-dialog"),
      entfallDialogForm: document.querySelector("#entfall-dialog-form"),
      entfallDialogReason: document.querySelector("#entfall-dialog-reason"),
      entfallDialogCancel: document.querySelector("#entfall-dialog-cancel"),

      topicDialog: document.querySelector("#topic-dialog"),
      topicDialogForm: document.querySelector("#topic-dialog-form"),
      topicDialogLesson: document.querySelector("#topic-dialog-lesson"),
      topicDialogInput: document.querySelector("#topic-dialog-input"),
      topicDialogCancel: document.querySelector("#topic-dialog-cancel"),

      slotDialog: document.querySelector("#slot-dialog"),
      slotDialogForm: document.querySelector("#slot-dialog-form"),
      slotDialogTitle: document.querySelector("#slot-dialog-title"),
      slotDialogId: document.querySelector("#slot-dialog-id"),
      slotDialogCourse: document.querySelector("#slot-dialog-course"),
      slotDialogDay: document.querySelector("#slot-dialog-day"),
      slotDialogHour: document.querySelector("#slot-dialog-hour"),
      slotDialogEndHour: document.querySelector("#slot-dialog-end-hour"),
      slotDialogStart: document.querySelector("#slot-dialog-start"),
      slotDialogEnd: document.querySelector("#slot-dialog-end"),
      slotDialogParity: document.querySelector("#slot-dialog-parity"),
      slotDialogEditInfo: document.querySelector("#slot-dialog-edit-info"),
      slotDialogEditTools: document.querySelector("#slot-dialog-edit-tools"),
      slotDialogEditScope: document.querySelector("#slot-dialog-edit-scope"),
      slotDialogEditFromDate: document.querySelector("#slot-dialog-edit-from-date"),
      slotDialogDelete: document.querySelector("#slot-dialog-delete"),
      slotDialogCancel: document.querySelector("#slot-dialog-cancel"),
      weekCalendarDialog: document.querySelector("#week-calendar-dialog"),
      weekCalendarPrev: document.querySelector("#week-calendar-prev"),
      weekCalendarNext: document.querySelector("#week-calendar-next"),
      weekCalendarMonth: document.querySelector("#week-calendar-month"),
      weekCalendarGrid: document.querySelector("#week-calendar-grid"),

      hoursPerDay: document.querySelector("#hours-per-day"),
      showHiddenSidebarCourses: document.querySelector("#show-hidden-sidebar-courses"),
      appVersion: document.querySelector("#app-version"),
      backupAutoEnabled: document.querySelector("#backup-auto-enabled"),
      backupIntervalDays: document.querySelector("#backup-interval-days"),
      backupNowBtn: document.querySelector("#backup-now-btn"),
      dbBackupAutoEnabled: document.querySelector("#db-backup-auto-enabled"),
      dbBackupIntervalDays: document.querySelector("#db-backup-interval-days"),
      dbBackupNowBtn: document.querySelector("#db-backup-now-btn"),
      backupExportBtn: document.querySelector("#backup-export-btn"),
      backupImportBtn: document.querySelector("#backup-import-btn"),
      backupRestoreBtn: document.querySelector("#backup-restore-btn"),
      backupResetDefaults: document.querySelector("#backup-reset-defaults"),
      backupHint: document.querySelector("#backup-hint"),
      backupImportFile: document.querySelector("#backup-import-file"),
      backupStatus: document.querySelector("#backup-status"),
      backupDirName: document.querySelector("#backup-dir-name"),
      backupDirChangeBtn: document.querySelector("#backup-dir-change-btn"),
      syncFileName: document.querySelector("#sync-file-name"),
      syncFileStatus: document.querySelector("#sync-file-status"),
      dbSelectExistingBtn: document.querySelector("#db-select-existing-btn"),
      dbCreateNewBtn: document.querySelector("#db-create-new-btn"),

      courseSettingsAdd: document.querySelector("#course-settings-add"),
      courseList: document.querySelector("#course-list"),

      slotForm: document.querySelector("#slot-form"),
      slotId: document.querySelector("#slot-id"),
      slotCourse: document.querySelector("#slot-course"),
      slotDay: document.querySelector("#slot-day"),
      slotHour: document.querySelector("#slot-hour"),
      slotDuration: document.querySelector("#slot-duration"),
      slotStart: document.querySelector("#slot-start"),
      slotEnd: document.querySelector("#slot-end"),
      slotParity: document.querySelector("#slot-parity"),
      slotEditTools: document.querySelector("#slot-edit-tools"),
      slotEditScope: document.querySelector("#slot-edit-scope"),
      slotEditFromDate: document.querySelector("#slot-edit-from-date"),
      slotReset: document.querySelector("#slot-reset"),
      slotDelete: document.querySelector("#slot-delete"),
      slotList: document.querySelector("#slot-list"),

      freeRangeAdd: document.querySelector("#free-range-add"),
      freeRangeDialog: document.querySelector("#free-range-dialog"),
      freeRangeDialogForm: document.querySelector("#free-range-dialog-form"),
      freeRangeDialogTitle: document.querySelector("#free-range-dialog-title"),
      freeRangeDialogId: document.querySelector("#free-range-dialog-id"),
      freeRangeDialogLabel: document.querySelector("#free-range-dialog-label"),
      freeRangeDialogStart: document.querySelector("#free-range-dialog-start"),
      freeRangeDialogEnd: document.querySelector("#free-range-dialog-end"),
      freeRangeDialogDelete: document.querySelector("#free-range-dialog-delete"),
      freeRangeDialogCancel: document.querySelector("#free-range-dialog-cancel"),
      dayoffRequiredHint: document.querySelector("#dayoff-required-hint"),
      dayoffRequiredMissing: document.querySelector("#dayoff-required-missing"),
      freeRangeList: document.querySelector("#free-range-list"),

      specialDayDialog: document.querySelector("#special-day-dialog"),
      specialDayDialogForm: document.querySelector("#special-day-dialog-form"),
      specialDayDialogTitle: document.querySelector("#special-day-dialog-title"),
      specialDayDialogId: document.querySelector("#special-day-dialog-id"),
      specialDayDialogName: document.querySelector("#special-day-dialog-name"),
      specialDayDialogDate: document.querySelector("#special-day-dialog-date"),
      specialDayDialogDelete: document.querySelector("#special-day-dialog-delete"),
      specialDayDialogCancel: document.querySelector("#special-day-dialog-cancel"),
      specialDayList: document.querySelector("#special-day-list")
    };
    this.localClipboardText = "";
    this.contextMenuItems = [];
    this.pendingMessageDialogResolver = null;
    this.pendingMessageDialogMode = null;
    this.pendingEntfallLessonId = null;
    this.pendingTopicLessonId = null;
    this.inlineTopicLessonId = null;
    this.inlineTopicDraft = "";
    this.pwaRegistration = null;
    this.pwaReloadTriggered = false;
    this.appVersion = "";
    this.weekCalendarMonthIso = null;
    this.weekCalendarHoverWeekStart = null;
    this.courseDialogSelectedColor = normalizeHexColor(DEFAULT_COURSE_COLOR, DEFAULT_COURSE_COLOR);
    this.courseDialogColorBackup = this.courseDialogSelectedColor;
    this.courseDialogDefaultColor = this.courseDialogSelectedColor;
    this.settingsDraft = this.buildSettingsDraftFromStore();
    this.settingsDirty = false;
    this.syncMeta = this.loadSyncMeta();
    this.syncState = {
      supported: supportsExternalFileSync(),
      initialized: false,
      syncingNow: false,
      pendingSaveTimer: 0,
      pendingSaveReason: "",
      suppressAutoPush: false,
      fileHandle: null,
      storedFileHandle: null,
      fileName: String(this.syncMeta.fileName || ""),
      lastQueuedLocalHash: ""
    };
    this.backupState = {
      directoryHandle: null,
      storedDirectoryHandle: null
    };
    this.lastAutoBackupAt = "";
    this.store.setAfterSaveHook(() => {
      this.handleStoreSaved();
    });

    this.ensureStandaloneSettingsView();
    this.initNumberSteppers();
    this.bindEvents();
    this.maybeRunAutomaticWebBackup();
    this.renderAll();
    this.initPwa();
    this.initializeExternalFileSync().catch((_error) => {
      this.setSyncStatus("Datenbankdatei konnte nicht initialisiert werden.", true);
    });
  }

  get activeSchoolYear() {
    const year = this.store.getActiveSchoolYear();
    if (year) {
      this.store.setActiveSchoolYear(year.id);
    }
    return year;
  }

  buildSettingsDraftFromStore() {
    return {
      hoursPerDay: this.store.getHoursPerDay(),
      showHiddenSidebarCourses: Boolean(
        this.store.getSetting("showHiddenSidebarCourses", SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT)
      ),
      backupEnabled: this.store.getBackupEnabled(),
      backupIntervalDays: this.store.getBackupIntervalDays()
    };
  }

  loadSyncMeta() {
    const fallback = {
      deviceId: randomId(),
      knownRemoteRevision: 0,
      knownRemoteHash: "",
      fileName: "",
      lastSyncedAt: ""
    };
    try {
      const raw = localStorage.getItem(SYNC_META_KEY);
      if (!raw) {
        return fallback;
      }
      const parsed = JSON.parse(raw);
      return {
        deviceId: String(parsed && parsed.deviceId ? parsed.deviceId : fallback.deviceId),
        knownRemoteRevision: Math.max(0, Number(parsed && parsed.knownRemoteRevision) || 0),
        knownRemoteHash: String(parsed && parsed.knownRemoteHash ? parsed.knownRemoteHash : ""),
        fileName: String(parsed && parsed.fileName ? parsed.fileName : ""),
        lastSyncedAt: String(parsed && parsed.lastSyncedAt ? parsed.lastSyncedAt : "")
      };
    } catch (_error) {
      return fallback;
    }
  }

  saveSyncMeta() {
    try {
      localStorage.setItem(SYNC_META_KEY, JSON.stringify(this.syncMeta));
      return true;
    } catch (_error) {
      return false;
    }
  }

  setSyncStatus(text, isError = false) {
    if (!this.refs.syncFileStatus) {
      return;
    }
    this.refs.syncFileStatus.textContent = text || "";
    this.refs.syncFileStatus.style.color = isError ? "#ff8a8a" : "";
  }

  getCurrentStateHash() {
    return hashStateObject(this.store.state);
  }

  getPayloadStateHash(payload) {
    const state = payload && payload.state ? payload.state : payload;
    return hashStateObject(state);
  }

  markKnownRemote(envelope) {
    if (!envelope || !envelope.payload) {
      return;
    }
    this.syncMeta.knownRemoteRevision = Math.max(0, Number(envelope.revision) || 0);
    this.syncMeta.knownRemoteHash = this.getPayloadStateHash(envelope.payload);
    this.syncMeta.lastSyncedAt = String(envelope.updatedAt || new Date().toISOString());
    this.syncMeta.fileName = String(this.syncState.fileName || this.syncMeta.fileName || "");
    this.syncState.lastQueuedLocalHash = this.syncMeta.knownRemoteHash;
    this.saveSyncMeta();
  }

  async ensureSyncFilePermission(handle, writable = false) {
    if (!handle || typeof handle.queryPermission !== "function") {
      return false;
    }
    const mode = writable ? "readwrite" : "read";
    try {
      let permission = await handle.queryPermission({ mode });
      if (permission === "granted") {
        return true;
      }
      permission = await handle.requestPermission({ mode });
      return permission === "granted";
    } catch (_error) {
      return false;
    }
  }

  async hasSyncFilePermission(handle, writable = false) {
    if (!handle || typeof handle.queryPermission !== "function") {
      return false;
    }
    const mode = writable ? "readwrite" : "read";
    try {
      const permission = await handle.queryPermission({ mode });
      return permission === "granted";
    } catch (_error) {
      return false;
    }
  }

  async pickExistingSyncFileHandle() {
    if (!this.syncState.supported) {
      return null;
    }
    if (typeof window.showOpenFilePicker === "function") {
      const [handle] = await window.showOpenFilePicker({
        multiple: false,
        types: [
          {
            description: "JSON-Datei",
            accept: { "application/json": [".json"] }
          }
        ],
        excludeAcceptAllOption: false
      });
      return handle || null;
    }
    return null;
  }

  async pickNewSyncFileHandle() {
    if (!this.syncState.supported) {
      return null;
    }
    if (typeof window.showSaveFilePicker === "function") {
      return window.showSaveFilePicker({
        suggestedName: this.buildSyncFileSuggestedName(),
        types: [
          {
            description: "JSON-Datei",
            accept: { "application/json": [".json"] }
          }
        ],
        excludeAcceptAllOption: false
      });
    }
    return null;
  }

  buildSyncFileSuggestedName() {
    const fallbackStartYear = (() => {
      const now = new Date();
      return now.getMonth() >= 6 ? now.getFullYear() : now.getFullYear() - 1;
    })();
    const activeYear = this.activeSchoolYear;
    const parsedStart = Number(String(activeYear && activeYear.startDate ? activeYear.startDate : "").slice(0, 4));
    const parsedEnd = Number(String(activeYear && activeYear.endDate ? activeYear.endDate : "").slice(0, 4));
    const startYear = Number.isFinite(parsedStart) && parsedStart > 0 ? parsedStart : fallbackStartYear;
    const endYear = Number.isFinite(parsedEnd) && parsedEnd > 0 ? parsedEnd : (startYear + 1);
    const toYY = (year) => String(Math.trunc(year) % 100).padStart(2, "0");
    return `PlanungDB${toYY(startYear)}-${toYY(endYear)}.json`;
  }

  buildBackupFileName() {
    const now = new Date();
    const stamp = [
      String(now.getFullYear()),
      String(now.getMonth() + 1).padStart(2, "0"),
      String(now.getDate()).padStart(2, "0"),
      "-",
      String(now.getHours()).padStart(2, "0"),
      String(now.getMinutes()).padStart(2, "0"),
      String(now.getSeconds()).padStart(2, "0")
    ].join("");
    return `Planung-Backup-${stamp}.json`;
  }

  async assignBackupDirectoryFromSyncFile(syncFileHandle) {
    if (!syncFileHandle || typeof window.showDirectoryPicker !== "function") {
      this.backupState.directoryHandle = null;
      return false;
    }
    try {
      await this.showInfoMessage(
        "Für Backups braucht die App Zugriff auf einen Ordner.\n\nBitte wähle am besten denselben Ordner wie bei der Datenbankdatei."
      );
      const directoryHandle = await window.showDirectoryPicker({
        mode: "readwrite",
        startIn: syncFileHandle
      });
      if (!directoryHandle) {
        this.backupState.directoryHandle = null;
        return false;
      }
      const permission = await directoryHandle.requestPermission({ mode: "readwrite" });
      if (permission !== "granted") {
        this.backupState.directoryHandle = null;
        return false;
      }
      this.backupState.directoryHandle = directoryHandle;
      return true;
    } catch (_error) {
      this.backupState.directoryHandle = null;
      return false;
    }
  }

  async ensureBackupDirectoryReady(syncFileHandle, options = {}) {
    const { allowPrompt = true } = options;
    if (this.backupState.directoryHandle) {
      const activePermissionGranted = allowPrompt
        ? await this.ensureSyncFilePermission(this.backupState.directoryHandle, true)
        : await this.hasSyncFilePermission(this.backupState.directoryHandle, true);
      if (activePermissionGranted) {
        return true;
      }
    }
    this.backupState.directoryHandle = null;

    let storedBackupDir = this.backupState.storedDirectoryHandle;
    if (!storedBackupDir) {
      storedBackupDir = await getStoredHandle(SYNC_HANDLE_BACKUP_DIR_KEY);
      this.backupState.storedDirectoryHandle = storedBackupDir || null;
    }
    if (!storedBackupDir) {
      void syncFileHandle;
      return false;
    }
    const storedPermissionGranted = allowPrompt
      ? await this.ensureSyncFilePermission(storedBackupDir, true)
      : await this.hasSyncFilePermission(storedBackupDir, true);
    if (storedPermissionGranted) {
      this.backupState.directoryHandle = storedBackupDir;
      return true;
    }
    void syncFileHandle;
    return false;
  }

  async connectSyncFileHandle(handle, source = "manual") {
    if (!handle) {
      return false;
    }
    const isStartup = source === "startup";
    this.syncState.fileHandle = handle;
    this.syncState.storedFileHandle = handle;
    this.syncState.fileName = String(handle.name || this.syncMeta.fileName || this.syncState.fileName || "");
    this.syncMeta.fileName = this.syncState.fileName;
    this.saveSyncMeta();
    await storeHandle(SYNC_HANDLE_FILE_KEY, handle);

    const backupDirectoryReady = await this.ensureBackupDirectoryReady(handle, {
      allowPrompt: !isStartup
    });
    if (backupDirectoryReady) {
      this.setBackupStatus("Backups werden im selben Ordner wie die Datenbankdatei erstellt.");
    } else {
      this.setBackupStatus("Backup-Ordner fehlt. Bei Bedarf bitte über den Button auswählen.");
    }

    const remoteEnvelope = await this.readSyncEnvelopeFromHandle(handle);
    if (remoteEnvelope && remoteEnvelope.payload) {
      if (isStartup) {
        await this.applyRemoteEnvelopeToApp(remoteEnvelope, "startup");
      } else {
        const remoteHash = this.getPayloadStateHash(remoteEnvelope.payload);
        const localHash = this.getCurrentStateHash();
        if (remoteHash !== localHash) {
          await this.applyRemoteEnvelopeToApp(remoteEnvelope, "manual");
        } else {
          this.markKnownRemote(remoteEnvelope);
          this.setSyncStatus("Datenbankdatei verbunden.");
        }
      }
    } else {
      const hasContent = await this.hasNonEmptySyncFile(handle);
      if (hasContent) {
        this.setSyncStatus("Vorhandene Datei erkannt (Format nicht kompatibel). Datei wurde nicht überschrieben.", true);
      } else if (isStartup) {
        this.setSyncStatus("Datenbankdatei verbunden. Datei wird beim nächsten Speichern befüllt.");
      } else {
        await this.pushLocalStateToSyncFile({
          manual: true,
          allowConflictPrompt: false,
          reason: "initial-seed"
        });
      }
    }
    return true;
  }

  async tryReconnectStoredSyncFile() {
    if (this.syncState.fileHandle) {
      return false;
    }
    let storedHandle = this.syncState.storedFileHandle;
    if (!storedHandle) {
      storedHandle = await getStoredHandle(SYNC_HANDLE_FILE_KEY);
      this.syncState.storedFileHandle = storedHandle || null;
    }
    if (!storedHandle) {
      return false;
    }
    if (!await this.ensureSyncFilePermission(storedHandle, true)) {
      return false;
    }
    await this.connectSyncFileHandle(storedHandle, "manual");
    this.syncState.initialized = true;
    this.renderAll();
    return true;
  }

  async writeBackupFileSnapshot(payload) {
    const directoryHandle = this.backupState.directoryHandle;
    if (!directoryHandle || typeof directoryHandle.getFileHandle !== "function") {
      return false;
    }
    try {
      const fileName = this.buildBackupFileName();
      const fileHandle = await directoryHandle.getFileHandle(fileName, { create: true });
      if (!fileHandle || typeof fileHandle.createWritable !== "function") {
        return false;
      }
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(payload, null, 2));
      await writable.close();
      return true;
    } catch (_error) {
      return false;
    }
  }

  async readSyncEnvelopeFromHandle(handle) {
    if (!handle || typeof handle.getFile !== "function") {
      return null;
    }
    try {
      const file = await handle.getFile();
      const text = await file.text();
      if (!String(text || "").trim()) {
        return null;
      }
      const parsed = JSON.parse(text);
      return normalizeSyncEnvelope(parsed);
    } catch (_error) {
      return null;
    }
  }

  async hasNonEmptySyncFile(handle) {
    if (!handle || typeof handle.getFile !== "function") {
      return false;
    }
    try {
      const file = await handle.getFile();
      if (!file || Number(file.size) <= 0) {
        return false;
      }
      const text = await file.text();
      return Boolean(String(text || "").trim());
    } catch (_error) {
      return false;
    }
  }

  async writeSyncEnvelopeToHandle(handle, envelope) {
    if (!handle || typeof handle.createWritable !== "function") {
      return false;
    }
    try {
      const writable = await handle.createWritable();
      await writable.write(JSON.stringify(envelope, null, 2));
      await writable.close();
      return true;
    } catch (_error) {
      return false;
    }
  }

  async applyRemoteEnvelopeToApp(envelope, source = "sync") {
    if (!envelope || !envelope.payload) {
      return false;
    }
    if (this.syncState.pendingSaveTimer) {
      clearTimeout(this.syncState.pendingSaveTimer);
      this.syncState.pendingSaveTimer = 0;
      this.syncState.pendingSaveReason = "";
    }
    this.syncState.suppressAutoPush = true;
    const result = this.store.importBackupPayload(envelope.payload);
    this.syncState.suppressAutoPush = false;
    if (!result.ok) {
      this.setSyncStatus(result.message || "Datenbankdatei konnte nicht geladen werden.", true);
      return false;
    }
    this.settingsDraft = this.buildSettingsDraftFromStore();
    this.settingsDirty = false;
    this.weekStartIso = this._clampWeekStart(currentWeekStartForDisplay());
    this.selectedLessonId = null;
    this.selectedCourseId = null;
    this.markKnownRemote(envelope);
    this.renderAll();
    if (source === "startup") {
      this.setSyncStatus("Datenbankdatei geladen.");
    } else {
      this.setSyncStatus("Remote-Stand geladen.");
    }
    return true;
  }

  async pushLocalStateToSyncFile({ manual = false, allowConflictPrompt = false, reason = "" } = {}) {
    if (!this.syncState.fileHandle) {
      if (manual) {
        this.setSyncStatus("Keine Datenbankdatei ausgewählt.", true);
      }
      return false;
    }
    if (this.syncState.syncingNow) {
      return false;
    }
    this.syncState.syncingNow = true;
    try {
      const handle = this.syncState.fileHandle;
      const localPayload = this.store.exportBackupPayload();
      const localHash = this.getPayloadStateHash(localPayload);
      const remoteEnvelope = await this.readSyncEnvelopeFromHandle(handle);
      const remoteRevision = remoteEnvelope ? Math.max(0, Number(remoteEnvelope.revision) || 0) : 0;
      const remoteHash = remoteEnvelope ? this.getPayloadStateHash(remoteEnvelope.payload) : "";
      const knownRevision = Math.max(0, Number(this.syncMeta.knownRemoteRevision) || 0);
      const knownHash = String(this.syncMeta.knownRemoteHash || "");

      if (remoteEnvelope && remoteHash && remoteHash === localHash) {
        this.markKnownRemote(remoteEnvelope);
        if (manual) {
          this.setSyncStatus("Bereits synchron.");
        }
        return true;
      }

      const remoteAdvanced = Boolean(remoteEnvelope && remoteRevision > knownRevision && remoteHash !== knownHash);
      const localChangedSinceSync = Boolean(knownHash && localHash !== knownHash);

      if (remoteAdvanced && localChangedSinceSync) {
        if (!allowConflictPrompt) {
          await this.applyRemoteEnvelopeToApp(remoteEnvelope, "sync");
          this.setSyncStatus("Sync-Konflikt erkannt. Remote-Stand wurde automatisch übernommen.");
          return true;
        }
        const loadRemote = await this.showConfirmMessage(
          "Die Datenbankdatei wurde auf einem anderen Gerät geändert.\n\nOK: Remote-Stand laden\nAbbrechen: Lokalen Stand in die Datei schreiben"
        );
        if (loadRemote) {
          return this.applyRemoteEnvelopeToApp(remoteEnvelope, "manual");
        }
      }

      const nextRevision = Math.max(remoteRevision, knownRevision) + 1;
      const createdAt = new Date().toISOString();
      const envelope = {
        schema: SYNC_ENVELOPE_SCHEMA,
        revision: nextRevision,
        updatedAt: createdAt,
        deviceId: String(this.syncMeta.deviceId || randomId()),
        reason: String(reason || ""),
        payload: localPayload
      };
      const writeOk = await this.writeSyncEnvelopeToHandle(handle, envelope);
      if (!writeOk) {
        this.setSyncStatus("Datenbankdatei konnte nicht geschrieben werden.", true);
        return false;
      }
      this.markKnownRemote(envelope);
      if (!manual) {
        this.setSyncStatus("Automatisch synchronisiert.");
      }
      return true;
    } finally {
      this.syncState.syncingNow = false;
    }
  }

  queueSyncSave(reason = "auto-save") {
    if (!this.syncState.initialized || !this.syncState.fileHandle || this.syncState.suppressAutoPush) {
      return;
    }
    if (this.syncState.pendingSaveTimer) {
      clearTimeout(this.syncState.pendingSaveTimer);
    }
    this.syncState.pendingSaveReason = reason;
    this.syncState.pendingSaveTimer = window.setTimeout(() => {
      this.syncState.pendingSaveTimer = 0;
      this.pushLocalStateToSyncFile({
        manual: false,
        allowConflictPrompt: false,
        reason: this.syncState.pendingSaveReason || "auto-save"
      }).catch(() => {
        this.setSyncStatus("Automatische Synchronisierung fehlgeschlagen.", true);
      });
    }, SYNC_SAVE_DEBOUNCE_MS);
  }

  handleStoreSaved() {
    if (!this.syncState.initialized || !this.syncState.fileHandle || this.syncState.suppressAutoPush) {
      return;
    }
    const localHash = this.getCurrentStateHash();
    if (!localHash) {
      return;
    }
    if (localHash === String(this.syncMeta.knownRemoteHash || "")) {
      return;
    }
    if (localHash === this.syncState.lastQueuedLocalHash) {
      return;
    }
    this.syncState.lastQueuedLocalHash = localHash;
    this.queueSyncSave("store-save");
  }

  async selectSyncFile(mode = "existing") {
    if (!this.syncState.supported) {
      await this.showInfoMessage(
        "Dieser Browser unterstützt keinen dauerhaften Dateizugriff für PWA-Sync.\nNutze dafür Chrome/Edge unter https oder localhost."
      );
      return;
    }
    let handle = null;
    try {
      if (mode === "new") {
        if (typeof window.showSaveFilePicker !== "function") {
          await this.showInfoMessage("Neue Datenbankdatei anlegen wird in diesem Browser nicht unterstützt.");
          return;
        }
        handle = await this.pickNewSyncFileHandle();
      } else {
        if (typeof window.showOpenFilePicker !== "function") {
          await this.showInfoMessage("Bestehende Datenbank auswählen wird in diesem Browser nicht unterstützt.");
          return;
        }
        handle = await this.pickExistingSyncFileHandle();
      }
    } catch (_error) {
      return;
    }
    if (!handle) {
      return;
    }
    if (!await this.ensureSyncFilePermission(handle, true)) {
      this.setSyncStatus("Zugriff auf die Datenbankdatei wurde verweigert.", true);
      return;
    }
    await this.connectSyncFileHandle(handle, "manual");
    this.syncState.initialized = true;
    this.renderAll();
  }

  async initializeExternalFileSync() {
    if (!this.syncState.supported) {
      this.syncState.initialized = true;
      this.setSyncStatus(
        "Datei-Sync wird in diesem Browser nicht unterstützt (nutze Chrome/Edge auf localhost/https).",
        true
      );
      this.openSyncSetupSettingsOnStartup();
      this.renderDatabaseSection();
      return;
    }
    const storedSyncHandle = await getStoredHandle(SYNC_HANDLE_FILE_KEY);
    if (!storedSyncHandle) {
      this.syncState.fileHandle = null;
      this.syncState.storedFileHandle = null;
      this.syncState.fileName = "";
      this.syncMeta.fileName = "";
      this.backupState.directoryHandle = null;
      this.backupState.storedDirectoryHandle = null;
      this.saveSyncMeta();
      this.syncState.initialized = true;
      this.setSyncStatus("Noch keine Datenbankdatei verbunden.");
      this.openSyncSetupSettingsOnStartup();
      this.renderDatabaseSection();
      return;
    }
    this.syncState.storedFileHandle = storedSyncHandle;
    this.syncState.fileName = String(storedSyncHandle.name || this.syncMeta.fileName || "");
    this.syncMeta.fileName = this.syncState.fileName;
    this.backupState.storedDirectoryHandle = await getStoredHandle(SYNC_HANDLE_BACKUP_DIR_KEY);
    if (!await this.hasSyncFilePermission(storedSyncHandle, false)) {
      this.syncState.fileHandle = null;
      this.backupState.directoryHandle = null;
      this.saveSyncMeta();
      this.syncState.initialized = true;
      this.setSyncStatus("Gespeicherte Datenbank gefunden. Bitte Zugriff erlauben.", true);
      this.openSyncSetupSettingsOnStartup();
      this.renderAll();
      return;
    }

    await this.connectSyncFileHandle(storedSyncHandle, "startup");

    this.currentView = "week";
    this.activeSettingsTab = "dayoff";
    this.weekStartIso = this._clampWeekStart(currentWeekStartForDisplay());
    this.selectedLessonId = null;
    this.selectedCourseId = null;
    this.syncState.initialized = true;
    this.renderAll();
  }

  openSyncSetupSettingsOnStartup() {
    if (this.locked) {
      return;
    }
    const isDefaultViewState = this.currentView === "week" && this.activeSettingsTab === "dayoff";
    const isAlreadySyncTab = this.currentView === "settings" && this.activeSettingsTab === "database";
    if (!isDefaultViewState && !isAlreadySyncTab) {
      return;
    }
    this.currentView = "settings";
    this.activeSettingsTab = "database";
    this.renderViewState();
    this.renderSettingsTabs();
    this.renderSidebarCourseList();
  }

  ensureStandaloneSettingsView() {
    if (!this.refs.stackGlass || !this.refs.viewSettings) {
      return;
    }
    let shell = this.refs.settingsShell;
    if (!shell) {
      shell = document.createElement("section");
      shell.id = "settings-shell";
      shell.className = "stack-glass";
      shell.hidden = true;
      this.refs.stackGlass.insertAdjacentElement("afterend", shell);
      this.refs.settingsShell = shell;
    }
    if (this.refs.viewSettings.parentElement !== shell) {
      shell.append(this.refs.viewSettings);
    }
  }

  initNumberSteppers() {
    const inputs = [...document.querySelectorAll("input[type='number']")];
    for (const input of inputs) {
      if (input.dataset.stepperInit === "1") {
        continue;
      }
      input.dataset.stepperInit = "1";

      const wrapper = document.createElement("span");
      wrapper.className = "number-stepper";
      input.parentNode.insertBefore(wrapper, input);
      wrapper.append(input);

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "number-stepper-btn minus";
      minus.textContent = "-";
      minus.setAttribute("tabindex", "-1");
      minus.setAttribute("aria-label", "Wert verringern");

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "number-stepper-btn plus";
      plus.textContent = "+";
      plus.setAttribute("tabindex", "-1");
      plus.setAttribute("aria-label", "Wert erhöhen");

      wrapper.append(minus, plus);
      input._stepperMinus = minus;
      input._stepperPlus = plus;

      this.bindNumberStepperButton(input, minus, -1);
      this.bindNumberStepperButton(input, plus, 1);

      const sync = () => this.syncNumberStepperState(input);
      input.addEventListener("input", sync);
      input.addEventListener("change", sync);
      sync();
    }
  }

  bindNumberStepperButton(input, button, direction) {
    let holdTimeout = 0;
    let holdInterval = 0;
    const clearHold = () => {
      if (holdTimeout) {
        clearTimeout(holdTimeout);
        holdTimeout = 0;
      }
      if (holdInterval) {
        clearInterval(holdInterval);
        holdInterval = 0;
      }
    };
    const trigger = () => {
      this.stepNumberInput(input, direction);
    };

    button.addEventListener("pointerdown", (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      trigger();
      clearHold();
      holdTimeout = window.setTimeout(() => {
        holdInterval = window.setInterval(trigger, 80);
      }, 320);
    });

    for (const eventName of ["pointerup", "pointercancel", "pointerleave", "blur"]) {
      button.addEventListener(eventName, clearHold);
    }
    window.addEventListener("pointerup", clearHold);
  }

  stepNumberInput(input, direction) {
    if (!input || input.disabled || input.readOnly) {
      return;
    }
    const previous = String(input.value || "");
    try {
      if (direction < 0) {
        input.stepDown();
      } else {
        input.stepUp();
      }
    } catch (_err) {
      const base = Number.isFinite(Number(input.value))
        ? Number(input.value)
        : (input.min !== "" && Number.isFinite(Number(input.min)) ? Number(input.min) : 0);
      const step = input.step && input.step !== "any" && Number.isFinite(Number(input.step))
        ? Number(input.step)
        : 1;
      let next = base + (step * direction);
      if (input.min !== "" && Number.isFinite(Number(input.min))) {
        next = Math.max(Number(input.min), next);
      }
      if (input.max !== "" && Number.isFinite(Number(input.max))) {
        next = Math.min(Number(input.max), next);
      }
      input.value = String(next);
    }

    if (String(input.value || "") !== previous) {
      input.dispatchEvent(new Event("input", { bubbles: true }));
      input.dispatchEvent(new Event("change", { bubbles: true }));
    }
    this.syncNumberStepperState(input);
  }

  syncNumberStepperState(input) {
    if (!input || !input._stepperMinus || !input._stepperPlus) {
      return;
    }
    const disabled = Boolean(input.disabled || input.readOnly);
    let disableMinus = disabled;
    let disablePlus = disabled;

    const hasValue = String(input.value || "").trim() !== "";
    const value = Number(input.value);
    const min = Number(input.min);
    const max = Number(input.max);

    if (!disabled && hasValue && Number.isFinite(value)) {
      if (input.min !== "" && Number.isFinite(min) && value <= min) {
        disableMinus = true;
      }
      if (input.max !== "" && Number.isFinite(max) && value >= max) {
        disablePlus = true;
      }
    }

    input._stepperMinus.disabled = disableMinus;
    input._stepperPlus.disabled = disablePlus;
  }

  syncAllNumberSteppers() {
    const inputs = document.querySelectorAll("input[type='number'][data-stepper-init='1']");
    for (const input of inputs) {
      this.syncNumberStepperState(input);
    }
  }

  isSettingsDraftDirty() {
    const draft = this.settingsDraft || this.buildSettingsDraftFromStore();
    if (Number(draft.hoursPerDay) !== Number(this.store.getHoursPerDay())) {
      return true;
    }
    if (
      Boolean(draft.showHiddenSidebarCourses)
      !== Boolean(this.store.getSetting("showHiddenSidebarCourses", SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT))
    ) {
      return true;
    }
    if (Boolean(draft.backupEnabled) !== Boolean(this.store.getBackupEnabled())) {
      return true;
    }
    if (Number(draft.backupIntervalDays) !== Number(this.store.getBackupIntervalDays())) {
      return true;
    }
    return false;
  }

  isSettingsBackupDraftDefault() {
    const draft = this.settingsDraft || this.buildSettingsDraftFromStore();
    return (
      Boolean(draft.backupEnabled) === BACKUP_ENABLED_DEFAULT
      && Number(draft.backupIntervalDays) === BACKUP_INTERVAL_DEFAULT_DAYS
    );
  }

  refreshSettingsDirtyState() {
    this.settingsDirty = this.isSettingsDraftDirty();
    this.updateSettingsActionButtons();
  }

  applySettingsDraftToStore() {
    const draft = this.settingsDraft || this.buildSettingsDraftFromStore();
    this.store.setHoursPerDay(draft.hoursPerDay);
    this.store.setSetting("showHiddenSidebarCourses", Boolean(draft.showHiddenSidebarCourses));
    this.store.setBackupEnabled(draft.backupEnabled);
    this.store.setBackupIntervalDays(draft.backupIntervalDays);
    if (this.store.getBackupEnabled()) {
      this.maybeRunAutomaticWebBackup();
    }
    this.settingsDraft = this.buildSettingsDraftFromStore();
    this.settingsDirty = false;
    this.selectedLessonId = null;
    this.renderAll();
  }

  cancelSettingsDraftChanges() {
    this.settingsDraft = this.buildSettingsDraftFromStore();
    this.settingsDirty = false;
    this.renderDisplaySection();
    this.renderBackupSection();
    this.renderDatabaseSection();
    this.updateSettingsActionButtons();
  }

  async applyDayoffDefaults() {
    const year = this.activeSchoolYear;
    if (!year) {
      return false;
    }
    if (!await this.showConfirmMessage("Standardwerte für Pflicht-Ferien und unterrichtsfreie Tage anwenden?")) {
      return false;
    }
    const overwrite = await this.showConfirmMessage("Sollen vorhandene Pflicht-Ferienwerte überschrieben werden?");
    const startYear = Number(String(year.startDate).slice(0, 4));
    const defaults = defaultHolidayRangesForYear(startYear);
    if (!defaults || Object.keys(defaults).length === 0) {
      await this.showInfoMessage("Für dieses Schuljahr sind keine Standard-Ferienwerte hinterlegt.");
      return false;
    }
    this.store.applyHolidayDefaultsForYear(year.id, overwrite);
    this.store.resetSpecialDays(startYear);
    this.renderAll();
    return true;
  }

  async applySettingsDefaultsForActiveTab() {
    const tab = this.activeSettingsTab;
    if (tab === "dayoff") {
      await this.applyDayoffDefaults();
      return;
    }
    if (tab === "display") {
      this.settingsDraft.hoursPerDay = HOURS_PER_DAY_DEFAULT;
      this.settingsDraft.showHiddenSidebarCourses = SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT;
      this.renderDisplaySection();
      this.refreshSettingsDirtyState();
      return;
    }
    if (tab === "backup" || tab === "database") {
      this.settingsDraft.backupEnabled = BACKUP_ENABLED_DEFAULT;
      this.settingsDraft.backupIntervalDays = BACKUP_INTERVAL_DEFAULT_DAYS;
      this.renderBackupSection();
      this.refreshSettingsDirtyState();
    }
  }

  applySettingsSaveForActiveTab() {
    const tab = this.activeSettingsTab;
    if (tab === "display" || tab === "backup" || tab === "database") {
      if (!this.settingsDirty) {
        return;
      }
      this.applySettingsDraftToStore();
    }
  }

  applySettingsCancelForActiveTab() {
    const tab = this.activeSettingsTab;
    if (tab === "display" || tab === "backup" || tab === "database") {
      this.cancelSettingsDraftChanges();
      return;
    }
    if (tab === "dayoff") {
      this.renderDayOffSection();
    }
  }

  updateSettingsActionButtons() {
    if (!this.refs.settingsResetAll || !this.refs.settingsSaveAll || !this.refs.settingsCancelAll) {
      return;
    }
    const tab = this.activeSettingsTab;
    if (this.refs.settingsActionsRow) {
      this.refs.settingsActionsRow.hidden = tab === "version";
    }
    let resetEnabled = false;
    let saveEnabled = false;
    let cancelEnabled = false;

    if (tab === "dayoff") {
      resetEnabled = Boolean(this.activeSchoolYear);
    } else if (tab === "display") {
      resetEnabled = Number(this.settingsDraft.hoursPerDay) !== HOURS_PER_DAY_DEFAULT
        || Boolean(this.settingsDraft.showHiddenSidebarCourses) !== SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT;
      saveEnabled = this.settingsDirty;
      cancelEnabled = this.settingsDirty;
    } else if (tab === "database") {
      if (this.lockReason === "databaseRequired" || this.lockReason === "backupDirRequired") {
        resetEnabled = false;
        saveEnabled = false;
        cancelEnabled = false;
      } else {
        resetEnabled = !this.isSettingsBackupDraftDefault();
        saveEnabled = this.settingsDirty;
        cancelEnabled = this.settingsDirty;
      }
    } else if (tab === "backup") {
      resetEnabled = !this.isSettingsBackupDraftDefault();
      saveEnabled = this.settingsDirty;
      cancelEnabled = this.settingsDirty;
    }

    this.refs.settingsResetAll.disabled = !resetEnabled;
    this.refs.settingsSaveAll.disabled = !saveEnabled;
    this.refs.settingsCancelAll.disabled = !cancelEnabled;
  }

  _currentIsoWeek() {
    return isoWeekNumber(this.weekStartIso);
  }

  _summerBreakBounds() {
    const year = this.activeSchoolYear;
    if (!year) {
      return { start: null, end: null };
    }
    const startYear = Number(String(year.startDate || "").slice(0, 4));
    const currentDefaults = defaultHolidayRangesForYear(startYear);
    const nextDefaults = defaultHolidayRangesForYear(startYear + 1);
    const currentSummer = Array.isArray(currentDefaults.Sommerferien)
      ? currentDefaults.Sommerferien
      : null;
    const nextSummer = Array.isArray(nextDefaults.Sommerferien)
      ? nextDefaults.Sommerferien
      : null;

    const ranges = this.store
      .listFreeRanges(year.id)
      .filter((item) => String(item.label || "").trim().toLowerCase() === "sommerferien");
    let start = ranges.find((item) => Boolean(item.startDate))?.startDate || null;
    let end = ranges.find((item) => Boolean(item.endDate))?.endDate || null;

    if (!end && currentSummer && currentSummer[1]) {
      end = currentSummer[1];
    }
    if (!start && nextSummer && nextSummer[0]) {
      start = nextSummer[0];
    }

    if (start && end && start <= end) {
      if (nextSummer && nextSummer[0]) {
        start = nextSummer[0];
      } else {
        start = year.endDate;
      }
    }

    return {
      start: start || null,
      end: end || null
    };
  }

  _weekBounds() {
    const year = this.activeSchoolYear;
    if (!year) {
      return { min: null, max: null };
    }
    const summer = this._summerBreakBounds();
    if (summer.start && summer.end) {
      const min = weekStartFor(summer.end);
      const max = weekStartFor(summer.start);
      if (min <= max) {
        return { min, max };
      }
    }
    return {
      min: weekStartFor(year.startDate),
      max: weekStartFor(year.endDate)
    };
  }

  _clampWeekStart(iso) {
    const { min, max } = this._weekBounds();
    if (min && iso < min) {
      return min;
    }
    if (max && iso > max) {
      return max;
    }
    return iso;
  }

  isAccessLocked() {
    const year = this.activeSchoolYear;
    if (!year) {
      return true;
    }
    return !this.store.requiredHolidaysComplete(year.id);
  }

  updateAccessLock() {
    const databaseRequired = !this.syncState.fileHandle;
    const backupDirRequired = !databaseRequired && !this.backupState.directoryHandle;
    const holidaysRequired = !databaseRequired && !backupDirRequired && this.isAccessLocked();
    this.lockReason = databaseRequired
      ? "databaseRequired"
      : (backupDirRequired ? "backupDirRequired" : (holidaysRequired ? "holidaysRequired" : ""));
    this.locked = this.lockReason !== "";
    if (this.locked) {
      this.closeWeekCalendarDialog();
      this.closeTopicDialog();
      this.resetInlineWeekBlockTopicEdit();
      this.currentView = "settings";
      this.activeSettingsTab = (this.lockReason === "databaseRequired" || this.lockReason === "backupDirRequired")
        ? "database"
        : "dayoff";
    }
    this.refs.viewWeekBtn.disabled = this.locked;
    this.refs.viewSettingsBtn.disabled = this.locked;
    this.updateSettingsActionButtons();
  }

  updateWeekNavigation() {
    const { min, max } = this._weekBounds();
    const atMin = Boolean(min && this.weekStartIso <= min);
    const atMax = Boolean(max && this.weekStartIso >= max);
    const currentWeekTarget = currentWeekStartForDisplay();
    this.refs.weekPrev.disabled = this.locked || atMin;
    this.refs.weekNext.disabled = this.locked || atMax;
    this.refs.kwLabel.disabled = this.locked;
    this.refs.weekPickerBtn.disabled = this.locked || this.weekStartIso === currentWeekTarget;
    this.refs.weekDate.disabled = this.locked;
  }

  _weekCalendarRange() {
    const { min, max } = this._weekBounds();
    if (min && max) {
      return {
        minDate: min,
        maxDate: addDays(max, 6)
      };
    }
    const year = this.activeSchoolYear;
    if (!year) {
      return { minDate: null, maxDate: null };
    }
    return {
      minDate: year.startDate,
      maxDate: year.endDate
    };
  }

  _weekCalendarMonthStartFor(iso) {
    const value = parseIsoDate(iso);
    if (!value) {
      return null;
    }
    return toIsoDate(new Date(value.getFullYear(), value.getMonth(), 1));
  }

  _weekCalendarShiftMonth(iso, delta) {
    const value = parseIsoDate(iso);
    if (!value) {
      return null;
    }
    return toIsoDate(new Date(value.getFullYear(), value.getMonth() + Number(delta || 0), 1));
  }

  _clampWeekCalendarMonth(monthIso) {
    const { minDate, maxDate } = this._weekCalendarRange();
    const minMonth = minDate ? this._weekCalendarMonthStartFor(minDate) : null;
    const maxMonth = maxDate ? this._weekCalendarMonthStartFor(maxDate) : null;
    let value = this._weekCalendarMonthStartFor(monthIso)
      || this._weekCalendarMonthStartFor(this.weekStartIso)
      || this._weekCalendarMonthStartFor(toIsoDate(new Date()));
    if (!value) {
      return null;
    }
    if (minMonth && value < minMonth) {
      value = minMonth;
    }
    if (maxMonth && value > maxMonth) {
      value = maxMonth;
    }
    return value;
  }

  syncWeekCalendarNavButtons() {
    if (!this.refs.weekCalendarPrev || !this.refs.weekCalendarNext) {
      return;
    }
    const { minDate, maxDate } = this._weekCalendarRange();
    const minMonth = minDate ? this._weekCalendarMonthStartFor(minDate) : null;
    const maxMonth = maxDate ? this._weekCalendarMonthStartFor(maxDate) : null;
    const month = this.weekCalendarMonthIso;
    this.refs.weekCalendarPrev.disabled = this.locked || !month || Boolean(minMonth && month <= minMonth);
    this.refs.weekCalendarNext.disabled = this.locked || !month || Boolean(maxMonth && month >= maxMonth);
  }

  syncWeekCalendarMonthOptions() {
    const select = this.refs.weekCalendarMonth;
    if (!select) {
      return;
    }
    this.weekCalendarMonthIso = this._clampWeekCalendarMonth(this.weekCalendarMonthIso || this.weekStartIso);
    const { minDate, maxDate } = this._weekCalendarRange();

    let startMonth = minDate ? this._weekCalendarMonthStartFor(minDate) : null;
    let endMonth = maxDate ? this._weekCalendarMonthStartFor(maxDate) : null;
    if (!startMonth || !endMonth) {
      const anchor = parseIsoDate(this.weekCalendarMonthIso || this.weekStartIso || toIsoDate(new Date()));
      startMonth = toIsoDate(new Date(anchor.getFullYear() - 1, 0, 1));
      endMonth = toIsoDate(new Date(anchor.getFullYear() + 1, 11, 1));
    }
    if (startMonth > endMonth) {
      const swap = startMonth;
      startMonth = endMonth;
      endMonth = swap;
    }

    select.innerHTML = "";
    let cursor = startMonth;
    let guard = 0;
    while (cursor && cursor <= endMonth && guard < 60) {
      const value = parseIsoDate(cursor);
      const option = document.createElement("option");
      option.value = cursor;
      option.textContent = value
        ? value.toLocaleDateString("de-DE", { month: "long", year: "numeric" })
        : cursor;
      select.append(option);
      cursor = this._weekCalendarShiftMonth(cursor, 1);
      guard += 1;
    }

    if (!select.querySelector(`option[value="${this.weekCalendarMonthIso}"]`) && select.options.length > 0) {
      this.weekCalendarMonthIso = select.options[0].value;
    }
    if (this.weekCalendarMonthIso) {
      select.value = this.weekCalendarMonthIso;
    }
    this.syncWeekCalendarNavButtons();
  }

  setWeekCalendarHoverWeek(weekStartIso) {
    const grid = this.refs.weekCalendarGrid;
    if (!grid) {
      this.weekCalendarHoverWeekStart = null;
      return;
    }
    const rows = [...grid.querySelectorAll("tr.week-calendar-row[data-week-start]")];
    let target = weekStartIso ? String(weekStartIso) : null;
    if (target && !rows.some((row) => row.dataset.weekStart === target)) {
      target = null;
    }
    this.weekCalendarHoverWeekStart = target;
    for (const row of rows) {
      row.classList.toggle("hovered", Boolean(target && row.dataset.weekStart === target));
    }
  }

  renderWeekCalendarGrid() {
    const grid = this.refs.weekCalendarGrid;
    if (!grid) {
      return;
    }
    this.weekCalendarMonthIso = this._clampWeekCalendarMonth(this.weekCalendarMonthIso || this.weekStartIso);
    const monthIso = this.weekCalendarMonthIso;
    if (!monthIso) {
      grid.innerHTML = "";
      return;
    }

    const monthStart = parseIsoDate(monthIso);
    if (!monthStart) {
      grid.innerHTML = "";
      return;
    }

    const monthTag = monthIso.slice(0, 7);
    const gridStart = weekStartFor(monthIso);
    const selectedWeekStart = this._clampWeekStart(this.weekStartIso);
    const selectedInMonth = selectedWeekStart.slice(0, 7) === monthTag;
    let selectedRow = null;
    if (selectedInMonth) {
      const diffDays = Math.round((parseIsoDate(selectedWeekStart) - parseIsoDate(gridStart)) / 86400000);
      if (diffDays >= 0 && diffDays < 42 && diffDays % 7 === 0) {
        selectedRow = diffDays / 7;
      }
    }

    const todayIso = toIsoDate(new Date());
    const todayWeekStart = currentWeekStartForDisplay();
    const { minDate, maxDate } = this._weekCalendarRange();
    grid.innerHTML = "";

    for (let row = 0; row < 6; row += 1) {
      const weekStart = addDays(gridStart, row * 7);
      const weekEnd = addDays(weekStart, 6);
      const rowInRange = (!minDate || weekEnd >= minDate) && (!maxDate || weekStart <= maxDate);

      const tr = document.createElement("tr");
      tr.className = "week-calendar-row";
      tr.dataset.weekStart = weekStart;
      if (row === selectedRow) {
        tr.classList.add("active");
      }
      if (rowInRange && weekStart === todayWeekStart) {
        tr.classList.add("today-week");
      }
      if (!rowInRange) {
        tr.classList.add("out-of-range");
      }

      const kwCell = document.createElement("td");
      kwCell.className = "week-calendar-week-cell";
      const kwButton = document.createElement("button");
      kwButton.type = "button";
      kwButton.className = "week-calendar-week-btn";
      kwButton.textContent = String(isoWeekNumber(weekStart)).padStart(2, "0");
      kwButton.dataset.weekStart = weekStart;
      kwButton.disabled = this.locked || !rowInRange;
      kwCell.append(kwButton);
      tr.append(kwCell);

      for (let col = 0; col < 5; col += 1) {
        const dayIso = addDays(weekStart, col);
        const dayDate = parseIsoDate(dayIso);
        const inRange = rowInRange && (!minDate || dayIso >= minDate) && (!maxDate || dayIso <= maxDate);

        const td = document.createElement("td");
        const dayButton = document.createElement("button");
        dayButton.type = "button";
        dayButton.className = "week-calendar-day-btn";
        dayButton.textContent = dayDate ? String(dayDate.getDate()) : "";
        dayButton.dataset.weekStart = weekStart;
        dayButton.dataset.date = dayIso;
        dayButton.disabled = this.locked || !inRange;
        if (dayIso.slice(0, 7) !== monthTag) {
          dayButton.classList.add("outside-month");
        }
        if (dayIso === todayIso) {
          dayButton.classList.add("today");
        }
        td.append(dayButton);
        tr.append(td);
      }

      grid.append(tr);
    }
    this.setWeekCalendarHoverWeek(this.weekCalendarHoverWeekStart);
    this.syncWeekCalendarNavButtons();
  }

  positionWeekCalendarDialog() {
    const dialog = this.refs.weekCalendarDialog;
    const anchor = this.refs.kwLabel;
    if (!dialog || !anchor) {
      return;
    }
    const margin = 8;
    const maxWidth = Math.min(368, window.innerWidth - (margin * 2));
    const anchorRect = anchor.getBoundingClientRect();
    const dialogRect = dialog.getBoundingClientRect();
    const dialogHeight = dialogRect.height > 0 ? dialogRect.height : 360;
    const left = clamp(
      Math.round(anchorRect.left + (anchorRect.width / 2) - (maxWidth / 2)),
      margin,
      Math.max(margin, window.innerWidth - maxWidth - margin)
    );
    const top = clamp(
      Math.round(anchorRect.bottom + 8),
      margin,
      Math.max(margin, window.innerHeight - dialogHeight - margin)
    );
    dialog.style.width = `${maxWidth}px`;
    dialog.style.left = `${left}px`;
    dialog.style.top = `${top}px`;
  }

  closeWeekCalendarDialog() {
    if (!this.refs.weekCalendarDialog) {
      return;
    }
    this.setWeekCalendarHoverWeek(null);
    this.closeDialog(this.refs.weekCalendarDialog);
  }

  applyWeekCalendarSelection(weekStartIso) {
    const selected = this._clampWeekStart(weekStartIso);
    this.closeWeekCalendarDialog();
    if (!selected || selected === this.weekStartIso) {
      return;
    }
    this.weekStartIso = selected;
    this.selectedLessonId = null;
    this.renderWeekSection();
    this.renderLessonSection();
  }

  openWeekMiniCalendar() {
    if (this.locked) {
      return;
    }
    const dialog = this.refs.weekCalendarDialog;
    if (dialog && this.refs.weekCalendarMonth && this.refs.weekCalendarGrid) {
      if (dialog.open) {
        this.closeWeekCalendarDialog();
        return;
      }
      this.weekCalendarMonthIso = this._clampWeekCalendarMonth(this.weekStartIso);
      this.syncWeekCalendarMonthOptions();
      this.renderWeekCalendarGrid();
      this.positionWeekCalendarDialog();
      this.openDialog(dialog);
      requestAnimationFrame(() => {
        this.positionWeekCalendarDialog();
      });
      return;
    }
    const input = this.refs.weekDate;
    if (!input) {
      return;
    }
    if (typeof input.showPicker === "function") {
      input.showPicker();
      return;
    }
    input.click();
    input.focus();
  }

  openDialog(dialog) {
    if (!dialog) {
      return;
    }
    if (typeof dialog.showModal === "function") {
      if (!dialog.open) {
        try {
          dialog.showModal();
        } catch (_error) {
          dialog.setAttribute("open", "open");
        }
      }
      return;
    }
    dialog.setAttribute("open", "open");
  }

  closeDialog(dialog) {
    if (!dialog) {
      return;
    }
    if (typeof dialog.close === "function") {
      if (dialog.open) {
        dialog.close();
      }
      return;
    }
    dialog.removeAttribute("open");
  }

  _resolveMessageDialog(action = "cancel") {
    const resolver = this.pendingMessageDialogResolver;
    const mode = this.pendingMessageDialogMode || "alert";
    this.pendingMessageDialogResolver = null;
    this.pendingMessageDialogMode = null;
    this.closeDialog(this.refs.messageDialog);
    if (!resolver) {
      return;
    }
    if (mode === "confirm") {
      resolver(action === "ok");
      return;
    }
    if (mode === "prompt") {
      if (action === "ok") {
        resolver(String(this.refs.messageDialogInput.value || ""));
      } else {
        resolver(null);
      }
      return;
    }
    resolver(undefined);
  }

  showMessageDialog({
    mode = "alert",
    title = "Hinweis",
    message = "",
    okText = "OK",
    cancelText = "Abbrechen",
    defaultValue = ""
  } = {}) {
    const normalizedMode = mode === "confirm" || mode === "prompt" ? mode : "alert";
    if (
      !this.refs.messageDialog
      || !this.refs.messageDialogTitle
      || !this.refs.messageDialogText
      || !this.refs.messageDialogOk
      || !this.refs.messageDialogCancel
      || !this.refs.messageDialogInput
      || !this.refs.messageDialogInputRow
    ) {
      if (normalizedMode === "confirm") {
        return Promise.resolve(false);
      }
      if (normalizedMode === "prompt") {
        return Promise.resolve(null);
      }
      return Promise.resolve(undefined);
    }
    if (this.pendingMessageDialogResolver) {
      this._resolveMessageDialog("cancel");
    }
    this.refs.messageDialogTitle.textContent = String(title || "Hinweis");
    this.refs.messageDialogText.textContent = String(message || "");
    this.refs.messageDialogOk.textContent = String(okText || "OK");
    this.refs.messageDialogCancel.textContent = String(cancelText || "Abbrechen");
    const isPrompt = normalizedMode === "prompt";
    this.refs.messageDialogInputRow.hidden = !isPrompt;
    this.refs.messageDialogCancel.hidden = normalizedMode === "alert";
    if (isPrompt) {
      this.refs.messageDialogInput.value = String(defaultValue || "");
    } else {
      this.refs.messageDialogInput.value = "";
    }

    return new Promise((resolve) => {
      this.pendingMessageDialogResolver = resolve;
      this.pendingMessageDialogMode = normalizedMode;
      this.openDialog(this.refs.messageDialog);
      requestAnimationFrame(() => {
        if (isPrompt) {
          this.refs.messageDialogInput.focus();
          this.refs.messageDialogInput.select();
        } else {
          this.refs.messageDialogOk.focus();
        }
      });
    });
  }

  async showInfoMessage(message, title = "Hinweis") {
    await this.showMessageDialog({
      mode: "alert",
      title,
      message,
      okText: "OK"
    });
  }

  async showConfirmMessage(message, options = {}) {
    return this.showMessageDialog({
      mode: "confirm",
      title: options.title || "Bitte bestätigen",
      message,
      okText: options.okText || "Ja",
      cancelText: options.cancelText || "Abbrechen"
    });
  }

  async showPromptMessage(message, defaultValue = "", options = {}) {
    return this.showMessageDialog({
      mode: "prompt",
      title: options.title || "Eingabe",
      message,
      okText: options.okText || "Übernehmen",
      cancelText: options.cancelText || "Abbrechen",
      defaultValue
    });
  }

  _courseDialogExistingColors(excludeCourseId = null) {
    const year = this.activeSchoolYear;
    if (!year) {
      return [];
    }
    const excludedId = Number(excludeCourseId || 0);
    return this.store
      .listCourses(year.id)
      .filter((item) => !item.noLesson)
      .filter((item) => !excludedId || Number(item.id) !== excludedId)
      .map((item) => normalizeCourseColor(item.color, false));
  }

  _renderCourseDialogColorPalette(existingColors = []) {
    const palette = this.refs.courseDialogColorPalette;
    if (!palette) {
      return;
    }
    const usedColors = new Set(
      existingColors
        .map((item) => normalizeHexColor(item, DEFAULT_COURSE_COLOR).toLowerCase())
    );
    palette.innerHTML = "";
    for (const baseColor of COLOR_PALETTE) {
      const color = normalizeHexColor(baseColor, DEFAULT_COURSE_COLOR);
      const isUsed = usedColors.has(color.toLowerCase());
      const button = document.createElement("button");
      button.type = "button";
      button.className = "course-color-btn";
      button.dataset.color = color;
      button.dataset.used = isUsed ? "1" : "0";
      button.disabled = isUsed;
      if (isUsed) {
        button.classList.add("used");
      }
      const fill = document.createElement("span");
      fill.className = "swatch-fill";
      fill.style.backgroundColor = color;
      button.append(fill);
      button.title = isUsed ? "Farbe bereits vergeben" : color;
      palette.append(button);
    }
    this._updateCourseDialogColorHighlight();
  }

  _updateCourseDialogColorHighlight() {
    const palette = this.refs.courseDialogColorPalette;
    if (!palette) {
      return;
    }
    const selected = canonicalHexColor(this.courseDialogSelectedColor || "");
    const selectedLower = selected ? selected.toLowerCase() : "";
    const buttons = [...palette.querySelectorAll("button.course-color-btn[data-color]")];
    for (const button of buttons) {
      const isUsed = button.dataset.used === "1";
      if (isUsed) {
        button.classList.remove("selected");
        continue;
      }
      const color = String(button.dataset.color || "").toLowerCase();
      button.classList.toggle("selected", Boolean(selectedLower && color === selectedLower));
    }
  }

  selectCourseDialogColor(color) {
    this.courseDialogSelectedColor = normalizeHexColor(
      color,
      this.courseDialogDefaultColor || DEFAULT_COURSE_COLOR
    );
    this._updateCourseDialogColorHighlight();
  }

  syncCourseDialogNoLessonState() {
    if (!this.refs.courseDialogNoLesson) {
      return;
    }
    const checked = Boolean(this.refs.courseDialogNoLesson.checked);
    if (checked) {
      if (this.courseDialogSelectedColor) {
        this.courseDialogColorBackup = this.courseDialogSelectedColor;
      }
      this.courseDialogSelectedColor = null;
    } else if (!this.courseDialogSelectedColor) {
      this.courseDialogSelectedColor = normalizeHexColor(
        this.courseDialogColorBackup || this.courseDialogDefaultColor,
        DEFAULT_COURSE_COLOR
      );
    }
    if (this.refs.courseDialogColorPanel) {
      this.refs.courseDialogColorPanel.classList.toggle("disabled", checked);
      this.refs.courseDialogColorPanel.setAttribute("aria-disabled", checked ? "true" : "false");
    }
    if (this.refs.courseDialogColorPalette) {
      this.refs.courseDialogColorPalette.setAttribute("aria-disabled", checked ? "true" : "false");
    }
    this._updateCourseDialogColorHighlight();
  }

  syncCourseDialogSidebarToggleButton() {
    if (!this.refs.courseDialogToggleSidebar) {
      return;
    }
    const id = Number(this.refs.courseDialogId.value || 0);
    if (!id) {
      this.refs.courseDialogToggleSidebar.hidden = true;
      return;
    }
    const year = this.activeSchoolYear;
    const course = year
      ? this.store.listCourses(year.id).find((item) => item.id === id)
      : null;
    const hidden = Boolean(course && course.hiddenInSidebar);
    this.refs.courseDialogToggleSidebar.hidden = false;
    this.refs.courseDialogToggleSidebar.textContent = hidden
      ? "Einblenden"
      : "Ausblenden";
  }

  openCourseDialog(courseId = null) {
    const year = this.activeSchoolYear;
    if (!year || !this.refs.courseDialog) {
      return;
    }
    const numericId = Number(courseId || 0);
    const course = numericId
      ? this.store.listCourses(year.id).find((item) => item.id === numericId)
      : null;
    const existingColors = this._courseDialogExistingColors(course ? course.id : null);
    const defaultColor = suggestColor(existingColors);

    this.refs.courseDialogId.value = course ? String(course.id) : "";
    this.refs.courseDialogTitle.textContent = course ? "Kurs anpassen" : "Kurs anlegen";
    this.refs.courseDialogName.value = course ? String(course.name || "") : "";
    this.courseDialogDefaultColor = defaultColor;
    this.courseDialogSelectedColor = (course && !course.noLesson)
      ? normalizeCourseColor(course.color, false)
      : defaultColor;
    this.courseDialogColorBackup = this.courseDialogSelectedColor;
    this._renderCourseDialogColorPalette(existingColors);
    this.refs.courseDialogNoLesson.checked = course ? Boolean(course.noLesson) : false;
    this.syncCourseDialogNoLessonState();
    this.syncCourseDialogSidebarToggleButton();
    this.refs.courseDialogDelete.hidden = !course;

    this.openDialog(this.refs.courseDialog);
    this.refs.courseDialogName.focus();
    this.refs.courseDialogName.select();
  }

  closeCourseDialog() {
    this.closeDialog(this.refs.courseDialog);
  }

  async submitCourseDialog() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const id = Number(this.refs.courseDialogId.value || 0);
    const name = String(this.refs.courseDialogName.value || "").trim();
    const noLesson = Boolean(this.refs.courseDialogNoLesson.checked);
    const color = noLesson
      ? null
      : normalizeHexColor(this.courseDialogSelectedColor, suggestColor(this._courseDialogExistingColors(id)));
    if (!name) {
      this.refs.courseDialogName.focus();
      return;
    }

    if (id) {
      const ok = this.store.updateCourse(year.id, id, name, color, noLesson);
      if (!ok) {
        await this.showInfoMessage("Kursname bereits vorhanden.");
        return;
      }
      if (noLesson && this.selectedCourseId === id) {
        this.selectedCourseId = null;
      }
    } else {
      const created = this.store.createCourse(year.id, name, color, noLesson);
      if (!created) {
        await this.showInfoMessage("Kursname bereits vorhanden.");
        return;
      }
      if (!noLesson && !this.selectedCourseId) {
        this.selectedCourseId = created;
      }
    }

    this.closeCourseDialog();
    this.renderAll();
  }

  toggleCourseSidebarVisibilityFromDialog() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const id = Number(this.refs.courseDialogId.value || 0);
    if (!id) {
      return;
    }
    const course = this.store.listCourses(year.id).find((item) => item.id === id);
    if (!course) {
      return;
    }
    const nextHidden = !Boolean(course.hiddenInSidebar);
    const ok = this.store.setCourseSidebarHidden(year.id, id, nextHidden);
    if (!ok) {
      return;
    }
    if (nextHidden && this.selectedCourseId === id) {
      this.selectedCourseId = null;
    }
    if (!nextHidden && !course.noLesson && !this.selectedCourseId) {
      this.selectedCourseId = id;
    }
    this.closeCourseDialog();
    this.renderAll();
  }

  async deleteCourseFromDialog() {
    const id = Number(this.refs.courseDialogId.value || 0);
    if (!id) {
      return;
    }
    if (!await this.showConfirmMessage("Soll dieser Kurs wirklich gelöscht werden?")) {
      return;
    }
    this.store.deleteCourse(id);
    if (this.selectedCourseId === id) {
      this.selectedCourseId = null;
    }
    if (Number(this.refs.slotCourse.value) === id) {
      this.resetSlotForm();
    }
    this.selectedLessonId = null;
    this.closeCourseDialog();
    this.renderAll();
  }

  openFreeRangeDialog(rangeId = null, presetLabel = "", presetOccurrence = 0) {
    const year = this.activeSchoolYear;
    if (!year || !this.refs.freeRangeDialog) {
      return;
    }
    const numericId = Number(rangeId || 0);
    const row = numericId
      ? this.store.listFreeRanges(year.id).find((item) => item.id === numericId)
      : null;

    const preset = String(presetLabel || "").trim();
    this.refs.freeRangeDialogId.value = row ? String(row.id) : "";
    this.refs.freeRangeDialogTitle.textContent = (row || preset) ? "Ferienzeitraum anpassen" : "Ferienzeitraum";
    this.refs.freeRangeDialogLabel.value = row ? String(row.label || "") : preset;
    this.refs.freeRangeDialogLabel.dataset.presetOccurrence = row ? "" : String(Number(presetOccurrence) || 0);
    this.refs.freeRangeDialogStart.value = row ? String(row.startDate || "") : "";
    this.refs.freeRangeDialogEnd.value = row ? String(row.endDate || "") : "";
    if (this.refs.freeRangeDialogDelete) {
      this.refs.freeRangeDialogDelete.hidden = !row;
    }

    if (!row && preset) {
      this.applySuggestedHolidayRangeInDialog();
    }

    this.openDialog(this.refs.freeRangeDialog);
    this.refs.freeRangeDialogLabel.focus();
    this.refs.freeRangeDialogLabel.select();
  }

  closeFreeRangeDialog() {
    this.closeDialog(this.refs.freeRangeDialog);
  }

  applySuggestedHolidayRangeInDialog() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const labelRaw = String(this.refs.freeRangeDialogLabel.value || "").trim();
    if (!labelRaw || this.refs.freeRangeDialogStart.value || this.refs.freeRangeDialogEnd.value) {
      return;
    }
    const startYear = Number(String(year.startDate).slice(0, 4));
    const presetOccurrence = Number(this.refs.freeRangeDialogLabel.dataset.presetOccurrence || 0);
    if (labelRaw.toLowerCase() === "sommerferien") {
      const [start, end] = defaultHolidayRangeForRow(startYear, "Sommerferien", presetOccurrence);
      if (start || end) {
        this.refs.freeRangeDialogLabel.value = "Sommerferien";
        this.refs.freeRangeDialogStart.value = start || "";
        this.refs.freeRangeDialogEnd.value = end || "";
      }
      return;
    }
    const defaults = defaultHolidayRangesForYear(startYear);
    for (const [name, range] of Object.entries(defaults)) {
      if (String(name).toLowerCase() !== labelRaw.toLowerCase()) {
        continue;
      }
      if (Array.isArray(range) && range.length === 2) {
        this.refs.freeRangeDialogLabel.value = name;
        this.refs.freeRangeDialogStart.value = range[0];
        this.refs.freeRangeDialogEnd.value = range[1];
      }
      break;
    }
  }

  async submitFreeRangeDialog() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const id = Number(this.refs.freeRangeDialogId.value || 0);
    let label = String(this.refs.freeRangeDialogLabel.value || "").trim();
    const startDate = this.refs.freeRangeDialogStart.value;
    const endDate = this.refs.freeRangeDialogEnd.value;
    const canonicalRequired = REQUIRED_HOLIDAYS.find(
      (item) => item.toLowerCase() === label.toLowerCase()
    );
    if (canonicalRequired) {
      label = canonicalRequired;
    }
    const isSummerHoliday = String(label || "").trim().toLowerCase() === "sommerferien";
    if (!label) {
      return;
    }
    if (isSummerHoliday) {
      if (!startDate && !endDate) {
        return;
      }
    } else if (!startDate || !endDate) {
      return;
    }
    if (!isSummerHoliday && endDate < startDate) {
      await this.showInfoMessage("Das Enddatum muss nach dem Startdatum liegen.");
      return;
    }
    this.store.upsertFreeRange(id || null, year.id, label, startDate, endDate);
    this.closeFreeRangeDialog();
    this.renderAll();
  }

  async deleteFreeRangeFromDialog() {
    const id = Number(this.refs.freeRangeDialogId.value || 0);
    if (!id) {
      return;
    }
    if (!await this.showConfirmMessage("Ferienzeitraum löschen?")) {
      return;
    }
    this.store.deleteFreeRange(id);
    this.closeFreeRangeDialog();
    this.renderAll();
  }

  openSpecialDayDialog(specialDayId = null) {
    if (!this.refs.specialDayDialog) {
      return;
    }
    const numericId = Number(specialDayId || 0);
    const row = numericId
      ? this.store.listSpecialDays().find((item) => item.id === numericId)
      : null;

    this.refs.specialDayDialogId.value = row ? String(row.id) : "";
    this.refs.specialDayDialogTitle.textContent = row ? "Unterrichtsfreien Tag anpassen" : "Unterrichtsfreien Tag hinzufügen";
    this.refs.specialDayDialogName.value = row ? String(row.name || "") : "";
    this.refs.specialDayDialogDate.value = row ? String(row.dayDate || "") : "";
    this.refs.specialDayDialogDelete.hidden = !row;
    this.openDialog(this.refs.specialDayDialog);
    this.refs.specialDayDialogName.focus();
    this.refs.specialDayDialogName.select();
  }

  closeSpecialDayDialog() {
    this.closeDialog(this.refs.specialDayDialog);
  }

  applySuggestedSpecialDayDateInDialog() {
    if (this.refs.specialDayDialogDate.value) {
      return;
    }
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const startYear = Number(String(year.startDate).slice(0, 4));
    const suggested = defaultSpecialDayDateForName(this.refs.specialDayDialogName.value, startYear);
    if (suggested) {
      this.refs.specialDayDialogDate.value = suggested;
    }
  }

  async submitSpecialDayDialog() {
    const id = Number(this.refs.specialDayDialogId.value || 0);
    const name = String(this.refs.specialDayDialogName.value || "").trim();
    const dayDate = this.refs.specialDayDialogDate.value;
    const existing = id
      ? this.store.listSpecialDays().find((item) => item.id === id)
      : null;
    if (existing && this.isDefaultSpecialDayName(existing.name)) {
      const previousName = String(existing.name || "").trim();
      const previousDate = String(existing.dayDate || "");
      if ((previousName !== name || previousDate !== dayDate)
        && !await this.showConfirmMessage("Soll dieser besondere Tag wirklich geändert werden?")) {
        return;
      }
    }
    const ok = this.store.upsertSpecialDay(id || null, name, dayDate);
    if (!ok) {
      await this.showInfoMessage("Name bereits vorhanden oder Eingabe ungültig.");
      return;
    }
    this.closeSpecialDayDialog();
    this.renderAll();
  }

  async deleteSpecialDayFromDialog() {
    const id = Number(this.refs.specialDayDialogId.value || 0);
    if (!id) {
      return;
    }
    if (!await this.showConfirmMessage("Unterrichtsfreien Tag löschen?")) {
      return;
    }
    this.store.deleteSpecialDay(id);
    this.closeSpecialDayDialog();
    this.renderAll();
  }

  isDefaultSpecialDayName(name) {
    const year = this.activeSchoolYear;
    if (!year) {
      return false;
    }
    const startYear = Number(String(year.startDate).slice(0, 4));
    const defaults = new Set(
      defaultSpecialDays(startYear).map((item) => String(item.name || "").trim().toLowerCase())
    );
    return defaults.has(String(name || "").trim().toLowerCase());
  }

  openEntfallDialog(lessonId) {
    const lesson = this.store.getLessonById(lessonId);
    if (!lesson || !this.refs.entfallDialog) {
      return;
    }
    const block = this.store.getLessonBlock(lesson.id);
    if (block.length === 0 || block.every((entry) => entry.canceled) || lesson.noLesson) {
      return;
    }
    this.pendingEntfallLessonId = lesson.id;
    this.refs.entfallDialogReason.value = "";
    this.openDialog(this.refs.entfallDialog);
    this.refs.entfallDialogReason.focus();
  }

  closeEntfallDialog() {
    this.pendingEntfallLessonId = null;
    if (this.refs.entfallDialogReason) {
      this.refs.entfallDialogReason.value = "";
    }
    this.closeDialog(this.refs.entfallDialog);
  }

  submitEntfallDialog() {
    const lessonId = Number(this.pendingEntfallLessonId || 0);
    if (!lessonId) {
      this.closeEntfallDialog();
      return;
    }
    const reason = String(this.refs.entfallDialogReason.value || "").trim();
    const topic = reason ? `${ENTFALL_TOPIC_DEFAULT} (${reason})` : ENTFALL_TOPIC_DEFAULT;
    this.store.updateLessonBlock(lessonId, topic, true, false);
    this.closeEntfallDialog();
    this.renderWeekSection();
    this.renderLessonSection();
    this.renderCourseTimeline();
  }

  openTopicDialog(lessonId) {
    const lesson = this.store.getLessonById(lessonId);
    if (!lesson || !this.refs.topicDialog) {
      return false;
    }
    const block = this.store.getLessonBlock(lesson.id);
    if (block.length === 0) {
      return false;
    }
    const allCanceled = block.every((entry) => entry.canceled);
    if (allCanceled || lesson.noLesson) {
      return false;
    }
    const isEntfall = block.some((entry) => entry.isEntfall);
    const isWritten = block.some((entry) => entry.isWrittenExam);
    if (isEntfall || isWritten) {
      return false;
    }
    const firstTopic = block
      .map((entry) => String(entry.topic || "").trim())
      .find(Boolean) || "";
    this.pendingTopicLessonId = lesson.id;
    if (this.refs.topicDialogLesson) {
      this.refs.topicDialogLesson.value = String(lesson.id);
    }
    this.refs.topicDialogInput.value = firstTopic;
    this.openDialog(this.refs.topicDialog);
    this.refs.topicDialogInput.focus();
    this.refs.topicDialogInput.select();
    return true;
  }

  closeTopicDialog() {
    this.pendingTopicLessonId = null;
    if (this.refs.topicDialogLesson) {
      this.refs.topicDialogLesson.value = "";
    }
    if (this.refs.topicDialogInput) {
      this.refs.topicDialogInput.value = "";
    }
    this.closeDialog(this.refs.topicDialog);
  }

  submitTopicDialog() {
    const lessonId = Number(this.pendingTopicLessonId || this.refs.topicDialogLesson.value || 0);
    if (!lessonId) {
      this.closeTopicDialog();
      return;
    }
    const topic = String(this.refs.topicDialogInput.value || "").trim();
    this.store.updateLessonBlock(lessonId, topic, false, false);
    this.selectedLessonId = lessonId;
    this.closeTopicDialog();
    this.renderWeekSection();
    this.renderLessonSection();
    this.renderCourseTimeline();
  }

  formatSlotConflictMessage(conflicts, year) {
    const parityLabel = (slot) => {
      const parity = Number(slot.weekParity || 0);
      if (parity === 0 && slot.startDate && slot.endDate && slot.startDate === slot.endDate) {
        return "einmalig";
      }
      if (parity === 1) {
        return "ungerade Wochen";
      }
      if (parity === 2) {
        return "gerade Wochen";
      }
      return "jede Woche";
    };
    const rangeLabel = (slot) => {
      const start = slot.startDate || year.startDate;
      const end = slot.endDate || year.endDate;
      if (!start || !end) {
        return "";
      }
      if (start === year.startDate && end === year.endDate) {
        return "gesamtes Schuljahr";
      }
      if (start === end) {
        return formatDate(start);
      }
      return `${formatDate(start)}-${formatDate(end)}`;
    };
    const lines = conflicts.slice(0, 3).map((item) => {
      const begin = Number(item.startHour);
      const end = begin + Math.max(1, Number(item.duration || 1)) - 1;
      const hourLabel = begin === end ? `Std. ${begin}` : `Std. ${begin}-${end}`;
      const dayLabel = DAYS_SHORT[Number(item.dayOfWeek) - 1] || `Tag ${item.dayOfWeek}`;
      const details = [dayLabel, hourLabel, rangeLabel(item), parityLabel(item)]
        .filter(Boolean)
        .join(", ");
      return `${item.courseName} (${details})`;
    });
    if (conflicts.length > 3) {
      lines.push(`... und ${conflicts.length - 3} weitere.`);
    }
    return `Dieser Termin überschneidet sich mit:\n${lines.join("\n")}\n\nBitte Zeit, Tag oder Zeitraum anpassen.`;
  }

  async persistSlotChange({
    slotId = null,
    courseId,
    dayOfWeek,
    startHour,
    duration,
    startDate = null,
    endDateInput = null,
    recurrenceValue = 0,
    editScope = "all",
    editFromDate = null
  }) {
    const year = this.activeSchoolYear;
    if (!year) {
      return false;
    }
    const normalizedSlotId = Number(slotId || 0);
    const normalizedCourseId = Number(courseId || 0);
    let normalizedDay = Number(dayOfWeek || 0);
    const normalizedStartHour = clamp(Number(startHour), 1, this.store.getHoursPerDay());
    const normalizedDuration = Math.max(1, Number(duration));
    const normalizedStartDate = startDate || null;
    let endDate = endDateInput || null;
    const normalizedRecurrence = Number(recurrenceValue || 0);
    let weekParity = normalizedRecurrence;

    if (normalizedRecurrence === -1) {
      if (!normalizedStartDate) {
        await this.showInfoMessage("Für 'Keine' muss ein Startdatum gesetzt sein.");
        return false;
      }
      const singleDay = dayOfWeekIso(normalizedStartDate);
      if (singleDay < 1 || singleDay > 5) {
        await this.showInfoMessage("Der Termin muss auf einen Schultag (Montag bis Freitag) fallen.");
        return false;
      }
      normalizedDay = singleDay;
      endDate = normalizedStartDate;
      weekParity = 0;
    }

    if (normalizedStartDate && endDate && endDate < normalizedStartDate) {
      await this.showInfoMessage("Das Enddatum muss nach dem Startdatum liegen.");
      return false;
    }

    const conflicts = this.store.findSlotConflicts(
      year.id,
      normalizedCourseId,
      normalizedDay,
      normalizedStartHour,
      normalizedDuration,
      normalizedStartDate,
      endDate,
      weekParity,
      normalizedSlotId || null
    );
    if (conflicts.length > 0) {
      await this.showInfoMessage(this.formatSlotConflictMessage(conflicts, year));
      return false;
    }

    if (normalizedSlotId) {
      if (!this.store.getSlot(normalizedSlotId)) {
        await this.showInfoMessage("Der Slot wurde nicht gefunden.");
        return false;
      }

      if (editScope === "from") {
        if (!editFromDate) {
          await this.showInfoMessage("Bitte ein Startdatum für die Teiländerung angeben.");
          return false;
        }
        const result = this.store.splitSlotFromDate(
          year.id,
          normalizedSlotId,
          editFromDate,
          normalizedCourseId,
          normalizedDay,
          normalizedStartHour,
          normalizedDuration,
          endDate,
          weekParity
        );
        if (!result || !result.ok) {
          await this.showInfoMessage((result && result.message) || "Teiländerung konnte nicht gespeichert werden.");
          return false;
        }
      } else {
        this.store.updateSlot(
          normalizedSlotId,
          normalizedCourseId,
          normalizedDay,
          normalizedStartHour,
          normalizedDuration,
          normalizedStartDate,
          endDate,
          weekParity
        );
      }
    } else {
      this.store.createSlot(
        normalizedCourseId,
        normalizedDay,
        normalizedStartHour,
        normalizedDuration,
        normalizedStartDate,
        endDate,
        weekParity
      );
    }

    this.selectedLessonId = null;
    return true;
  }

  async deleteSlotWithScope(slotId, editScope = "all", editFromDate = null) {
    const year = this.activeSchoolYear;
    if (!year) {
      return false;
    }
    const normalizedSlotId = Number(slotId || 0);
    if (!normalizedSlotId) {
      return false;
    }
    const slot = this.store.getSlot(normalizedSlotId);
    if (!slot) {
      await this.showInfoMessage("Der Slot wurde nicht gefunden.");
      return false;
    }
    if (!await this.showConfirmMessage("Unterrichtsstunde löschen?")) {
      return false;
    }

    const oldStart = slot.startDate || year.startDate;
    if (editScope === "from" && editFromDate) {
      if (editFromDate <= oldStart) {
        this.store.deleteSlot(normalizedSlotId);
      } else {
        const result = this.store.splitSlotFromDate(
          year.id,
          normalizedSlotId,
          editFromDate,
          slot.courseId,
          slot.dayOfWeek,
          slot.startHour,
          slot.duration,
          slot.endDate || null,
          slot.weekParity || 0
        );
        if (!result || !result.ok) {
          await this.showInfoMessage((result && result.message) || "Teillöschung konnte nicht durchgeführt werden.");
          return false;
        }
        if (result.newSlotId) {
          this.store.deleteSlot(result.newSlotId);
        }
      }
    } else {
      this.store.deleteSlot(normalizedSlotId);
    }
    this.selectedLessonId = null;
    return true;
  }

  populateSlotDialogCourseSelect(selectedCourseId = null) {
    const year = this.activeSchoolYear;
    if (!year || !this.refs.slotDialogCourse) {
      return false;
    }
    const courses = this.store.listCourses(year.id);
    this.refs.slotDialogCourse.innerHTML = "";
    for (const course of courses) {
      const option = document.createElement("option");
      option.value = String(course.id);
      option.textContent = course.name;
      const courseColor = normalizeCourseColor(course.color, Boolean(course.noLesson));
      option.style.color = courseColor;
      option.style.backgroundColor = "var(--dropdown-bg)";
      option.dataset.courseColor = courseColor;
      this.refs.slotDialogCourse.append(option);
    }
    if (courses.length === 0) {
      return false;
    }
    const selected = Number(selectedCourseId || 0);
    const fallback = courses[0].id;
    this.refs.slotDialogCourse.value = String(
      courses.some((course) => course.id === selected) ? selected : fallback
    );
    this.syncSlotDialogCourseColor();
    return true;
  }

  syncSlotDialogCourseColor() {
    if (!this.refs.slotDialogCourse) {
      return;
    }
    const selectedOption = this.refs.slotDialogCourse.selectedOptions
      ? this.refs.slotDialogCourse.selectedOptions[0]
      : null;
    const selectedColor = selectedOption
      ? String(selectedOption.dataset.courseColor || selectedOption.style.color || "").trim()
      : "";
    this.refs.slotDialogCourse.style.color = selectedColor || "";
  }

  syncSlotFormCourseColor() {
    if (!this.refs.slotCourse) {
      return;
    }
    const selectedOption = this.refs.slotCourse.selectedOptions
      ? this.refs.slotCourse.selectedOptions[0]
      : null;
    const selectedColor = selectedOption
      ? String(selectedOption.dataset.courseColor || selectedOption.style.color || "").trim()
      : "";
    this.refs.slotCourse.style.color = selectedColor || "";
  }

  syncSlotDialogHourRange() {
    if (!this.refs.slotDialogHour || !this.refs.slotDialogEndHour) {
      return;
    }
    const maxHour = this.store.getHoursPerDay();
    this.refs.slotDialogHour.max = String(maxHour);
    this.refs.slotDialogEndHour.max = String(maxHour);

    const startHour = clamp(Number(this.refs.slotDialogHour.value || 1), 1, maxHour);
    this.refs.slotDialogHour.value = String(startHour);
    this.refs.slotDialogEndHour.min = String(startHour);

    const endHour = clamp(Number(this.refs.slotDialogEndHour.value || startHour), startHour, maxHour);
    this.refs.slotDialogEndHour.value = String(endHour);
  }

  syncSlotDialogEditTools() {
    if (!this.refs.slotDialogId) {
      return;
    }
    const isEditing = Boolean(this.refs.slotDialogId.value);
    const recurrenceNone = Number(this.refs.slotDialogParity.value || 0) === -1;
    this.refs.slotDialogEditTools.hidden = true;
    this.refs.slotDialogDelete.hidden = !isEditing;

    if (!isEditing) {
      this.refs.slotDialogEditScope.value = "all";
      this.refs.slotDialogEditFromDate.value = "";
      this.refs.slotDialogStart.disabled = false;
    } else {
      const fromScope = this.refs.slotDialogEditScope.value === "from" && Boolean(this.refs.slotDialogEditFromDate.value);
      this.refs.slotDialogStart.disabled = fromScope;
      if (fromScope) {
        this.refs.slotDialogStart.value = this.refs.slotDialogEditFromDate.value;
      }
    }
    this.refs.slotDialogEnd.disabled = recurrenceNone;
    this.refs.slotDialogDay.disabled = recurrenceNone;
    if (recurrenceNone) {
      if (this.slotDialogEndDateBackup === null) {
        this.slotDialogEndDateBackup = this.refs.slotDialogEnd.value || "";
      }
      const startIso = this.refs.slotDialogStart.value || "";
      if (startIso) {
        this.refs.slotDialogEnd.value = startIso;
        const isoDay = dayOfWeekIso(startIso);
        if (isoDay >= 1 && isoDay <= 5) {
          this.refs.slotDialogDay.value = String(isoDay);
        }
      }
    } else {
      if (this.slotDialogEndDateBackup) {
        this.refs.slotDialogEnd.value = this.slotDialogEndDateBackup;
      }
      this.slotDialogEndDateBackup = null;
    }

    if (this.refs.slotDialogEditInfo) {
      if (!isEditing) {
        this.refs.slotDialogEditInfo.hidden = true;
        this.refs.slotDialogEditInfo.textContent = "";
      } else {
        const fromScope = this.refs.slotDialogEditScope.value === "from" && Boolean(this.refs.slotDialogEditFromDate.value);
        const dateLabel = fromScope ? formatDate(this.refs.slotDialogEditFromDate.value) : "–";
        this.refs.slotDialogEditInfo.textContent =
          `Serie wird ab dem ausgewählten Termin verändert (${dateLabel})`;
        this.refs.slotDialogEditInfo.hidden = false;
      }
    }
  }

  _computeSlotEndDefault(startDefaultIso) {
    const year = this.activeSchoolYear;
    if (!year) {
      return startDefaultIso;
    }
    const ranges = this.store.listFreeRanges(year.id);
    const halfYearRange = ranges.find(
      (item) => String(item.label || "").trim().toLowerCase() === "halbjahresferien" && item.startDate
    );
    const summer = this._summerBreakBounds();
    let endDefault = summer.start || year.endDate;
    if (halfYearRange && startDefaultIso < halfYearRange.startDate) {
      endDefault = halfYearRange.startDate;
    }
    if (endDefault < startDefaultIso) {
      endDefault = startDefaultIso;
    }
    if (endDefault > year.endDate) {
      endDefault = year.endDate;
    }
    return endDefault;
  }

  async openSlotDialogForCreate(dayOfWeek, startHour) {
    const year = this.activeSchoolYear;
    if (!year || !this.refs.slotDialog) {
      return;
    }
    if (!this.populateSlotDialogCourseSelect(this.selectedCourseId)) {
      await this.showInfoMessage("Erst Kurs anlegen.");
      return;
    }
    this.refs.slotDialogTitle.textContent = "Unterrichtsstunde anlegen";
    this.refs.slotDialogId.value = "";
    this.refs.slotDialogDay.value = String(dayOfWeek);
    this.refs.slotDialogHour.value = String(clamp(Number(startHour), 1, this.store.getHoursPerDay()));
    this.refs.slotDialogEndHour.value = String(clamp(Number(startHour) + 1, 1, this.store.getHoursPerDay()));
    this.refs.slotDialogParity.value = "0";
    this.refs.slotDialogEditScope.value = "all";
    this.refs.slotDialogEditFromDate.value = "";
    if (this.refs.slotDialogEditInfo) {
      this.refs.slotDialogEditInfo.hidden = true;
      this.refs.slotDialogEditInfo.textContent = "";
    }
    this.slotDialogEndDateBackup = null;

    let startDefault = addDays(this.weekStartIso, Number(dayOfWeek) - 1);
    if (startDefault < year.startDate) {
      startDefault = year.startDate;
    }
    if (startDefault > year.endDate) {
      startDefault = year.endDate;
    }
    const endDefault = this._computeSlotEndDefault(startDefault);

    this.slotDialogStartMinIso = startDefault;
    this.refs.slotDialogStart.min = startDefault;
    this.refs.slotDialogStart.max = year.endDate;
    this.refs.slotDialogEnd.min = startDefault;
    this.refs.slotDialogEnd.max = year.endDate;
    this.refs.slotDialogStart.value = startDefault;
    this.refs.slotDialogEnd.value = endDefault;
    this.syncSlotDialogHourRange();
    this.syncSlotDialogEditTools();
    this.openDialog(this.refs.slotDialog);
  }

  async openSlotDialogForEdit(slotOrId, clickedDate = null) {
    const year = this.activeSchoolYear;
    if (!year || !this.refs.slotDialog) {
      return;
    }
    const slot = (slotOrId && typeof slotOrId === "object")
      ? slotOrId
      : this.store.getSlot(Number(slotOrId));
    if (!slot) {
      return;
    }
    if (!this.populateSlotDialogCourseSelect(slot.courseId)) {
      await this.showInfoMessage("Erst Kurs anlegen.");
      return;
    }
    this.refs.slotDialogTitle.textContent = "Unterrichtsstunde anpassen";
    this.refs.slotDialogId.value = String(slot.id);
    this.refs.slotDialogCourse.value = String(slot.courseId);
    this.syncSlotDialogCourseColor();
    this.refs.slotDialogDay.value = String(slot.dayOfWeek);
    this.refs.slotDialogHour.value = String(slot.startHour);
    this.refs.slotDialogEndHour.value = String(
      clamp(Number(slot.startHour) + Number(slot.duration || 1) - 1, 1, this.store.getHoursPerDay())
    );
    this.refs.slotDialogStart.value = slot.startDate || "";
    this.refs.slotDialogEnd.value = slot.endDate || "";
    let displayParity = Number(slot.weekParity || 0);
    if (displayParity === 0 && slot.startDate && slot.endDate && slot.startDate === slot.endDate) {
      displayParity = -1;
    }
    this.refs.slotDialogParity.value = String(displayParity);
    this.refs.slotDialogEditScope.value = "all";
    this.refs.slotDialogEditFromDate.value = "";
    this.slotDialogEndDateBackup = null;

    const slotStart = slot.startDate || year.startDate;
    const slotEnd = slot.endDate || year.endDate;
    this.slotDialogStartMinIso = null;
    this.refs.slotDialogStart.min = slotStart;
    this.refs.slotDialogStart.max = slotEnd;
    this.refs.slotDialogEnd.min = slotStart;
    this.refs.slotDialogEnd.max = slotEnd;
    if (clickedDate && clickedDate >= slotStart && clickedDate <= slotEnd) {
      this.refs.slotDialogEditScope.value = "from";
      this.refs.slotDialogEditFromDate.value = clickedDate;
    }
    this.syncSlotDialogHourRange();
    this.syncSlotDialogEditTools();
    this.openDialog(this.refs.slotDialog);
  }

  closeSlotDialog() {
    this.slotDialogStartMinIso = null;
    this.slotDialogEndDateBackup = null;
    this.closeDialog(this.refs.slotDialog);
  }

  async submitSlotDialog() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    let startDate = this.refs.slotDialogStart.value || null;
    let endDate = this.refs.slotDialogEnd.value || null;
    if (startDate) {
      startDate = normalizeIsoToSchoolWeekday(startDate, "forward");
      this.refs.slotDialogStart.value = startDate;
    }
    if (endDate) {
      endDate = normalizeIsoToSchoolWeekday(endDate, "backward");
      this.refs.slotDialogEnd.value = endDate;
    }
    if (startDate && endDate && endDate < startDate) {
      endDate = startDate;
      this.refs.slotDialogEnd.value = endDate;
    }
    if (!startDate || !endDate) {
      await this.showInfoMessage("Bitte Start- und Enddatum vollständig eingeben.");
      return;
    }
    if (startDate < year.startDate) {
      await this.showInfoMessage("Startdatum liegt vor dem Schuljahr.");
      return;
    }
    if (endDate > year.endDate) {
      await this.showInfoMessage("Enddatum liegt nach dem Schuljahr.");
      return;
    }
    if (!this.refs.slotDialogId.value && this.slotDialogStartMinIso && startDate < this.slotDialogStartMinIso) {
      await this.showInfoMessage("Startdatum liegt vor dem gewählten Tag.");
      return;
    }
    if (endDate < startDate) {
      await this.showInfoMessage("Enddatum muss am oder nach dem Startdatum liegen.");
      return;
    }
    this.syncSlotDialogHourRange();
    const startHour = Number(this.refs.slotDialogHour.value || 1);
    const endHour = Number(this.refs.slotDialogEndHour.value || startHour);
    const duration = Math.max(1, endHour - startHour + 1);

    const ok = await this.persistSlotChange({
      slotId: this.refs.slotDialogId.value || null,
      courseId: this.refs.slotDialogCourse.value,
      dayOfWeek: this.refs.slotDialogDay.value,
      startHour,
      duration,
      startDate,
      endDateInput: endDate,
      recurrenceValue: this.refs.slotDialogParity.value,
      editScope: this.refs.slotDialogEditScope.value || "all",
      editFromDate: this.refs.slotDialogEditFromDate.value || null
    });
    if (!ok) {
      return;
    }
    this.closeSlotDialog();
    this.resetSlotForm();
    this.renderAll();
  }

  async deleteSlotFromDialog() {
    const slotId = this.refs.slotDialogId.value;
    if (!slotId) {
      return;
    }
    const ok = await this.deleteSlotWithScope(
      slotId,
      this.refs.slotDialogEditScope.value || "all",
      this.refs.slotDialogEditFromDate.value || null
    );
    if (!ok) {
      return;
    }
    this.closeSlotDialog();
    this.resetSlotForm();
    this.renderAll();
  }

  findSidebarDragAfterElement(clientY) {
    const rows = [...this.refs.sidebarCourseList.querySelectorAll("li[data-course-id]:not(.dragging)")];
    let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
    for (const row of rows) {
      const box = row.getBoundingClientRect();
      const offset = clientY - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        closest = { offset, element: row };
      }
    }
    return closest.element;
  }

  syncSidebarDragPlaceholderState() {
    if (!this.dragPlaceholder || !this.dragSourceRow) {
      return;
    }
    const atOrigin = this.dragPlaceholder.previousElementSibling === this.dragSourceRow;
    this.dragPlaceholder.classList.toggle("at-origin", atOrigin);
  }

  positionSidebarDragPlaceholder(clientY) {
    if (!this.refs.sidebarCourseList || !this.dragPlaceholder) {
      return;
    }
    const after = this.findSidebarDragAfterElement(clientY);
    if (!after) {
      const addItem = this.refs.sidebarCourseList.querySelector("li[data-add-item='1']");
      if (addItem) {
        this.refs.sidebarCourseList.insertBefore(this.dragPlaceholder, addItem);
      } else {
        this.refs.sidebarCourseList.append(this.dragPlaceholder);
      }
      this.syncSidebarDragPlaceholderState();
      return;
    }
    this.refs.sidebarCourseList.insertBefore(this.dragPlaceholder, after);
    this.syncSidebarDragPlaceholderState();
  }

  autoScrollSidebarListDuringDrag(clientY) {
    if (!this.refs.sidebarCourseList) {
      return;
    }
    const rect = this.refs.sidebarCourseList.getBoundingClientRect();
    const threshold = 34;
    const step = 14;
    if (clientY < rect.top + threshold) {
      this.refs.sidebarCourseList.scrollTop -= step;
    } else if (clientY > rect.bottom - threshold) {
      this.refs.sidebarCourseList.scrollTop += step;
    }
  }

  clearSidebarDragState() {
    if (this.dragSourceRow) {
      this.dragSourceRow.classList.remove("dragging");
    }
    if (this.dragPlaceholder && this.dragPlaceholder.parentElement) {
      this.dragPlaceholder.remove();
    }
    this.dragCourseId = null;
    this.dragSourceRow = null;
    this.dragPlaceholder = null;
    this.dragDropCommitted = false;
  }

  applySidebarCourseOrderFromDom() {
    const year = this.activeSchoolYear;
    if (!year) {
      return;
    }
    const orderedIds = [...this.refs.sidebarCourseList.querySelectorAll("li[data-course-id]")]
      .map((row) => Number(row.dataset.courseId))
      .filter((id) => id > 0);
    if (orderedIds.length === 0) {
      return;
    }
    this.store.updateCourseOrder(year.id, orderedIds);
  }

  switchView(viewName) {
    this.hideContextMenu();
    this.closeWeekCalendarDialog();
    this.closeTopicDialog();
    this.resetInlineWeekBlockTopicEdit();
    if (this.locked && viewName !== "settings") {
      this.currentView = "settings";
      this.renderViewState();
      this.renderSettingsTabs();
      this.renderSidebarCourseList();
      return;
    }
    this.currentView = viewName;
    this.renderViewState();
    this.renderSidebarCourseList();
    if (viewName === "course") {
      this.scrollCourseNextIntoView = true;
      this.renderCourseTimeline();
    }
  }

  switchSettingsTab(tabName) {
    if (!this.refs.settingsPanels[tabName]) {
      return;
    }
    this.activeSettingsTab = tabName;
    this.renderSettingsTabs();
  }

  bindEvents() {
    this.refs.viewWeekBtn.addEventListener("click", () => {
      this.switchView("week");
    });

    this.refs.viewSettingsBtn.addEventListener("click", () => {
      this.switchView("settings");
    });

    if (this.refs.contextMenu && typeof this.refs.contextMenu.close === "function") {
      this.refs.contextMenu.addEventListener("cancel", (event) => {
        event.preventDefault();
        this.hideContextMenu();
      });
      this.refs.contextMenu.addEventListener("close", () => {
        this.refs.contextMenu.hidden = true;
        this.refs.contextMenu.innerHTML = "";
        this.contextMenuItems = [];
      });
    }

    this.refs.sidebarCourseList.addEventListener("click", (event) => {
      const addButton = event.target.closest("button[data-add-course='1']");
      if (addButton) {
        if (this.locked) {
          return;
        }
        this.openCourseDialog();
        return;
      }
      if (this.locked) {
        return;
      }
      const button = event.target.closest("button[data-course-id]");
      if (!button) {
        return;
      }
      if (button.dataset.noLesson === "1") {
        return;
      }
      this.selectedCourseId = Number(button.dataset.courseId);
      this.switchView("course");
    });

    this.refs.sidebarCourseList.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      if (event.button !== 2) {
        this.hideContextMenu();
        return;
      }
      const row = event.target.closest("li[data-course-id]");
      if (!row || this.locked) {
        this.hideContextMenu();
        return;
      }
      this.openCourseDialog(Number(row.dataset.courseId));
    });

    this.refs.courseDialogCancel.addEventListener("click", () => {
      this.closeCourseDialog();
    });

    this.refs.courseDialogNoLesson.addEventListener("change", () => {
      this.syncCourseDialogNoLessonState();
    });

    if (this.refs.courseDialogColorPalette) {
      this.refs.courseDialogColorPalette.addEventListener("click", (event) => {
        const button = event.target.closest("button.course-color-btn[data-color]");
        if (!button || button.disabled || this.refs.courseDialogNoLesson.checked) {
          return;
        }
        this.selectCourseDialogColor(button.dataset.color);
      });
    }

    this.refs.courseDialogForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      await this.submitCourseDialog();
    });

    this.refs.courseDialogDelete.addEventListener("click", async () => {
      await this.deleteCourseFromDialog();
    });

    if (this.refs.courseDialogToggleSidebar) {
      this.refs.courseDialogToggleSidebar.addEventListener("click", () => {
        this.toggleCourseSidebarVisibilityFromDialog();
      });
    }

    this.refs.courseDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeCourseDialog();
    });

    this.refs.entfallDialogCancel.addEventListener("click", () => {
      this.closeEntfallDialog();
    });

    this.refs.entfallDialogForm.addEventListener("submit", (event) => {
      event.preventDefault();
      this.submitEntfallDialog();
    });

    this.refs.entfallDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeEntfallDialog();
    });

    this.refs.topicDialogCancel.addEventListener("click", () => {
      this.closeTopicDialog();
    });

    this.refs.topicDialogForm.addEventListener("submit", (event) => {
      event.preventDefault();
      this.submitTopicDialog();
    });

    this.refs.topicDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeTopicDialog();
    });
    this.refs.topicDialog.addEventListener("click", (event) => {
      if (event.target === this.refs.topicDialog) {
        this.closeTopicDialog();
      }
    });

    if (this.refs.messageDialogForm) {
      this.refs.messageDialogForm.addEventListener("submit", (event) => {
        event.preventDefault();
        this._resolveMessageDialog("ok");
      });
    }

    if (this.refs.messageDialogCancel) {
      this.refs.messageDialogCancel.addEventListener("click", () => {
        this._resolveMessageDialog("cancel");
      });
    }

    if (this.refs.messageDialog) {
      this.refs.messageDialog.addEventListener("cancel", (event) => {
        event.preventDefault();
        this._resolveMessageDialog("cancel");
      });
      this.refs.messageDialog.addEventListener("click", (event) => {
        if (event.target === this.refs.messageDialog) {
          this._resolveMessageDialog("cancel");
        }
      });
    }

    this.refs.slotDialogCancel.addEventListener("click", () => {
      this.closeSlotDialog();
    });

    this.refs.slotDialogCourse.addEventListener("change", () => {
      this.syncSlotDialogCourseColor();
    });

    this.refs.slotDialogParity.addEventListener("change", () => {
      this.syncSlotDialogEditTools();
    });

    this.refs.slotDialogHour.addEventListener("change", () => {
      this.syncSlotDialogHourRange();
    });

    this.refs.slotDialogEndHour.addEventListener("change", () => {
      this.syncSlotDialogHourRange();
    });

    this.refs.slotDialogStart.addEventListener("change", () => {
      const normalizedStart = normalizeIsoToSchoolWeekday(this.refs.slotDialogStart.value || "", "forward");
      if (normalizedStart && normalizedStart !== this.refs.slotDialogStart.value) {
        this.refs.slotDialogStart.value = normalizedStart;
      }
      this.syncSlotDialogEditTools();
    });

    this.refs.slotDialogEnd.addEventListener("change", () => {
      const normalizedEnd = normalizeIsoToSchoolWeekday(this.refs.slotDialogEnd.value || "", "backward");
      if (normalizedEnd && normalizedEnd !== this.refs.slotDialogEnd.value) {
        this.refs.slotDialogEnd.value = normalizedEnd;
      }
      if (this.refs.slotDialogStart.value && this.refs.slotDialogEnd.value < this.refs.slotDialogStart.value) {
        this.refs.slotDialogEnd.value = this.refs.slotDialogStart.value;
      }
      this.syncSlotDialogEditTools();
    });

    this.refs.slotDialogForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      await this.submitSlotDialog();
    });

    this.refs.slotDialogDelete.addEventListener("click", async () => {
      await this.deleteSlotFromDialog();
    });

    this.refs.slotDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeSlotDialog();
    });

    this.refs.sidebarCourseList.addEventListener("dragstart", (event) => {
      const row = event.target.closest("li[data-course-id]");
      if (!row || this.locked || !row.draggable) {
        event.preventDefault();
        return;
      }
      this.dragCourseId = Number(row.dataset.courseId);
      this.dragSourceRow = row;
      this.dragDropCommitted = false;
      row.classList.add("dragging");
      const rowHeight = Math.max(Math.round(row.getBoundingClientRect().height), 42);
      const placeholder = document.createElement("li");
      placeholder.className = "sidebar-drag-placeholder";
      placeholder.setAttribute("aria-hidden", "true");
      placeholder.style.height = `${rowHeight}px`;
      this.dragPlaceholder = placeholder;
      this.refs.sidebarCourseList.insertBefore(placeholder, row.nextSibling);
      this.syncSidebarDragPlaceholderState();
      if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", String(this.dragCourseId));
      }
    });

    this.refs.sidebarCourseList.addEventListener("dragover", (event) => {
      if (this.locked || !this.dragCourseId || !this.dragSourceRow || !this.dragPlaceholder) {
        return;
      }
      event.preventDefault();
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = "move";
      }
      this.autoScrollSidebarListDuringDrag(event.clientY);
      this.positionSidebarDragPlaceholder(event.clientY);
    });

    this.refs.sidebarCourseList.addEventListener("drop", (event) => {
      if (this.locked || !this.dragCourseId) {
        return;
      }
      event.preventDefault();
      this.dragDropCommitted = true;
      this.positionSidebarDragPlaceholder(event.clientY);
    });

    this.refs.sidebarCourseList.addEventListener("dragend", () => {
      const shouldApply = Boolean(this.dragCourseId && this.dragDropCommitted);
      if (
        shouldApply &&
        this.dragSourceRow &&
        this.dragPlaceholder &&
        this.dragPlaceholder.parentElement === this.refs.sidebarCourseList
      ) {
        this.refs.sidebarCourseList.insertBefore(this.dragSourceRow, this.dragPlaceholder);
      }
      this.clearSidebarDragState();
      if (shouldApply) {
        this.applySidebarCourseOrderFromDom();
        this.renderSidebarCourseList();
        this.renderCourseSection();
        this.renderSlotSection();
      }
    });

    this.refs.settingsTabs.forEach((button) => {
      button.addEventListener("click", () => {
        this.switchSettingsTab(button.dataset.tab);
      });
    });

    if (this.refs.settingsResetAll) {
      this.refs.settingsResetAll.addEventListener("click", async () => {
        await this.applySettingsDefaultsForActiveTab();
      });
    }
    if (this.refs.settingsSaveAll) {
      this.refs.settingsSaveAll.addEventListener("click", () => {
        this.applySettingsSaveForActiveTab();
      });
    }
    if (this.refs.settingsCancelAll) {
      this.refs.settingsCancelAll.addEventListener("click", () => {
        this.applySettingsCancelForActiveTab();
      });
    }

    this.refs.schoolYearSelect.addEventListener("change", () => {
      this.store.setActiveSchoolYear(Number(this.refs.schoolYearSelect.value));
      this.weekStartIso = this._clampWeekStart(this.weekStartIso);
      this.selectedLessonId = null;
      const courses = this.store.listCourses(this.activeSchoolYear.id).filter((course) => !course.noLesson);
      if (!courses.some((course) => course.id === this.selectedCourseId)) {
        this.selectedCourseId = courses.length > 0 ? courses[0].id : null;
      }
      this.renderAll();
    });

    this.refs.weekPrev.addEventListener("click", () => {
      if (this.locked) {
        return;
      }
      const candidate = this._clampWeekStart(addDays(this.weekStartIso, -7));
      if (candidate === this.weekStartIso) {
        return;
      }
      this.weekStartIso = candidate;
      this.selectedLessonId = null;
      this.renderWeekSection();
      this.renderLessonSection();
    });

    this.refs.weekNext.addEventListener("click", () => {
      if (this.locked) {
        return;
      }
      const candidate = this._clampWeekStart(addDays(this.weekStartIso, 7));
      if (candidate === this.weekStartIso) {
        return;
      }
      this.weekStartIso = candidate;
      this.selectedLessonId = null;
      this.renderWeekSection();
      this.renderLessonSection();
    });

    this.refs.kwLabel.addEventListener("click", () => {
      this.openWeekMiniCalendar();
    });

    this.refs.weekPickerBtn.addEventListener("click", () => {
      if (this.locked) {
        return;
      }
      const candidate = currentWeekStartForDisplay();
      const { min, max } = this._weekBounds();
      if ((min && candidate < min) || (max && candidate > max)) {
        return;
      }
      if (candidate === this.weekStartIso) {
        return;
      }
      this.weekStartIso = candidate;
      this.selectedLessonId = null;
      this.renderWeekSection();
      this.renderLessonSection();
    });

    this.refs.weekDate.addEventListener("change", () => {
      if (this.locked) {
        return;
      }
      if (!this.refs.weekDate.value) {
        return;
      }
      this.weekStartIso = this._clampWeekStart(weekStartFor(this.refs.weekDate.value));
      this.selectedLessonId = null;
      this.renderWeekSection();
      this.renderLessonSection();
    });

    if (this.refs.weekCalendarPrev) {
      this.refs.weekCalendarPrev.addEventListener("click", () => {
        if (this.locked) {
          return;
        }
        const nextMonth = this._weekCalendarShiftMonth(this.weekCalendarMonthIso, -1);
        this.weekCalendarMonthIso = this._clampWeekCalendarMonth(nextMonth);
        this.syncWeekCalendarMonthOptions();
        this.renderWeekCalendarGrid();
        this.positionWeekCalendarDialog();
      });
    }

    if (this.refs.weekCalendarNext) {
      this.refs.weekCalendarNext.addEventListener("click", () => {
        if (this.locked) {
          return;
        }
        const nextMonth = this._weekCalendarShiftMonth(this.weekCalendarMonthIso, 1);
        this.weekCalendarMonthIso = this._clampWeekCalendarMonth(nextMonth);
        this.syncWeekCalendarMonthOptions();
        this.renderWeekCalendarGrid();
        this.positionWeekCalendarDialog();
      });
    }

    if (this.refs.weekCalendarMonth) {
      this.refs.weekCalendarMonth.addEventListener("change", () => {
        this.weekCalendarMonthIso = this._clampWeekCalendarMonth(this.refs.weekCalendarMonth.value);
        this.syncWeekCalendarMonthOptions();
        this.renderWeekCalendarGrid();
      });
    }

    if (this.refs.weekCalendarGrid) {
      this.refs.weekCalendarGrid.addEventListener("mouseover", (event) => {
        const row = event.target.closest("tr.week-calendar-row[data-week-start]");
        this.setWeekCalendarHoverWeek(row ? row.dataset.weekStart : null);
      });

      this.refs.weekCalendarGrid.addEventListener("mouseleave", () => {
        this.setWeekCalendarHoverWeek(null);
      });

      this.refs.weekCalendarGrid.addEventListener("focusin", (event) => {
        const row = event.target.closest("tr.week-calendar-row[data-week-start]");
        this.setWeekCalendarHoverWeek(row ? row.dataset.weekStart : null);
      });

      this.refs.weekCalendarGrid.addEventListener("focusout", () => {
        const active = document.activeElement;
        const row = active ? active.closest("tr.week-calendar-row[data-week-start]") : null;
        this.setWeekCalendarHoverWeek(row ? row.dataset.weekStart : null);
      });

      this.refs.weekCalendarGrid.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-week-start]");
        if (!button || button.disabled) {
          return;
        }
        this.applyWeekCalendarSelection(button.dataset.weekStart);
      });
    }

    if (this.refs.weekCalendarDialog) {
      this.refs.weekCalendarDialog.addEventListener("cancel", (event) => {
        event.preventDefault();
        this.closeWeekCalendarDialog();
      });

      this.refs.weekCalendarDialog.addEventListener("click", (event) => {
        if (event.target === this.refs.weekCalendarDialog) {
          this.closeWeekCalendarDialog();
        }
      });
    }

    this.refs.weekTable.addEventListener("mousedown", (event) => {
      if (this.locked) {
        return;
      }
      const inlineTopicInput = event.target.closest(".week-inline-topic-input[data-lesson-id]");
      if (inlineTopicInput) {
        return;
      }
      const activeLessonId = Number(this.inlineTopicLessonId || 0);
      if (!activeLessonId) {
        return;
      }
      const lessonBlock = event.target.closest(".lesson-block[data-lesson-id]");
      if (!lessonBlock) {
        return;
      }
      if (lessonBlock.dataset.noLesson === "1" || lessonBlock.matches("button:disabled")) {
        return;
      }
      const nextLessonId = Number(lessonBlock.dataset.lessonId || 0);
      if (!nextLessonId || nextLessonId === activeLessonId) {
        return;
      }
      event.preventDefault();
      this.finishInlineWeekBlockTopicEdit(true, nextLessonId);
    });

    this.refs.weekTable.addEventListener("click", (event) => {
      if (this.locked) {
        return;
      }
      this.hideContextMenu();
      const inlineTopicInput = event.target.closest(".week-inline-topic-input[data-lesson-id]");
      if (inlineTopicInput) {
        return;
      }
      const lessonBlock = event.target.closest(".lesson-block[data-lesson-id]");
      if (lessonBlock) {
        if (lessonBlock.matches("button:disabled")) {
          return;
        }
        if (lessonBlock.dataset.noLesson === "1") {
          this.selectedLessonId = null;
          this.resetInlineWeekBlockTopicEdit();
          this.renderWeekTable();
          this.renderLessonSection();
          return;
        }
        const lessonId = Number(lessonBlock.dataset.lessonId);
        if (lessonId && lessonId === Number(this.inlineTopicLessonId || 0)) {
          return;
        }
        if (!this.promptEditWeekBlockTopic(lessonId)) {
          this.selectedLessonId = lessonId;
          this.renderWeekTable();
          this.renderLessonSection();
        }
        return;
      }

      const dayCell = event.target.closest("td.day-cell.empty[data-day][data-hour]");
      if (!dayCell) {
        return;
      }
      if (this.selectedLessonId !== null) {
        this.selectedLessonId = null;
        this.resetInlineWeekBlockTopicEdit();
        this.renderWeekTable();
        this.renderLessonSection();
      }
    });

    this.refs.weekTable.addEventListener("input", (event) => {
      const inlineTopicInput = event.target.closest(".week-inline-topic-input[data-lesson-id]");
      if (!inlineTopicInput) {
        return;
      }
      const lessonId = Number(inlineTopicInput.dataset.lessonId || 0);
      if (!lessonId || lessonId !== Number(this.inlineTopicLessonId || 0)) {
        return;
      }
      this.inlineTopicDraft = inlineTopicInput.value;
      this.syncInlineWeekBlockTopicInputSize(inlineTopicInput);
    });

    this.refs.weekTable.addEventListener("keydown", (event) => {
      const inlineTopicInput = event.target.closest(".week-inline-topic-input[data-lesson-id]");
      if (!inlineTopicInput) {
        return;
      }
      const lessonId = Number(inlineTopicInput.dataset.lessonId || 0);
      if (!lessonId || lessonId !== Number(this.inlineTopicLessonId || 0)) {
        return;
      }
      this.inlineTopicDraft = inlineTopicInput.value;
      event.stopPropagation();
      if (event.key === "Enter" && !(event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        this.finishInlineWeekBlockTopicEdit(true);
        return;
      }
      if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        const start = Number(inlineTopicInput.selectionStart ?? inlineTopicInput.value.length);
        const end = Number(inlineTopicInput.selectionEnd ?? start);
        const current = String(inlineTopicInput.value || "");
        const next = `${current.slice(0, start)}\n${current.slice(end)}`;
        inlineTopicInput.value = next;
        inlineTopicInput.selectionStart = start + 1;
        inlineTopicInput.selectionEnd = start + 1;
        this.inlineTopicDraft = inlineTopicInput.value;
        this.syncInlineWeekBlockTopicInputSize(inlineTopicInput);
        return;
      }
      if (event.key === "Escape") {
        event.preventDefault();
        this.finishInlineWeekBlockTopicEdit(false);
      }
    });

    this.refs.weekTable.addEventListener("focusout", (event) => {
      const inlineTopicInput = event.target.closest(".week-inline-topic-input[data-lesson-id]");
      if (!inlineTopicInput) {
        return;
      }
      const lessonId = Number(inlineTopicInput.dataset.lessonId || 0);
      if (!lessonId || lessonId !== Number(this.inlineTopicLessonId || 0)) {
        return;
      }
      this.inlineTopicDraft = inlineTopicInput.value;
      const nextFocused = event.relatedTarget;
      if (nextFocused === inlineTopicInput) {
        return;
      }
      this.finishInlineWeekBlockTopicEdit(true);
    });

    this.refs.weekTable.addEventListener("dblclick", async (event) => {
      if (this.locked) {
        return;
      }
      const lessonBlock = event.target.closest(".lesson-block[data-lesson-id]");
      if (lessonBlock) {
        return;
      }
      const dayCell = event.target.closest("td.day-cell.empty[data-day][data-hour]");
      if (!dayCell) {
        return;
      }
      const day = Number(dayCell.dataset.day);
      const hour = Number(dayCell.dataset.hour);
      await this.openSlotDialogForCreate(day, hour);
    });

    this.refs.weekTable.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      if (event.button !== 2) {
        this.hideContextMenu();
        return;
      }
      if (this.locked) {
        this.hideContextMenu();
        return;
      }
      const lessonBlock = event.target.closest(".lesson-block[data-lesson-id]");
      if (!lessonBlock || lessonBlock.matches("button:disabled")) {
        this.hideContextMenu();
        if (this.selectedLessonId) {
          this.selectedLessonId = null;
          this.resetInlineWeekBlockTopicEdit();
          this.renderWeekTable();
          this.renderLessonSection();
        }
        return;
      }
      this.openWeekBlockContextMenu(
        Number(lessonBlock.dataset.lessonId),
        event.clientX,
        event.clientY,
        "week"
      );
    });

    this.refs.hoursPerDay.addEventListener("change", () => {
      const hours = clamp(Number(this.refs.hoursPerDay.value) || HOURS_PER_DAY_DEFAULT, 1, 12);
      this.settingsDraft.hoursPerDay = hours;
      this.refs.hoursPerDay.value = String(hours);
      this.renderDisplaySection();
      this.refreshSettingsDirtyState();
    });

    if (this.refs.showHiddenSidebarCourses) {
      this.refs.showHiddenSidebarCourses.addEventListener("change", () => {
        this.settingsDraft.showHiddenSidebarCourses = Boolean(this.refs.showHiddenSidebarCourses.checked);
        this.renderDisplaySection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.backupAutoEnabled) {
      this.refs.backupAutoEnabled.addEventListener("change", () => {
        this.settingsDraft.backupEnabled = Boolean(this.refs.backupAutoEnabled.checked);
        this.renderBackupSection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.backupIntervalDays) {
      this.refs.backupIntervalDays.addEventListener("change", () => {
        const days = clamp(
          Number(this.refs.backupIntervalDays.value) || BACKUP_INTERVAL_DEFAULT_DAYS,
          1,
          30
        );
        this.settingsDraft.backupIntervalDays = days;
        this.refs.backupIntervalDays.value = String(days);
        this.renderBackupSection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.backupNowBtn) {
      this.refs.backupNowBtn.addEventListener("click", () => {
        this.createLatestWebBackup("manual");
        this.renderBackupSection();
      });
    }

    if (this.refs.dbBackupAutoEnabled) {
      this.refs.dbBackupAutoEnabled.addEventListener("change", () => {
        this.settingsDraft.backupEnabled = Boolean(this.refs.dbBackupAutoEnabled.checked);
        this.renderBackupSection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.dbBackupIntervalDays) {
      this.refs.dbBackupIntervalDays.addEventListener("change", () => {
        const days = clamp(
          Number(this.refs.dbBackupIntervalDays.value) || BACKUP_INTERVAL_DEFAULT_DAYS,
          1,
          30
        );
        this.settingsDraft.backupIntervalDays = days;
        this.refs.dbBackupIntervalDays.value = String(days);
        this.renderBackupSection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.dbBackupNowBtn) {
      this.refs.dbBackupNowBtn.addEventListener("click", () => {
        this.createLatestWebBackup("manual");
        this.renderBackupSection();
      });
    }

    if (this.refs.backupDirChangeBtn) {
      this.refs.backupDirChangeBtn.addEventListener("click", async () => {
        if (!this.syncState.fileHandle) {
          await this.showInfoMessage("Bitte zuerst eine Datenbankdatei auswählen.");
          return;
        }
        if (!this.backupState.directoryHandle && this.backupState.storedDirectoryHandle) {
          if (await this.ensureSyncFilePermission(this.backupState.storedDirectoryHandle, true)) {
            this.backupState.directoryHandle = this.backupState.storedDirectoryHandle;
            this.setBackupStatus("Backup-Ordner verbunden.");
            this.renderAll();
            return;
          }
        }
        const assigned = await this.assignBackupDirectoryFromSyncFile(this.syncState.fileHandle);
        if (assigned && this.backupState.directoryHandle) {
          this.backupState.storedDirectoryHandle = this.backupState.directoryHandle;
          await storeHandle(SYNC_HANDLE_BACKUP_DIR_KEY, this.backupState.directoryHandle);
          this.setBackupStatus("Backup-Ordner verbunden.");
        } else {
          this.setBackupStatus("Backup-Ordner wurde nicht verbunden.", true);
        }
        this.renderAll();
      });
    }

    if (this.refs.backupExportBtn) {
      this.refs.backupExportBtn.addEventListener("click", () => {
        this.exportBackup();
        this.renderBackupSection();
      });
    }

    if (this.refs.backupImportBtn && this.refs.backupImportFile) {
      this.refs.backupImportBtn.addEventListener("click", () => {
        this.refs.backupImportFile.click();
      });
    }

    if (this.refs.backupImportFile) {
      this.refs.backupImportFile.addEventListener("change", async () => {
        const [file] = this.refs.backupImportFile.files || [];
        if (!file) {
          return;
        }
        await this.importBackupFromFile(file);
        this.refs.backupImportFile.value = "";
        this.renderBackupSection();
      });
    }

    if (this.refs.backupRestoreBtn) {
      this.refs.backupRestoreBtn.addEventListener("click", async () => {
        await this.restoreLatestWebBackup();
      });
    }

    if (this.refs.backupResetDefaults) {
      this.refs.backupResetDefaults.addEventListener("click", () => {
        this.settingsDraft.backupEnabled = BACKUP_ENABLED_DEFAULT;
        this.settingsDraft.backupIntervalDays = BACKUP_INTERVAL_DEFAULT_DAYS;
        this.renderBackupSection();
        this.refreshSettingsDirtyState();
      });
    }

    if (this.refs.dbSelectExistingBtn) {
      this.refs.dbSelectExistingBtn.addEventListener("click", async () => {
        const reconnected = await this.tryReconnectStoredSyncFile();
        if (reconnected) {
          return;
        }
        await this.selectSyncFile("existing");
      });
    }

    if (this.refs.dbCreateNewBtn) {
      this.refs.dbCreateNewBtn.addEventListener("click", async () => {
        await this.selectSyncFile("new");
      });
    }

    this.refs.courseSettingsAdd.addEventListener("click", () => {
      if (this.locked) {
        return;
      }
      this.openCourseDialog();
    });

    this.refs.courseList.addEventListener("click", (event) => {
      const button = event.target.closest("button[data-action]");
      if (!button) {
        return;
      }
      if (this.locked) {
        return;
      }
      const id = Number(button.dataset.id);
      const action = button.dataset.action;
      if (!id) {
        return;
      }
      if (action === "edit" || action === "delete") {
        this.openCourseDialog(id);
        if (action === "delete") {
          this.refs.courseDialogDelete.focus();
        }
        return;
      }
    });

    this.refs.courseList.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      if (event.button !== 2) {
        this.hideContextMenu();
        return;
      }
      const row = event.target.closest("li[data-course-id]");
      if (!row) {
        return;
      }
      if (this.locked) {
        this.hideContextMenu();
        return;
      }
      const id = Number(row.dataset.courseId);
      if (!id) {
        return;
      }
      this.openCourseDialog(id);
    });

    this.refs.slotForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const ok = await this.persistSlotChange({
        slotId: this.refs.slotId.value || null,
        courseId: this.refs.slotCourse.value,
        dayOfWeek: this.refs.slotDay.value,
        startHour: this.refs.slotHour.value,
        duration: this.refs.slotDuration.value,
        startDate: this.refs.slotStart.value || null,
        endDateInput: this.refs.slotEnd.value || null,
        recurrenceValue: this.refs.slotParity.value,
        editScope: this.refs.slotEditScope.value || "all",
        editFromDate: this.refs.slotEditFromDate.value || null
      });
      if (!ok) {
        return;
      }
      this.resetSlotForm();
      this.renderAll();
    });

    this.refs.slotCourse.addEventListener("change", () => {
      this.syncSlotFormCourseColor();
    });

    this.refs.slotEditScope.addEventListener("change", () => {
      this.syncSlotEditTools();
    });

    this.refs.slotParity.addEventListener("change", () => {
      this.syncSlotEditTools();
    });

    this.refs.slotStart.addEventListener("change", () => {
      if (Number(this.refs.slotParity.value || 0) === -1) {
        this.refs.slotEnd.value = this.refs.slotStart.value || "";
      }
    });

    this.refs.slotEditFromDate.addEventListener("change", () => {
      if (this.refs.slotEditScope.value === "from" && this.refs.slotEditFromDate.value) {
        this.refs.slotStart.value = this.refs.slotEditFromDate.value;
        if (Number(this.refs.slotParity.value || 0) === -1) {
          this.refs.slotEnd.value = this.refs.slotEditFromDate.value;
        }
      }
    });

    this.refs.slotReset.addEventListener("click", () => {
      this.resetSlotForm();
    });

    this.refs.slotDelete.addEventListener("click", async () => {
      const slotId = Number(this.refs.slotId.value || 0);
      if (!slotId) {
        return;
      }
      const ok = await this.deleteSlotWithScope(
        slotId,
        this.refs.slotEditScope.value || "all",
        this.refs.slotEditFromDate.value || null
      );
      if (!ok) {
        return;
      }
      this.resetSlotForm();
      this.renderAll();
    });

    this.refs.slotList.addEventListener("click", async (event) => {
      const button = event.target.closest("button[data-action]");
      if (!button) {
        return;
      }
      const id = Number(button.dataset.id);
      const action = button.dataset.action;

      if (action === "edit") {
        const slot = this.store.getSlot(id);
        if (!slot) {
          return;
        }
        await this.openSlotDialogForEdit(slot);
        return;
      }

      if (action === "delete") {
        if (!await this.showConfirmMessage("Unterrichtsstunde löschen?")) {
          return;
        }
        this.store.deleteSlot(id);
        this.selectedLessonId = null;
        this.renderAll();
      }
    });

    if (this.refs.freeRangeAdd) {
      this.refs.freeRangeAdd.addEventListener("click", () => {
        this.openFreeRangeDialog();
      });
    }

    this.refs.freeRangeDialogCancel.addEventListener("click", () => {
      this.closeFreeRangeDialog();
    });

    this.refs.freeRangeDialogLabel.addEventListener("change", () => {
      this.applySuggestedHolidayRangeInDialog();
    });

    this.refs.freeRangeDialogLabel.addEventListener("blur", () => {
      this.applySuggestedHolidayRangeInDialog();
    });

    this.refs.freeRangeDialogForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      await this.submitFreeRangeDialog();
    });

    if (this.refs.freeRangeDialogDelete) {
      this.refs.freeRangeDialogDelete.addEventListener("click", async () => {
        await this.deleteFreeRangeFromDialog();
      });
    }

    this.refs.freeRangeDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeFreeRangeDialog();
    });

    this.refs.freeRangeList.addEventListener("click", (event) => {
      const row = event.target.closest("li[data-clickable='1']");
      if (!row) {
        return;
      }
      const year = this.activeSchoolYear;
      if (!year) {
        return;
      }
      const id = Number(row.dataset.id || 0);
      const presetLabel = String(row.dataset.label || "").trim();
      const occurrence = Number(row.dataset.occurrence || 0);
      if (id) {
        this.openFreeRangeDialog(id);
      } else if (presetLabel) {
        this.openFreeRangeDialog(null, presetLabel, occurrence);
      }
    });

    this.refs.specialDayDialogCancel.addEventListener("click", () => {
      this.closeSpecialDayDialog();
    });

    this.refs.specialDayDialogName.addEventListener("change", () => {
      this.applySuggestedSpecialDayDateInDialog();
    });

    this.refs.specialDayDialogName.addEventListener("blur", () => {
      this.applySuggestedSpecialDayDateInDialog();
    });

    this.refs.specialDayDialogForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      await this.submitSpecialDayDialog();
    });

    this.refs.specialDayDialogDelete.addEventListener("click", async () => {
      await this.deleteSpecialDayFromDialog();
    });

    this.refs.specialDayDialog.addEventListener("cancel", (event) => {
      event.preventDefault();
      this.closeSpecialDayDialog();
    });

    this.refs.specialDayList.addEventListener("click", (event) => {
      const actionButton = event.target.closest("button[data-action]");
      const action = actionButton ? actionButton.dataset.action : "";
      if (action === "add") {
        if (this.activeSchoolYear) {
          this.openSpecialDayDialog();
        }
        return;
      }
      const row = event.target.closest("li[data-special-day-id]");
      if (!row || !this.activeSchoolYear) {
        return;
      }
      const id = Number(row.dataset.specialDayId || 0);
      if (!id) {
        return;
      }
      this.openSpecialDayDialog(id);
    });

    this.refs.courseTable.addEventListener("change", (event) => {
      const input = event.target.closest("input.course-topic-input");
      if (!input) {
        return;
      }
      const lessonId = Number(input.dataset.lessonId);
      const isEntfall = input.dataset.isEntfall === "1";
      const isWritten = input.dataset.isWritten === "1";
      this.store.updateLessonBlock(lessonId, input.value, isEntfall, isWritten);
      this.renderWeekSection();
      this.renderCourseTimeline();
      this.renderLessonSection();
    });

    this.refs.courseTable.addEventListener("click", (event) => {
      this.hideContextMenu();
      const topicInput = event.target.closest("input.course-topic-input");
      if (topicInput && !topicInput.disabled) {
        topicInput.focus();
        topicInput.select();
        return;
      }
      const dateButton = event.target.closest("button.course-date-link[data-date]");
      if (dateButton) {
        const targetWeek = this._clampWeekStart(weekStartFor(dateButton.dataset.date));
        if (targetWeek !== this.weekStartIso) {
          this.weekStartIso = targetWeek;
        }
        this.selectedLessonId = null;
        this.switchView("week");
        this.renderWeekSection();
        this.renderLessonSection();
      }
    });

    this.refs.courseTable.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      if (event.button !== 2) {
        this.hideContextMenu();
        return;
      }
      if (this.locked) {
        this.hideContextMenu();
        return;
      }
      const row = event.target.closest("tr[data-lesson-id]");
      if (!row) {
        this.hideContextMenu();
        return;
      }
      const lessonId = Number(row.dataset.lessonId);
      const lesson = this.store.getLessonById(lessonId);
      if (!lesson) {
        this.hideContextMenu();
        return;
      }
      const block = this.store.getLessonBlock(lessonId);
      if (block.length === 0 || block.every((entry) => entry.canceled)) {
        this.hideContextMenu();
        return;
      }
      this.openWeekBlockContextMenu(lessonId, event.clientX, event.clientY, "course");
    });

    document.addEventListener("click", (event) => {
      if (!this.refs.contextMenu || this.refs.contextMenu.hidden) {
        return;
      }
      if (this.refs.contextMenu.contains(event.target)) {
        return;
      }
      this.hideContextMenu();
    });

    document.addEventListener("contextmenu", (event) => {
      event.preventDefault();
      if (event.button !== 2) {
        this.hideContextMenu();
        return;
      }
      if (!this.refs.contextMenu || this.refs.contextMenu.hidden) {
        return;
      }
      if (this.refs.contextMenu.contains(event.target)) {
        return;
      }
      const isMenuAnchor = Boolean(
        event.target && event.target.closest && event.target.closest(".lesson-block[data-lesson-id]")
      ) || Boolean(
        event.target && event.target.closest && event.target.closest("tr[data-lesson-id]")
      );
      if (!isMenuAnchor) {
        this.hideContextMenu();
      }
    });

    document.addEventListener("selectstart", (event) => {
      const target = event.target;
      const editable = Boolean(
        target
        && target.closest
        && target.closest("input, textarea, select, [contenteditable='true']")
      );
      if (!editable) {
        event.preventDefault();
      }
    });

    window.addEventListener("resize", () => {
      this.hideContextMenu();
      if (this.refs.weekCalendarDialog && this.refs.weekCalendarDialog.open) {
        this.positionWeekCalendarDialog();
      }
      if (this.currentView === "week") {
        this.syncWeekLayoutScale();
      }
    });

    window.addEventListener("scroll", () => {
      this.hideContextMenu();
      if (this.refs.weekCalendarDialog && this.refs.weekCalendarDialog.open) {
        this.closeWeekCalendarDialog();
      }
    }, true);

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        this.hideContextMenu();
        return;
      }
      const key = String(event.key || "").toLowerCase();
      const copyPressed = (event.ctrlKey || event.metaKey) && !event.altKey && key === "c";
      if (!copyPressed) {
        return;
      }
      const target = event.target;
      const editable = Boolean(
        target
        && target.closest
        && target.closest("input, textarea, select, [contenteditable='true']")
      );
      if (editable) {
        return;
      }
      const title = this.getSelectedWeekLessonTitle();
      if (!title) {
        return;
      }
      event.preventDefault();
      void this.writeClipboardText(title);
    });
  }

  initPwa() {
    if ("serviceWorker" in navigator && window.isSecureContext) {
      navigator.serviceWorker.addEventListener("message", (event) => {
        const data = event.data || {};
        if (data.type === "VERSION" && Number.isFinite(Number(data.version))) {
          this.appVersion = String(Number(data.version));
          if (this.refs.appVersion) {
            this.refs.appVersion.textContent = this.appVersion;
          }
        }
      });

      navigator.serviceWorker.addEventListener("controllerchange", () => {
        if (this.pwaReloadTriggered) {
          return;
        }
        this.pwaReloadTriggered = true;
        window.location.reload();
      });

      navigator.serviceWorker.register("./service-worker.js")
        .then((registration) => {
          this.pwaRegistration = registration;
          this.requestServiceWorkerVersion();
          this.attachServiceWorkerUpdateHandlers(registration);
          return registration.update().catch(() => undefined);
        })
        .catch(() => undefined);
    }
  }

  requestServiceWorkerVersion() {
    if (!("serviceWorker" in navigator)) {
      return;
    }
    const registration = this.pwaRegistration;
    const worker = (registration && (registration.active || registration.waiting || registration.installing))
      || navigator.serviceWorker.controller;
    if (!worker || typeof worker.postMessage !== "function") {
      return;
    }
    worker.postMessage({ type: "GET_VERSION" });
  }

  attachServiceWorkerUpdateHandlers(registration) {
    const promptForWaitingUpdate = async () => {
      if (!registration.waiting) {
        return;
      }
      const confirmed = await this.showConfirmMessage("Neue Version verfügbar – App neu starten", {
        title: "Update verfügbar",
        okText: "Neu starten",
        cancelText: "Später"
      });
      if (!confirmed || !registration.waiting) {
        return;
      }
      registration.waiting.postMessage({ type: "SKIP_WAITING" });
    };

    if (registration.waiting) {
      void promptForWaitingUpdate();
    }

    registration.addEventListener("updatefound", () => {
      const installing = registration.installing;
      if (!installing) {
        return;
      }
      installing.addEventListener("statechange", () => {
        if (installing.state === "installed" && registration.waiting) {
          void promptForWaitingUpdate();
          this.requestServiceWorkerVersion();
        }
      });
    });
  }

  setBackupStatus(text, isError = false) {
    if (!this.refs.backupStatus) {
      return;
    }
    this.refs.backupStatus.textContent = text || "";
    this.refs.backupStatus.style.color = isError ? "#ff8a8a" : "";
  }

  formatDateTime(isoDateTime) {
    if (!isoDateTime) {
      return "";
    }
    const value = new Date(isoDateTime);
    if (Number.isNaN(value.getTime())) {
      return "";
    }
    return value.toLocaleString("de-DE", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }

  readLatestWebBackupSnapshot() {
    return null;
  }

  writeLatestWebBackupSnapshot(snapshot) {
    void snapshot;
    return false;
  }

  createLatestWebBackup(mode = "manual", silent = false) {
    const createdAt = new Date().toISOString();
    const backupMode = String(mode || "manual");
    if (!this.backupState.directoryHandle) {
      if (!silent) {
        this.setBackupStatus("Backup-Ordner nicht verfügbar. Bitte Datenbankdatei neu auswählen.", true);
      }
      return { ok: false };
    }
    const payload = this.store.exportBackupPayload();
    this.writeBackupFileSnapshot(payload).then((ok) => {
      if (!ok) {
        if (!silent) {
          this.setBackupStatus("Backup-Datei konnte nicht erstellt werden.", true);
        }
        return;
      }
      if (backupMode === "auto") {
        this.lastAutoBackupAt = createdAt;
      }
      if (!silent) {
        this.setBackupStatus("Backup-Datei erstellt.");
        if (backupMode === "manual") {
          this.showInfoMessage("Backup wurde erfolgreich erstellt.").catch(() => undefined);
        }
      }
    }).catch(() => {
      if (!silent) {
        this.setBackupStatus("Backup fehlgeschlagen.", true);
      }
    });
    if (!silent && backupMode === "auto") {
      this.setBackupStatus("Automatisches Backup gestartet.");
    }
    return { ok: true, createdAt };
  }

  maybeRunAutomaticWebBackup() {
    if (!this.store.getBackupEnabled()) {
      return false;
    }
    if (!this.backupState.directoryHandle) {
      return false;
    }
    const intervalDays = this.store.getBackupIntervalDays();
    const nowMs = Date.now();
    const lastAuto = this.lastAutoBackupAt;
    const lastAutoMs = lastAuto ? Date.parse(lastAuto) : NaN;
    const due = Number.isNaN(lastAutoMs) || (nowMs - lastAutoMs) >= (intervalDays * BACKUP_DAY_MS);
    if (!due) {
      return false;
    }
    const result = this.createLatestWebBackup("auto", true);
    if (result.ok) {
      this.setBackupStatus("Automatisches Backup gestartet.");
    }
    return result.ok;
  }

  renderDatabaseSection() {
    const pendingStoredHandle = !this.syncState.fileHandle ? this.syncState.storedFileHandle : null;
    const pendingStoredFileName = pendingStoredHandle
      ? String(pendingStoredHandle.name || this.syncState.fileName || this.syncMeta.fileName || "")
      : "";
    if (this.refs.syncFileName) {
      if (!this.syncState.supported) {
        this.refs.syncFileName.textContent = "Nicht unterstützt";
      } else if (pendingStoredHandle) {
        this.refs.syncFileName.textContent = `Datenbankdatei: ${pendingStoredFileName} (Zugriff ausstehend)`;
      } else if (!this.syncState.fileHandle) {
        this.refs.syncFileName.textContent = "Datenbankdatei: nicht ausgewählt";
      } else {
        this.refs.syncFileName.textContent = this.syncState.fileName || "";
      }
    }
    if (this.refs.syncFileStatus) {
      const currentStatus = String(this.refs.syncFileStatus.textContent || "").trim();
      if (!this.syncState.supported) {
        this.setSyncStatus(
          "Datei-Sync wird in diesem Browser nicht unterstützt.",
          true
        );
      } else if (!this.syncState.fileHandle) {
        const hasConnectedStatus = currentStatus === "Datenbankdatei verbunden."
          || currentStatus.startsWith("Zuletzt synchronisiert:");
        if (!currentStatus || hasConnectedStatus) {
          this.setSyncStatus(
            pendingStoredHandle
              ? "Gespeicherte Datenbank gefunden. Bitte Zugriff erlauben."
              : "Noch keine Datenbankdatei verbunden."
          );
        }
      } else {
        const hasDisconnectedStatus = currentStatus === "Noch keine Datenbankdatei verbunden."
          || currentStatus === "Bitte Datenbankdatei erneut auswählen."
          || currentStatus === "Gespeicherte Datenbank gefunden. Bitte Zugriff erlauben.";
        if (!currentStatus || hasDisconnectedStatus) {
          if (this.syncMeta.lastSyncedAt) {
            this.setSyncStatus(`Zuletzt synchronisiert: ${this.formatDateTime(this.syncMeta.lastSyncedAt)}`);
          } else {
            this.setSyncStatus("Datenbankdatei verbunden.");
          }
        }
      }
    }
    const allowDatabaseControls = this.lockReason === "databaseRequired" || this.lockReason === "backupDirRequired";
    const disabled = this.locked && !allowDatabaseControls;
    const shouldPulse = this.locked && this.lockReason === "databaseRequired";
    if (this.refs.dbSelectExistingBtn) {
      this.refs.dbSelectExistingBtn.disabled = disabled;
      this.refs.dbSelectExistingBtn.classList.toggle("attention-pulse", shouldPulse);
    }
    if (this.refs.dbCreateNewBtn) {
      this.refs.dbCreateNewBtn.disabled = disabled;
      this.refs.dbCreateNewBtn.classList.toggle("attention-pulse", shouldPulse);
    }
    this.updateSettingsActionButtons();
  }

  renderBackupSection() {
    const hasBackupTabControls = Boolean(this.refs.backupAutoEnabled && this.refs.backupIntervalDays);
    const hasDatabaseTabControls = Boolean(this.refs.dbBackupAutoEnabled && this.refs.dbBackupIntervalDays);
    if (!hasBackupTabControls && !hasDatabaseTabControls) {
      return;
    }
    const draft = this.settingsDraft || this.buildSettingsDraftFromStore();
    const enabled = Boolean(draft.backupEnabled);
    const interval = clamp(Number(draft.backupIntervalDays) || BACKUP_INTERVAL_DEFAULT_DAYS, 1, 30);
    const backupFileConnected = Boolean(this.backupState.directoryHandle);
    const pendingStoredBackupDir = !backupFileConnected ? this.backupState.storedDirectoryHandle : null;
    if (this.refs.backupDirName) {
      if (!this.syncState.supported) {
        this.refs.backupDirName.textContent = "Backup-Ordner: nicht unterstützt";
      } else if (!this.syncState.fileHandle) {
        this.refs.backupDirName.textContent = "Backup-Ordner: nicht ausgewählt";
      } else if (backupFileConnected) {
        this.refs.backupDirName.textContent = `Backup-Ordner: ${String(this.backupState.directoryHandle.name || "")}`;
      } else if (pendingStoredBackupDir) {
        this.refs.backupDirName.textContent = `Backup-Ordner: ${String(pendingStoredBackupDir.name || "")} (Zugriff ausstehend)`;
      } else {
        this.refs.backupDirName.textContent = "Backup-Ordner: nicht ausgewählt";
      }
    }
    if (this.refs.backupDirChangeBtn) {
      this.refs.backupDirChangeBtn.disabled = !this.syncState.fileHandle;
      this.refs.backupDirChangeBtn.classList.toggle(
        "attention-pulse",
        Boolean(this.syncState.fileHandle) && !backupFileConnected
      );
    }
    if (this.refs.backupAutoEnabled) {
      this.refs.backupAutoEnabled.checked = enabled;
    }
    if (this.refs.backupIntervalDays) {
      this.refs.backupIntervalDays.value = String(interval);
      this.refs.backupIntervalDays.disabled = !enabled;
    }
    if (this.refs.dbBackupAutoEnabled) {
      this.refs.dbBackupAutoEnabled.checked = enabled;
    }
    if (this.refs.dbBackupIntervalDays) {
      this.refs.dbBackupIntervalDays.value = String(interval);
      this.refs.dbBackupIntervalDays.disabled = !enabled;
    }
    if (this.refs.backupNowBtn) {
      this.refs.backupNowBtn.disabled = !backupFileConnected;
    }
    if (this.refs.dbBackupNowBtn) {
      this.refs.dbBackupNowBtn.disabled = !backupFileConnected;
    }

    let snapshotAvailable = false;
    if (this.refs.backupRestoreBtn) {
      this.refs.backupRestoreBtn.disabled = !snapshotAvailable;
    }
    if (this.refs.backupResetDefaults) {
      const isDefaultConfig = enabled === BACKUP_ENABLED_DEFAULT
        && interval === BACKUP_INTERVAL_DEFAULT_DAYS;
      this.refs.backupResetDefaults.disabled = isDefaultConfig;
    }

    if (this.refs.backupHint) {
      this.refs.backupHint.textContent = "";
      this.refs.backupHint.classList.remove("backup-due");
    }
    this.syncAllNumberSteppers();
    this.updateSettingsActionButtons();
  }

  async restoreLatestWebBackup() {
    await this.showInfoMessage("Interne Browser-Backups sind deaktiviert. Verwende stattdessen die Datenbankdatei.");
  }

  exportBackup() {
    try {
      this.createLatestWebBackup("manual", true);
      const payload = this.store.exportBackupPayload();
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const now = new Date();
      const stamp = [
        String(now.getFullYear()),
        String(now.getMonth() + 1).padStart(2, "0"),
        String(now.getDate()).padStart(2, "0"),
        "-",
        String(now.getHours()).padStart(2, "0"),
        String(now.getMinutes()).padStart(2, "0"),
        String(now.getSeconds()).padStart(2, "0")
      ].join("");
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = `Planung-Backup-${stamp}.json`;
      document.body.append(anchor);
      anchor.click();
      anchor.remove();
      URL.revokeObjectURL(url);
      this.setBackupStatus("Backup exportiert.");
      this.renderBackupSection();
    } catch (_error) {
      this.setBackupStatus("Backup konnte nicht exportiert werden.", true);
    }
  }

  async importBackupFromFile(file) {
    try {
      const allow = await this.showConfirmMessage("Aktuelle Daten durch das Backup ersetzen?");
      if (!allow) {
        this.setBackupStatus("Import abgebrochen.");
        return;
      }
      const text = await file.text();
      const parsed = JSON.parse(text);
      const result = this.store.importBackupPayload(parsed);
      if (!result.ok) {
        this.setBackupStatus(result.message || "Backup konnte nicht importiert werden.", true);
        return;
      }
      this.settingsDraft = this.buildSettingsDraftFromStore();
      this.settingsDirty = false;
      this.weekStartIso = this._clampWeekStart(currentWeekStartForDisplay());
      this.selectedLessonId = null;
      this.selectedCourseId = null;
      this.renderAll();
      this.setBackupStatus("Backup erfolgreich importiert.");
    } catch (_error) {
      this.setBackupStatus("Datei konnte nicht gelesen werden.", true);
    }
  }

  syncSlotEditTools() {
    const isEditing = Boolean(this.refs.slotId.value);
    const recurrenceNone = Number(this.refs.slotParity.value || 0) === -1;
    this.refs.slotEditTools.hidden = !isEditing;
    this.refs.slotDelete.hidden = !isEditing;
    if (!isEditing) {
      this.refs.slotEditScope.value = "all";
      this.refs.slotEditFromDate.value = "";
      this.refs.slotEditFromDate.disabled = true;
      this.refs.slotStart.disabled = false;
      this.refs.slotEnd.disabled = recurrenceNone;
      if (recurrenceNone) {
        this.refs.slotEnd.value = this.refs.slotStart.value || "";
      }
      return;
    }
    const fromScope = this.refs.slotEditScope.value === "from";
    this.refs.slotEditFromDate.disabled = !fromScope;
    this.refs.slotStart.disabled = fromScope;
    if (fromScope && this.refs.slotEditFromDate.value) {
      this.refs.slotStart.value = this.refs.slotEditFromDate.value;
    }
    if (recurrenceNone) {
      this.refs.slotEnd.value = this.refs.slotStart.value || "";
    }
    this.refs.slotEnd.disabled = recurrenceNone;
  }

  prefillSlotFromGrid(dayOfWeek, startHour) {
    const year = this.activeSchoolYear;
    this.switchView("settings");
    this.refs.slotId.value = "";
    this.refs.slotDay.value = String(dayOfWeek);
    this.refs.slotHour.value = String(startHour);
    if (this.selectedCourseId) {
      this.refs.slotCourse.value = String(this.selectedCourseId);
    }
    this.refs.slotDuration.value = "1";
    this.refs.slotParity.value = "0";
    if (year) {
      let startDefault = addDays(this.weekStartIso, Number(dayOfWeek) - 1);
      if (startDefault < year.startDate) {
        startDefault = year.startDate;
      }
      if (startDefault > year.endDate) {
        startDefault = year.endDate;
      }
      const endDefault = this._computeSlotEndDefault(startDefault);

      this.refs.slotStart.value = startDefault;
      this.refs.slotEnd.value = endDefault;
    } else {
      this.refs.slotStart.value = "";
      this.refs.slotEnd.value = "";
    }
    this.syncSlotEditTools();
  }

  prefillSlotForEdit(slot, clickedDate = null) {
    const year = this.activeSchoolYear;
    if (!slot || !year) {
      return;
    }
    this.switchView("settings");
    this.refs.slotId.value = String(slot.id);
    this.refs.slotCourse.value = String(slot.courseId);
    this.refs.slotDay.value = String(slot.dayOfWeek);
    this.refs.slotHour.value = String(slot.startHour);
    this.refs.slotDuration.value = String(slot.duration);
    this.refs.slotStart.value = slot.startDate || "";
    this.refs.slotEnd.value = slot.endDate || "";
    let displayParity = Number(slot.weekParity || 0);
    if (displayParity === 0 && slot.startDate && slot.endDate && slot.startDate === slot.endDate) {
      displayParity = -1;
    }
    this.refs.slotParity.value = String(displayParity);
    this.refs.slotEditScope.value = "all";

    const slotStart = slot.startDate || year.startDate;
    const slotEnd = slot.endDate || year.endDate;
    this.refs.slotEditFromDate.min = slotStart;
    this.refs.slotEditFromDate.max = slotEnd;

    let defaultFrom = this.weekStartIso > slotStart ? this.weekStartIso : slotStart;
    if (clickedDate && clickedDate >= slotStart && clickedDate <= slotEnd) {
      defaultFrom = clickedDate;
      this.refs.slotEditScope.value = "from";
    }
    this.refs.slotEditFromDate.value = defaultFrom > slotEnd ? slotEnd : defaultFrom;
    this.syncSlotEditTools();
  }

  hideContextMenu() {
    const menu = this.refs.contextMenu;
    if (!menu) {
      return;
    }
    if (typeof menu.close === "function" && menu.open) {
      menu.close();
    }
    menu.hidden = true;
    menu.innerHTML = "";
    this.contextMenuItems = [];
  }

  showContextMenu(items, clientX, clientY) {
    const menu = this.refs.contextMenu;
    if (!menu) {
      return;
    }
    const available = (items || []).filter((item) => item && item.label);
    if (available.length === 0) {
      this.hideContextMenu();
      return;
    }
    this.contextMenuItems = available;
    menu.innerHTML = "";
    for (const item of available) {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "context-item";
      button.textContent = item.label;
      if (item.separatorBefore) {
        button.classList.add("separator-before");
      }
      button.disabled = Boolean(item.disabled);
      button.addEventListener("click", async () => {
        this.hideContextMenu();
        if (item.disabled || typeof item.handler !== "function") {
          return;
        }
        await item.handler();
      });
      menu.append(button);
    }
    menu.hidden = false;
    if (typeof menu.show === "function" && !menu.open) {
      try {
        menu.show();
      } catch (_error) {
        menu.setAttribute("open", "open");
      }
    }
    const menuRect = menu.getBoundingClientRect();
    const margin = 8;
    const maxX = window.innerWidth - menuRect.width - margin;
    const maxY = window.innerHeight - menuRect.height - margin;
    const left = clamp(clientX, margin, Math.max(margin, maxX));
    const top = clamp(clientY, margin, Math.max(margin, maxY));
    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
  }

  async writeClipboardText(text) {
    const normalized = String(text || "");
    this.localClipboardText = normalized;
    try {
      if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
        await navigator.clipboard.writeText(normalized);
      }
    } catch (_error) {
      return;
    }
  }

  async readClipboardText() {
    try {
      if (navigator.clipboard && typeof navigator.clipboard.readText === "function") {
        const text = await navigator.clipboard.readText();
        if (text || text === "") {
          this.localClipboardText = text;
          return text;
        }
      }
    } catch (_error) {
      return this.localClipboardText || "";
    }
    return this.localClipboardText || "";
  }

  getSelectedWeekLessonTitle() {
    if (this.currentView !== "week") {
      return "";
    }
    const lessonId = Number(this.selectedLessonId || 0);
    if (!lessonId) {
      return "";
    }
    const lesson = this.store.getLessonById(lessonId);
    if (!lesson) {
      return "";
    }
    const block = this.store.getLessonBlock(lesson.id);
    if (!Array.isArray(block) || block.length === 0) {
      return "";
    }
    const allCanceled = block.every((entry) => entry.canceled);
    const anyCanceled = block.some((entry) => entry.canceled);
    const partialCanceled = anyCanceled && !allCanceled;
    const isNoLesson = Boolean(lesson.noLesson);
    const isEntfall = block.some((entry) => entry.isEntfall);
    const isWritten = block.some((entry) => entry.isWrittenExam);
    const topics = new Set(
      block
        .map((entry) => String(entry.topic || "").trim())
        .filter(Boolean)
    );
    let displayTopic = "";
    if (allCanceled && lesson.cancelLabel) {
      displayTopic = String(lesson.cancelLabel || "").trim();
    } else if (isNoLesson) {
      displayTopic = String(lesson.courseName || "").trim();
    } else if (topics.size === 1) {
      displayTopic = [...topics][0];
    } else if (topics.size > 1) {
      displayTopic = "Mehrere Themen";
    }
    if (!allCanceled && !isNoLesson && (isEntfall || isWritten)) {
      displayTopic = overrideTopicForFlags(displayTopic, isEntfall, isWritten);
    }
    const displayText = allCanceled
      ? (String(lesson.cancelLabel || "").trim() || "Unterrichtsfrei")
      : formatPartialDisplay(displayTopic, partialCanceled);
    return String(displayText || "").trim();
  }

  resetInlineWeekBlockTopicEdit() {
    this.inlineTopicLessonId = null;
    this.inlineTopicDraft = "";
  }

  syncInlineWeekBlockTopicInputSize(targetInput = null) {
    const input = targetInput
      || (
        this.refs.weekTable
          ? this.refs.weekTable.querySelector(
            `.week-inline-topic-input[data-lesson-id="${Number(this.inlineTopicLessonId || 0)}"]`
          )
          : null
      );
    if (!input) {
      return;
    }

    // Keep edit field strictly inside the existing lesson block so row heights stay stable.
    input.style.height = "100%";
    input.style.minHeight = "0";
    input.style.maxHeight = "100%";
  }

  startInlineWeekBlockTopicEdit(lessonId) {
    const lesson = this.store.getLessonById(lessonId);
    if (!lesson) {
      return false;
    }
    const block = this.store.getLessonBlock(lesson.id);
    if (block.length === 0) {
      return false;
    }
    const allCanceled = block.every((entry) => entry.canceled);
    if (allCanceled || lesson.noLesson) {
      return false;
    }
    const isEntfall = block.some((entry) => entry.isEntfall);
    const isWritten = block.some((entry) => entry.isWrittenExam);
    if (isEntfall || isWritten) {
      return false;
    }
    const firstTopic = block
      .map((entry) => String(entry.topic || "").trim())
      .find(Boolean) || "";
    this.inlineTopicLessonId = lesson.id;
    this.inlineTopicDraft = firstTopic;
    this.selectedLessonId = lesson.id;
    this.renderWeekTable();
    this.renderLessonSection();
    requestAnimationFrame(() => {
      const currentLessonId = Number(this.inlineTopicLessonId || 0);
      if (!currentLessonId || currentLessonId !== lesson.id || !this.refs.weekTable) {
        return;
      }
      const inlineTopicInput = this.refs.weekTable.querySelector(
        `.week-inline-topic-input[data-lesson-id="${currentLessonId}"]`
      );
      if (!inlineTopicInput) {
        return;
      }
      this.syncInlineWeekBlockTopicInputSize(inlineTopicInput);
      inlineTopicInput.focus();
      inlineTopicInput.select();
    });
    return true;
  }

  finishInlineWeekBlockTopicEdit(saveChanges = true, nextLessonId = null) {
    const activeElement = document.activeElement;
    if (activeElement && typeof activeElement.blur === "function") {
      activeElement.blur();
    }
    const lessonId = Number(this.inlineTopicLessonId || 0);
    const nextInlineLessonId = Number(nextLessonId || 0);
    if (!lessonId) {
      this.resetInlineWeekBlockTopicEdit();
      if (nextInlineLessonId) {
        this.startInlineWeekBlockTopicEdit(nextInlineLessonId);
      }
      return;
    }
    const nextTopic = String(this.inlineTopicDraft || "").trim();
    this.resetInlineWeekBlockTopicEdit();

    if (!saveChanges) {
      this.selectedLessonId = nextInlineLessonId || null;
      this.renderWeekTable();
      this.renderLessonSection();
      if (nextInlineLessonId) {
        this.startInlineWeekBlockTopicEdit(nextInlineLessonId);
      }
      return;
    }

    const lesson = this.store.getLessonById(lessonId);
    const block = lesson ? this.store.getLessonBlock(lesson.id) : [];
    const blocked = !lesson
      || block.length === 0
      || block.every((entry) => entry.canceled)
      || lesson.noLesson
      || block.some((entry) => entry.isEntfall || entry.isWrittenExam);
    if (!blocked) {
      this.store.updateLessonBlock(lessonId, nextTopic, false, false);
    }
    this.selectedLessonId = nextInlineLessonId || null;
    this.renderWeekSection();
    this.renderLessonSection();
    this.renderCourseTimeline();
    if (nextInlineLessonId) {
      this.startInlineWeekBlockTopicEdit(nextInlineLessonId);
    }
  }

  promptEditWeekBlockTopic(lessonId) {
    return this.startInlineWeekBlockTopicEdit(lessonId);
  }

  openWeekBlockContextMenu(lessonId, clientX, clientY, source = "week") {
    const lesson = this.store.getLessonById(lessonId);
    if (!lesson) {
      return;
    }
    const block = this.store.getLessonBlock(lesson.id);
    if (block.length === 0) {
      return;
    }
    const allCanceled = block.every((entry) => entry.canceled);
    if (allCanceled) {
      return;
    }
    const isNoLesson = Boolean(lesson.noLesson);
    const isEntfall = block.some((entry) => entry.isEntfall);
    const isWritten = block.some((entry) => entry.isWrittenExam);
    const editable = !allCanceled && !isNoLesson;
    const isTopicEditable = editable && !(isEntfall || isWritten);
    const slotId = lesson.slotId ? Number(lesson.slotId) : null;
    const courseId = lesson.courseId ? Number(lesson.courseId) : null;
    const startLessonId = lesson.id ? Number(lesson.id) : null;
    const clickedDate = lesson.lessonDate || null;
    const distinctTopics = [...new Set(
      block
        .map((entry) => String(entry.topic || "").trim())
        .filter(Boolean)
    )];
    let rawTopic = "";
    if (distinctTopics.length === 1) {
      rawTopic = distinctTopics[0];
    }
    if (isEntfall || isWritten) {
      rawTopic = overrideTopicForFlags(rawTopic, isEntfall, isWritten);
    }
    const hasTopic = source === "week"
      ? distinctTopics.length > 0 || isEntfall || isWritten
      : Boolean(rawTopic) || isEntfall || isWritten;
    this.readClipboardText().then((clipboardText) => {
      const canPaste = isTopicEditable && Boolean(String(clipboardText || "").trim());
      this.showContextMenu(
        [
          {
            label: "Kopieren",
            disabled: !Boolean(rawTopic),
            handler: async () => {
              await this.writeClipboardText(rawTopic);
            }
          },
          {
            label: "Einfügen",
            disabled: !canPaste,
            handler: async () => {
              const text = String(await this.readClipboardText()).trim();
              if (!text) {
                return;
              }
              this.store.updateLessonBlock(lesson.id, text, isEntfall, isWritten);
              this.renderWeekSection();
              this.renderLessonSection();
              this.renderCourseTimeline();
            }
          },
          {
            label: "Serie anpassen",
            separatorBefore: true,
            disabled: !slotId,
            handler: async () => {
              const slot = this.store.getSlot(slotId);
              if (!slot) {
                return;
              }
              await this.openSlotDialogForEdit(slot, clickedDate);
            }
          },
          {
            label: isWritten ? "Schriftliche Arbeit aufheben" : "Schriftliche Arbeit",
            disabled: !editable,
            handler: async () => {
              if (isWritten) {
                this.store.updateLessonBlock(lesson.id, "", false, false);
              } else {
                this.store.updateLessonBlock(lesson.id, WRITTEN_EXAM_TOPIC, false, true);
              }
              this.renderWeekSection();
              this.renderLessonSection();
              this.renderCourseTimeline();
            }
          },
          {
            label: isEntfall ? "Entfall aufheben" : "Entfall",
            disabled: !editable,
            handler: async () => {
              if (isEntfall) {
                this.store.updateLessonBlock(lesson.id, "", false, false);
              } else {
                this.openEntfallDialog(lesson.id);
                return;
              }
              this.renderWeekSection();
              this.renderLessonSection();
              this.renderCourseTimeline();
            }
          },
          {
            label: "Planung in Zukunft verschieben",
            disabled: !editable || !hasTopic || !courseId || !startLessonId,
            handler: async () => {
              const year = this.activeSchoolYear;
              if (!year || !courseId || !startLessonId) {
                return;
              }
              const result = this.store.shiftCourseTopicsForward(year.id, courseId, startLessonId);
              if (!result.success && result.message) {
                await this.showInfoMessage(result.message);
              }
              this.renderWeekSection();
              this.renderLessonSection();
              this.renderCourseTimeline();
            }
          },
          {
            label: "Planung in Vergangenheit verschieben",
            disabled: !editable || !hasTopic || !courseId || !startLessonId,
            handler: async () => {
              const year = this.activeSchoolYear;
              if (!year || !courseId || !startLessonId) {
                return;
              }
              const result = this.store.shiftCourseTopicsBackward(year.id, courseId, startLessonId);
              if (!result.success && result.message) {
                await this.showInfoMessage(result.message);
              }
              this.renderWeekSection();
              this.renderLessonSection();
              this.renderCourseTimeline();
            }
          }
        ],
        clientX,
        clientY
      );
    });
  }

  renderAll() {
    this.hideContextMenu();
    this.renderSchoolYearSelect();
    this.updateAccessLock();
    this.renderViewState();
    this.renderSettingsTabs();
    this.renderSidebarCourseList();
    this.renderCourseSection();
    this.renderSlotSection();
    this.renderDisplaySection();
    this.renderDayOffSection();
    this.renderBackupSection();
    this.renderDatabaseSection();
    this.renderWeekSection();
    this.renderLessonSection();
    this.renderCourseTimeline();
    this.syncSlotEditTools();
    this.updateWeekNavigation();
    this.syncAllNumberSteppers();
  }

  renderViewState() {
    const isWeek = this.currentView === "week";
    const isCourse = this.currentView === "course";
    const isSettings = this.currentView === "settings";
    const showMainStack = isWeek || isCourse;
    document.body.dataset.view = this.currentView;

    this.refs.viewWeek.hidden = !isWeek;
    this.refs.viewCourse.hidden = !isCourse;
    this.refs.viewSettings.hidden = !isSettings;
    if (this.refs.stackGlass) {
      this.refs.stackGlass.hidden = !showMainStack;
      this.refs.stackGlass.style.display = showMainStack ? "grid" : "none";
    }
    if (this.refs.settingsShell) {
      this.refs.settingsShell.hidden = !isSettings;
      this.refs.settingsShell.style.display = isSettings ? "grid" : "none";
    }
    this.refs.headerGlass.style.display = (!this.locked && isWeek) ? "flex" : "none";
    this.refs.viewSettingsBtn.hidden = false;
    this.refs.viewSettingsBtn.disabled = this.locked;
    if (this.refs.mainPane) {
      this.refs.mainPane.style.gridTemplateRows = isSettings ? "1fr" : "auto 1fr";
    }

    this.refs.viewWeekBtn.classList.toggle("active", isWeek);
    this.refs.viewSettingsBtn.classList.toggle("active", isSettings);

    if (isWeek) {
      requestAnimationFrame(() => this.syncWeekLayoutScale());
    } else if (this.refs.headerGlass && this.refs.weekTable) {
      this.refs.headerGlass.style.setProperty("--week-header-scale", "1");
      this.refs.weekTable.style.setProperty("--week-table-scale", "1");
    }
  }

  renderSettingsTabs() {
    const fallbackTab = "dayoff";
    let tabName = this.refs.settingsPanels[this.activeSettingsTab]
      ? this.activeSettingsTab
      : fallbackTab;
    if (this.locked) {
      tabName = (this.lockReason === "databaseRequired" || this.lockReason === "backupDirRequired")
        ? "database"
        : "dayoff";
    }
    this.activeSettingsTab = tabName;

    this.refs.settingsTabs.forEach((button) => {
      const isActive = button.dataset.tab === tabName;
      const isLockedHidden = this.locked
        && this.lockReason === "holidaysRequired"
        && button.dataset.tab !== "dayoff";
      const isLockedDisabled = isLockedHidden || (
        this.locked
        && (this.lockReason === "databaseRequired" || this.lockReason === "backupDirRequired")
        && button.dataset.tab !== "database"
      );
      button.hidden = isLockedHidden;
      button.disabled = isLockedDisabled;
      button.classList.toggle("active", isActive);
      button.setAttribute("aria-selected", isActive ? "true" : "false");
      button.setAttribute("tabindex", isActive ? "0" : "-1");
    });

    Object.entries(this.refs.settingsPanels).forEach(([name, panel]) => {
      const isActive = name === tabName;
      panel.hidden = !isActive;
      panel.classList.toggle("active", isActive);
    });
    this.updateSettingsActionButtons();
  }

  renderSchoolYearSelect() {
    const years = this.store.listSchoolYears();
    const active = this.activeSchoolYear;
    this.refs.schoolYearSelect.innerHTML = "";

    for (const year of years) {
      const option = document.createElement("option");
      option.value = String(year.id);
      option.textContent = `${year.name} (${formatDate(year.startDate)} - ${formatDate(year.endDate)})`;
      if (active && year.id === active.id) {
        option.selected = true;
      }
      this.refs.schoolYearSelect.append(option);
    }

    this.weekStartIso = this._clampWeekStart(this.weekStartIso);
    this.refs.weekDate.value = this.weekStartIso;
    this.refs.hoursPerDay.value = String(this.store.getHoursPerDay());
    this.refs.kwLabel.textContent = `KW ${String(this._currentIsoWeek()).padStart(2, "0")}`;
  }

  renderSidebarCourseList() {
    const year = this.activeSchoolYear;
    const allCourses = year ? this.store.listCourses(year.id) : [];
    const showHidden = Boolean(
      this.store.getSetting("showHiddenSidebarCourses", SHOW_HIDDEN_SIDEBAR_COURSES_DEFAULT)
    );
    const courses = showHidden
      ? allCourses
      : allCourses.filter((course) => !course.hiddenInSidebar);
    const selectableCourses = courses.filter((course) => !course.noLesson);

    if (!selectableCourses.some((course) => course.id === this.selectedCourseId)) {
      this.selectedCourseId = selectableCourses.length > 0 ? selectableCourses[0].id : null;
    }

    this.refs.sidebarCourseList.innerHTML = "";
    this.refs.sidebarCourseList.classList.toggle(
      "empty-pulse",
      !this.locked && selectableCourses.length === 0
    );
    for (const course of courses) {
      const li = document.createElement("li");
      li.dataset.courseId = String(course.id);
      li.dataset.noLesson = course.noLesson ? "1" : "0";
      li.draggable = !this.locked && !course.noLesson;
      const button = document.createElement("button");
      button.type = "button";
      button.dataset.courseId = String(course.id);
      button.dataset.noLesson = course.noLesson ? "1" : "0";
      button.disabled = this.locked || Boolean(course.noLesson);
      if (course.noLesson) {
        button.classList.add("disabled-course");
        button.title = "Unterrichtsfrei-Kurs · Rechtsklick: Bearbeiten";
        li.title = "Rechtsklick: Bearbeiten";
      } else {
        button.title = "Linksklick: Kursansicht / Rechtsklick: Kurs anpassen / Ziehen: Reihenfolge in Randleiste";
      }
      if (this.currentView === "course" && course.id === this.selectedCourseId) {
        button.classList.add("active");
      }
      const baseColor = normalizeCourseColor(course.color, Boolean(course.noLesson));
      button.style.background = colorToRgba(course.noLesson ? NO_LESSON_COLOR : lightenHex(baseColor, 0.06), 0.9);
      button.style.color = "#000000";
      button.style.borderColor = colorToRgba(lightenHex(baseColor, 0.3), 0.6);
      const name = document.createElement("span");
      name.className = "course-name";
      name.textContent = course.name;
      button.append(name);
      li.append(button);
      this.refs.sidebarCourseList.append(li);
    }

    const addItem = document.createElement("li");
    addItem.dataset.addItem = "1";
    const addButton = document.createElement("button");
    addButton.type = "button";
    addButton.className = "sidebar-add-btn";
    addButton.dataset.addCourse = "1";
    addButton.setAttribute("aria-label", "Neuen Kurs anlegen");
    const plusIcon = document.createElement("span");
    plusIcon.className = "sidebar-add-plus";
    plusIcon.setAttribute("aria-hidden", "true");
    addButton.append(plusIcon);
    addButton.title = "Neuen Kurs anlegen";
    addButton.disabled = this.locked;
    addItem.append(addButton);
    this.refs.sidebarCourseList.append(addItem);
  }

  renderCourseSection() {
    const year = this.activeSchoolYear;
    const courses = year ? this.store.listCourses(year.id) : [];
    this.refs.courseSettingsAdd.disabled = this.locked || !year;

    this.refs.courseList.innerHTML = "";
    for (const course of courses) {
      const li = document.createElement("li");
      li.dataset.courseId = String(course.id);
      const main = document.createElement("div");
      main.className = "main";
      const name = document.createElement("div");
      const dot = document.createElement("span");
      dot.className = "color-dot";
      dot.style.display = "inline-block";
      dot.style.marginRight = "8px";
      dot.style.background = normalizeCourseColor(course.color, Boolean(course.noLesson));
      name.append(dot, document.createTextNode(course.name));
      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = course.noLesson ? "Unterrichtsfrei-Kurs" : "Regulärer Kurs";
      main.append(name, meta);

      const actions = document.createElement("div");
      actions.className = "item-actions";
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "ghost";
      editBtn.dataset.action = "edit";
      editBtn.dataset.id = String(course.id);
      editBtn.textContent = "✎ Bearbeiten";
      editBtn.disabled = this.locked;

      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "delete";
      deleteBtn.dataset.action = "delete";
      deleteBtn.dataset.id = String(course.id);
      deleteBtn.textContent = "Löschen";
      deleteBtn.disabled = this.locked;

      actions.append(editBtn, deleteBtn);

      li.append(main, actions);
      this.refs.courseList.append(li);
    }
  }

  renderSlotSection() {
    this.renderSlotCourseSelect();
    this.renderSlotList();
  }

  renderSlotCourseSelect() {
    const year = this.activeSchoolYear;
    const courses = year ? this.store.listCourses(year.id) : [];
    const previous = this.refs.slotCourse.value;
    this.refs.slotCourse.innerHTML = "";

    for (const course of courses) {
      const option = document.createElement("option");
      option.value = String(course.id);
      option.textContent = course.name;
      const courseColor = normalizeCourseColor(course.color, Boolean(course.noLesson));
      option.style.color = courseColor;
      option.style.backgroundColor = "var(--dropdown-bg)";
      option.dataset.courseColor = courseColor;
      this.refs.slotCourse.append(option);
    }

    if (courses.length === 0) {
      const option = document.createElement("option");
      option.value = "";
      option.textContent = "Erst Kurs anlegen";
      option.style.backgroundColor = "var(--dropdown-bg)";
      this.refs.slotCourse.append(option);
      this.refs.slotCourse.disabled = true;
      this.refs.slotCourse.style.color = "";
      return;
    }

    this.refs.slotCourse.disabled = false;
    this.refs.slotCourse.value = courses.some((course) => String(course.id) === previous)
      ? previous
      : String(courses[0].id);
    this.syncSlotFormCourseColor();
  }

  renderSlotList() {
    const year = this.activeSchoolYear;
    const slots = year ? this.store.listSlotsForYear(year.id) : [];
    const coursesById = new Map((year ? this.store.listCourses(year.id) : []).map((item) => [item.id, item]));
    this.refs.slotList.innerHTML = "";

    for (const slot of slots) {
      const course = coursesById.get(slot.courseId);
      const li = document.createElement("li");
      const main = document.createElement("div");
      main.className = "main";
      const name = document.createElement("div");
      const dayName = DAYS_SHORT[slot.dayOfWeek - 1] || `Tag ${slot.dayOfWeek}`;
      const oneTime = Number(slot.weekParity) === 0 && slot.startDate && slot.endDate && slot.startDate === slot.endDate;
      const parityText = oneTime
        ? "einmalig"
        : Number(slot.weekParity) === 1
          ? "ung. KW"
          : Number(slot.weekParity) === 2
            ? "ger. KW"
            : "jede KW";
      name.textContent = `${dayName} ${slot.startHour}.-${slot.startHour + slot.duration - 1}. Std. · ${course ? course.name : "?"}`;
      const meta = document.createElement("div");
      meta.className = "meta";
      const rangeText = slot.startDate || slot.endDate
        ? slot.startDate && slot.endDate && slot.startDate === slot.endDate
          ? formatDate(slot.startDate)
          : `${slot.startDate ? formatDate(slot.startDate) : "Start Schuljahr"} - ${slot.endDate ? formatDate(slot.endDate) : "Ende Schuljahr"}`
        : "Ganzes Schuljahr";
      meta.textContent = `${rangeText} · ${parityText}`;
      main.append(name, meta);

      const actions = document.createElement("div");
      actions.className = "item-actions";
      actions.innerHTML = `
        <button type="button" class="ghost" data-action="edit" data-id="${slot.id}">Bearbeiten</button>
        <button type="button" class="delete" data-action="delete" data-id="${slot.id}">Löschen</button>
      `;
      li.append(main, actions);
      this.refs.slotList.append(li);
    }
  }

  renderDisplaySection() {
    const draftHours = clamp(
      Number((this.settingsDraft && this.settingsDraft.hoursPerDay) || this.store.getHoursPerDay()),
      1,
      12
    );
    const draftShowHidden = Boolean(
      (this.settingsDraft && this.settingsDraft.showHiddenSidebarCourses)
      || false
    );
    if (this.refs.hoursPerDay) {
      this.refs.hoursPerDay.value = String(draftHours);
    }
    if (this.refs.showHiddenSidebarCourses) {
      this.refs.showHiddenSidebarCourses.checked = draftShowHidden;
    }
    if (this.refs.appVersion) {
      this.refs.appVersion.textContent = this.appVersion || "unbekannt";
    }
    this.syncAllNumberSteppers();
    this.updateSettingsActionButtons();
  }

  renderDayOffSection() {
    const year = this.activeSchoolYear;
    const canEdit = Boolean(year);
    if (this.refs.freeRangeAdd) {
      this.refs.freeRangeAdd.disabled = !canEdit;
    }
    this.renderRequiredHolidayHint();
    this.renderFreeRangeList();
    this.renderSpecialDayList();
    this.updateSettingsActionButtons();
  }

  getMissingRequiredHolidays(schoolYearId) {
    const ranges = this.store.listFreeRanges(schoolYearId);
    return computeRequiredHolidayMissingLabels(ranges);
  }

  getMissingRequiredHolidayDetails(schoolYearId) {
    const ranges = this.store.listFreeRanges(schoolYearId);
    return computeRequiredHolidayMissingDetails(ranges);
  }

  renderRequiredHolidayHint() {
    if (!this.refs.dayoffRequiredHint || !this.refs.dayoffRequiredMissing) {
      return;
    }
    const hintTitle = this.refs.dayoffRequiredHint.querySelector(".required-hint-title");
    const year = this.activeSchoolYear;
    if (!year) {
      this.refs.dayoffRequiredHint.hidden = true;
      this.refs.dayoffRequiredHint.style.display = "none";
      this.refs.dayoffRequiredMissing.textContent = "";
      if (hintTitle) {
        hintTitle.textContent = "Pflicht-Ferien sind noch unvollständig.";
      }
      return;
    }
    const missing = this.getMissingRequiredHolidays(year.id);
    const isComplete = this.store.requiredHolidaysComplete(year.id);
    const details = this.getMissingRequiredHolidayDetails(year.id);
    const shouldShowHint = !isComplete && details.length > 0 && missing.length > 0;
    if (!shouldShowHint) {
      this.refs.dayoffRequiredHint.hidden = true;
      this.refs.dayoffRequiredHint.style.display = "none";
      this.refs.dayoffRequiredMissing.textContent = "";
      if (hintTitle) {
        hintTitle.textContent = "Pflicht-Ferien sind noch unvollständig.";
      }
      return;
    }
    this.refs.dayoffRequiredHint.hidden = false;
    this.refs.dayoffRequiredHint.style.display = "grid";
    if (hintTitle) {
      hintTitle.textContent = "Pflicht-Ferien sind noch unvollständig.";
    }
    this.refs.dayoffRequiredMissing.textContent =
      `Fehlend: ${details.join("; ")}.`;
  }

  renderFreeRangeList() {
    const year = this.activeSchoolYear;
    const ranges = year ? this.store.listFreeRanges(year.id) : [];
    const canEdit = Boolean(year);
    this.refs.freeRangeList.innerHTML = "";

    const requiredLookup = new Set(REQUIRED_HOLIDAYS.map((label) => label.toLowerCase()));
    const byLabel = new Map();
    for (const item of ranges) {
      const normalized = String(item.label || "").trim().toLowerCase();
      if (!byLabel.has(normalized)) {
        byLabel.set(normalized, []);
      }
      byLabel.get(normalized).push(item);
    }
    const displayRanges = [];
    const usedRows = new Set();
    const requiredDisplayOrder = requiredHolidayRowSpecs();

    for (const entry of requiredDisplayOrder) {
      const existingRows = byLabel.get(entry.label.toLowerCase()) || [];
      const sortedRows = [...existingRows].sort((a, b) => {
        const aKey = String(a.startDate || a.endDate || "");
        const bKey = String(b.startDate || b.endDate || "");
        return aKey.localeCompare(bKey);
      });
      const row = sortedRows[entry.occurrence] || null;
      if (row) {
        displayRanges.push({ ...row, __occurrence: entry.occurrence });
        usedRows.add(row);
      } else {
        displayRanges.push({
          id: null,
          label: entry.label,
          __occurrence: entry.occurrence,
          startDate: "",
          endDate: ""
        });
      }
    }

    for (const range of ranges) {
      if (usedRows.has(range)) {
        continue;
      }
      const normalized = String(range.label || "").trim().toLowerCase();
      if (requiredLookup.has(normalized)) {
        continue;
      }
      displayRanges.push(range);
    }

    for (const range of displayRanges) {
      const li = document.createElement("li");
      li.dataset.clickable = canEdit ? "1" : "0";
      if (canEdit) {
        li.title = "Linksklick: Daten bearbeiten";
      }
      if (range.id) {
        li.dataset.id = String(range.id);
      } else {
        li.dataset.label = String(range.label || "");
      }
      if (Number.isInteger(range.__occurrence)) {
        li.dataset.occurrence = String(range.__occurrence);
      }
      const main = document.createElement("div");
      main.className = "main";
      const title = document.createElement("div");
      title.textContent = range.label;
      const meta = document.createElement("div");
      meta.className = "meta";
      const isSummer = String(range.label || "").trim().toLowerCase() === "sommerferien";
      const isTopSummer = isSummer && Number(range.__occurrence) === 0;
      const isBottomSummer = isSummer && Number(range.__occurrence) === 1;
      const wrapsYear = Boolean(range.startDate && range.endDate && range.startDate > range.endDate);
      if (isTopSummer) {
        if (range.startDate && range.endDate) {
          meta.textContent = `${formatDate(range.startDate)} - ${formatDate(range.endDate)}`;
        } else {
          meta.textContent = range.endDate ? `bis ${formatDate(range.endDate)}` : "Nicht gesetzt";
        }
      } else if (isBottomSummer) {
        if (range.startDate && range.endDate) {
          meta.textContent = `${formatDate(range.startDate)} - ${formatDate(range.endDate)}`;
        } else if (range.startDate) {
          meta.textContent = `ab ${formatDate(range.startDate)}`;
        } else if (range.endDate) {
          meta.textContent = `bis ${formatDate(range.endDate)}`;
        } else {
          meta.textContent = "Nicht gesetzt";
        }
      } else if (!range.startDate && !range.endDate) {
        meta.textContent = "Nicht gesetzt";
      } else if (range.startDate && !range.endDate) {
        meta.textContent = `ab ${formatDate(range.startDate)}`;
      } else if (!range.startDate && range.endDate) {
        meta.textContent = `bis ${formatDate(range.endDate)}`;
      } else {
        meta.textContent = wrapsYear
          ? `${formatDate(range.startDate)} - ${formatDate(range.endDate)} (überjährig)`
          : `${formatDate(range.startDate)} - ${formatDate(range.endDate)}`;
      }
      main.append(title, meta);
      li.append(main);
      this.refs.freeRangeList.append(li);
    }
  }

  renderSpecialDayList() {
    const canEdit = Boolean(this.activeSchoolYear);
    const rows = this.store.listSpecialDays();
    this.refs.specialDayList.innerHTML = "";

    for (const day of rows) {
      const li = document.createElement("li");
      li.dataset.clickable = canEdit ? "1" : "0";
      if (canEdit) {
        li.title = "Linksklick: Daten bearbeiten";
      }
      li.dataset.specialDayId = String(day.id);
      const main = document.createElement("div");
      main.className = "main";
      const name = document.createElement("div");
      name.textContent = day.name;
      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = formatDate(day.dayDate);
      main.append(name, meta);
      li.append(main);
      this.refs.specialDayList.append(li);
    }

    const addLi = document.createElement("li");
    addLi.dataset.addItem = "1";
    const addBtn = document.createElement("button");
    addBtn.type = "button";
    addBtn.className = "sidebar-add-btn";
    addBtn.dataset.action = "add";
    addBtn.disabled = !canEdit;
    addBtn.setAttribute("aria-label", "Unterrichtsfreien Tag hinzufügen");
    addBtn.title = "Unterrichtsfreien Tag hinzufügen";
    const plusIcon = document.createElement("span");
    plusIcon.className = "sidebar-add-plus";
    plusIcon.setAttribute("aria-hidden", "true");
    addBtn.append(plusIcon);
    addLi.append(addBtn);
    this.refs.specialDayList.append(addLi);
  }

  renderWeekSection() {
    this.refs.weekDate.value = this.weekStartIso;
    this.refs.kwLabel.textContent = `KW ${String(this._currentIsoWeek()).padStart(2, "0")}`;
    this.updateWeekNavigation();
    if (this.refs.weekCalendarDialog && this.refs.weekCalendarDialog.open) {
      this.weekCalendarMonthIso = this._clampWeekCalendarMonth(this.weekCalendarMonthIso || this.weekStartIso);
      this.syncWeekCalendarMonthOptions();
      this.renderWeekCalendarGrid();
      this.positionWeekCalendarDialog();
    }
    this.renderWeekTable();
    this.syncWeekLayoutScale();
  }

  syncWeekLayoutScale() {
    const table = this.refs.weekTable;
    const header = this.refs.headerGlass;
    const weekView = this.refs.viewWeek;
    const tablePanel = table && table.closest ? table.closest(".table-panel") : null;
    if (!table || !header || !tablePanel) {
      return;
    }

    if (this.currentView !== "week" || this.locked) {
      header.style.setProperty("--week-header-scale", "1");
      table.style.setProperty("--week-table-scale", "1");
      return;
    }

    if (header.clientWidth <= 0 || tablePanel.clientWidth <= 0 || tablePanel.clientHeight <= 0) {
      return;
    }

    const minHeaderScale = 0.38;
    const minTableScale = 0.2;
    const precision = 0.005;
    let headerScale = 1;
    let tableScale = 1;

    const applyHeaderScale = () => {
      header.style.setProperty("--week-header-scale", headerScale.toFixed(2));
    };
    const applyTableScale = () => {
      table.style.setProperty("--week-table-scale", tableScale.toFixed(2));
    };
    const headerFits = () => header.scrollWidth <= header.clientWidth + 0.5;
    const tableFitsWidth = () => table.scrollWidth <= tablePanel.clientWidth + 0.5;
    const weekFitsHeight = () => !weekView || weekView.scrollHeight <= weekView.clientHeight + 0.5;
    const tableFitsHeight = () => {
      const tbody = table.tBodies[0];
      if (!tbody || tbody.rows.length === 0) {
        return true;
      }
      const lastRow = tbody.rows[tbody.rows.length - 1];
      const panelRect = tablePanel.getBoundingClientRect();
      const tableRect = table.getBoundingClientRect();
      const lastRowRect = lastRow.getBoundingClientRect();
      return tablePanel.scrollHeight <= tablePanel.clientHeight + 0.5
        && tableRect.bottom <= panelRect.bottom + 0.5
        && lastRowRect.bottom <= panelRect.bottom + 0.5;
    };
    const weekFitsAll = () => weekFitsHeight() && tableFitsHeight();
    const syncForCurrentScales = () => {
      applyHeaderScale();
      applyTableScale();
      this.syncWeekTableRowHeights();
    };
    const canFit = (tableCandidate, headerCandidate) => {
      tableScale = clamp(Number(tableCandidate), minTableScale, 1);
      headerScale = clamp(Number(headerCandidate), minHeaderScale, 1);
      syncForCurrentScales();
      return headerFits() && tableFitsWidth() && weekFitsAll();
    };

    let bestTableScale = minTableScale;
    if (canFit(bestTableScale, minHeaderScale)) {
      let low = bestTableScale;
      let high = 1;
      while ((high - low) > precision) {
        const mid = (low + high) / 2;
        if (canFit(mid, minHeaderScale)) {
          bestTableScale = mid;
          low = mid;
        } else {
          high = mid;
        }
      }
    } else {
      tableScale = bestTableScale;
      headerScale = minHeaderScale;
      syncForCurrentScales();
    }

    tableScale = bestTableScale;
    let bestHeaderScale = minHeaderScale;
    if (canFit(tableScale, bestHeaderScale)) {
      let low = bestHeaderScale;
      let high = 1;
      while ((high - low) > precision) {
        const mid = (low + high) / 2;
        if (canFit(tableScale, mid)) {
          bestHeaderScale = mid;
          low = mid;
        } else {
          high = mid;
        }
      }
    }

    tableScale = Number(bestTableScale.toFixed(2));
    headerScale = Number(bestHeaderScale.toFixed(2));
    syncForCurrentScales();
    this.syncInlineWeekBlockTopicInputSize();
  }

  syncWeekTableRowHeights() {
    const table = this.refs.weekTable;
    const tablePanel = table && table.closest ? table.closest(".table-panel") : null;
    if (!table) {
      return;
    }

    const tbody = table.tBodies[0];
    const rowCount = tbody ? tbody.rows.length : 0;
    if (!tbody || rowCount === 0) {
      table.style.removeProperty("--week-row-height");
      table.style.setProperty("--week-block-font-scale", "1");
      return;
    }

    const tableHeight = tablePanel ? tablePanel.clientHeight : table.clientHeight;
    const headerHeight = table.tHead ? table.tHead.getBoundingClientRect().height : 0;
    const availableBodyHeight = Math.max(0, tableHeight - headerHeight);
    let rowHeight = availableBodyHeight / rowCount;
    if (!Number.isFinite(rowHeight) || rowHeight <= 0) {
      table.style.removeProperty("--week-row-height");
      return;
    }

    // Prevent cumulative rounding/content pressure from creating vertical overflow.
    rowHeight = Math.max(0, rowHeight - 0.25);
    const applyUniformRowHeight = () => {
      const px = `${rowHeight}px`;
      table.style.setProperty("--week-row-height", px);
      for (const row of tbody.rows) {
        row.style.height = px;
        row.style.minHeight = px;
        row.style.maxHeight = px;
      }
      const spanCells = tbody.querySelectorAll("td[rowspan]");
      for (const cell of spanCells) {
        const span = Math.max(1, Number(cell.getAttribute("rowspan")) || 1);
        const spanPx = `${Math.max(0, rowHeight * span)}px`;
        cell.style.height = spanPx;
        cell.style.minHeight = spanPx;
        cell.style.maxHeight = spanPx;
      }
    };

    applyUniformRowHeight();

    const tightenRowHeight = (maxPasses = 8) => {
      for (let pass = 0; pass < maxPasses; pass += 1) {
        const panelRect = tablePanel ? tablePanel.getBoundingClientRect() : null;
        const tableRect = table.getBoundingClientRect();
        const tbodyRows = tbody.rows;
        const lastRow = tbodyRows.length > 0 ? tbodyRows[tbodyRows.length - 1] : null;
        const lastRowRect = lastRow ? lastRow.getBoundingClientRect() : null;
        const overflowByTable = table.scrollHeight - table.clientHeight;
        const overflowByPanelScroll = tablePanel
          ? (tablePanel.scrollHeight - tablePanel.clientHeight)
          : 0;
        const overflowByTableBottom = panelRect
          ? (tableRect.bottom - panelRect.bottom)
          : 0;
        const overflowByLastRowBottom = (panelRect && lastRowRect)
          ? (lastRowRect.bottom - panelRect.bottom)
          : 0;
        const overflow = Math.max(
          0,
          overflowByTable,
          overflowByPanelScroll,
          overflowByTableBottom,
          overflowByLastRowBottom
        );
        if (overflow <= 0.5) {
          return;
        }
        rowHeight = Math.max(0, rowHeight - (overflow / rowCount) - 0.05);
        applyUniformRowHeight();
        if (rowHeight <= 0) {
          return;
        }
      }
    };

    tightenRowHeight(8);

    this.syncWeekTileTextScale();
    tightenRowHeight(6);
  }

  syncWeekTileTextScale() {
    const table = this.refs.weekTable;
    if (!table) {
      return;
    }

    const blocks = [...table.querySelectorAll("button.lesson-block")];
    if (blocks.length === 0) {
      table.style.setProperty("--week-block-font-scale", "1");
      return;
    }

    const fitsAll = () => {
      for (const block of blocks) {
        if (block.scrollHeight - block.clientHeight > 1.5) {
          return false;
        }
        if (block.scrollWidth - block.clientWidth > 1.5) {
          return false;
        }
      }
      return true;
    };

    const minScale = 0.25;
    const step = 0.01;
    let scale = 1;
    table.style.setProperty("--week-block-font-scale", scale.toFixed(2));
    if (fitsAll()) {
      return;
    }

    while (scale > minScale) {
      scale = Math.max(minScale, Number((scale - step).toFixed(2)));
      table.style.setProperty("--week-block-font-scale", scale.toFixed(2));
      if (fitsAll()) {
        return;
      }
    }
  }

  renderWeekTable() {
    const year = this.activeSchoolYear;
    this.refs.weekTable.innerHTML = "";
    if (!year) {
      this.refs.weekTable.style.removeProperty("--week-row-height");
      this.refs.weekTable.style.setProperty("--week-block-font-scale", "1");
      return;
    }

    this.store.generateLessonsForYear(year.id);
    const hoursPerDay = this.store.getHoursPerDay();
    this.refs.weekTable.style.setProperty("--hours-per-day", String(Math.max(1, hoursPerDay)));
    const days = [0, 1, 2, 3, 4].map((offset) => addDays(this.weekStartIso, offset));
    const lessons = this.store.listLessonsForWeek(year.id, days[0], days[4]);
    const lessonsByDayHour = new Map();
    for (const lesson of lessons) {
      const key = `${lesson.lessonDate}|${lesson.hour}`;
      if (!lessonsByDayHour.has(key)) {
        lessonsByDayHour.set(key, []);
      }
      lessonsByDayHour.get(key).push(lesson);
    }

    const ranges = this.store.listFreeRanges(year.id);
    const specialByDate = new Map(this.store.listSpecialDays().map((item) => [item.dayDate, item.name]));
    const dayOffByIso = new Map();
    for (const dayIso of days) {
      let dayOff = null;
      for (const range of ranges) {
        if (isoInDateRange(dayIso, range.startDate, range.endDate)) {
          dayOff = {
            label: String(range.label || "Unterrichtsfrei"),
            kind: "holiday"
          };
          break;
        }
      }
      if (!dayOff) {
        const specialLabel = specialByDate.get(dayIso);
        if (specialLabel) {
          dayOff = {
            label: String(specialLabel || "Unterrichtsfrei"),
            kind: "special"
          };
        }
      }
      if (dayOff) {
        dayOffByIso.set(dayIso, dayOff);
      }
    }

    const buildBlockMeta = (blockLessons) => {
      const topLesson = blockLessons[0];
      const allCanceled = blockLessons.every((entry) => entry.canceled);
      const anyCanceled = blockLessons.some((entry) => entry.canceled);
      const partialCanceled = anyCanceled && !allCanceled;
      const isNoLesson = Boolean(topLesson.noLesson);
      const isEntfall = blockLessons.some((entry) => entry.isEntfall);
      const isWritten = blockLessons.some((entry) => entry.isWrittenExam);
      const topics = new Set(
        blockLessons
          .map((entry) => String(entry.topic || "").trim())
          .filter(Boolean)
      );

      let displayTopic = "";
      let rawTopic = "";
      if (allCanceled && topLesson.cancelLabel) {
        displayTopic = topLesson.cancelLabel;
      } else if (isNoLesson) {
        displayTopic = topLesson.courseName || "";
      } else if (topics.size === 1) {
        rawTopic = [...topics][0];
        displayTopic = rawTopic;
      } else if (topics.size > 1) {
        displayTopic = "Mehrere Themen";
      }

      if (!allCanceled && !isNoLesson && (isEntfall || isWritten)) {
        displayTopic = overrideTopicForFlags(displayTopic, isEntfall, isWritten);
        rawTopic = displayTopic;
      }

      let background = "rgba(34, 41, 54, 0.84)";
      let foreground = "#0f1216";
      if (allCanceled) {
        background = "rgba(28, 34, 44, 0.72)";
        foreground = "#8b96a8";
      } else if (isNoLesson) {
        background = "rgba(120, 120, 120, 0.82)";
        foreground = "#0f1216";
      } else {
        const courseColor = normalizeCourseColor(topLesson.color, false);
        const tinted = lightenHex(courseColor, 0.1);
        background = colorToRgba(tinted, 0.88);
        foreground = readableTextColor(tinted);
        if (isEntfall) {
          foreground = "#000000";
        } else if (isWritten) {
          foreground = "#b91c1c";
        }
      }

      return {
        topLesson,
        courseName: String(topLesson.courseName || ""),
        allCanceled,
        partialCanceled,
        isNoLesson,
        isEntfall,
        isWritten,
        rawTopic,
        displayText: allCanceled
          ? (topLesson.cancelLabel || "Unterrichtsfrei")
          : formatPartialDisplay(displayTopic, partialCanceled),
        background,
        foreground,
        selectable: !allCanceled && !isNoLesson
      };
    };

    const dayBlockMap = new Map();
    for (const dayIso of days) {
      if (dayOffByIso.has(dayIso)) {
        continue;
      }
      const blocks = new Map();
      let hour = 1;
      while (hour <= hoursPerDay) {
        const rows = lessonsByDayHour.get(`${dayIso}|${hour}`) || [];
        if (rows.length === 0) {
          hour += 1;
          continue;
        }
        if (rows.length > 1) {
          const meta = buildBlockMeta(rows);
          blocks.set(hour, {
            ...meta,
            lessons: rows,
            firstLessonId: rows[0].id,
            rowSpan: 1
          });
          hour += 1;
          continue;
        }
        const startLesson = rows[0];
        const merged = [startLesson];
        let cursor = hour + 1;
        while (cursor <= hoursPerDay) {
          const nextRows = lessonsByDayHour.get(`${dayIso}|${cursor}`) || [];
          if (nextRows.length !== 1) {
            break;
          }
          const nextLesson = nextRows[0];
          if (Number(nextLesson.courseId) !== Number(startLesson.courseId)) {
            break;
          }
          merged.push(nextLesson);
          cursor += 1;
        }
        const meta = buildBlockMeta(merged);
        blocks.set(hour, {
          ...meta,
          lessons: merged,
          firstLessonId: merged[0].id,
          rowSpan: merged.length
        });
        hour = cursor;
      }
      dayBlockMap.set(dayIso, blocks);
    }

    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    const hourHead = document.createElement("th");
    hourHead.textContent = "";
    headerRow.append(hourHead);
    const todayIso = toIsoDate(new Date());

    days.forEach((dayIso, index) => {
      const th = document.createElement("th");
      th.className = "day-head";
      if (dayIso === todayIso) {
        th.classList.add("today");
      }
      const dayOff = dayOffByIso.get(dayIso);
      if (dayOff) {
        th.classList.add("day-off-head");
        th.classList.add(dayOff.kind === "holiday" ? "holiday" : "special");
      }
      th.innerHTML = `
        <span class="day-name">${DAYS_SHORT[index]}</span>
        <span class="day-date">${formatDate(dayIso).slice(0, 5)}</span>
      `;
      headerRow.append(th);
    });
    thead.append(headerRow);

    const tbody = document.createElement("tbody");
    const skipByDay = [0, 0, 0, 0, 0];
    for (let hour = 1; hour <= hoursPerDay; hour += 1) {
      const tr = document.createElement("tr");
      const hourCell = document.createElement("td");
      hourCell.className = "hour";
      hourCell.textContent = String(hour);
      tr.append(hourCell);

      for (let dayIndex = 0; dayIndex < days.length; dayIndex += 1) {
        const dayIso = days[dayIndex];
        const dayOff = dayOffByIso.get(dayIso);
        if (dayOff) {
          if (hour === 1) {
            const td = document.createElement("td");
            td.className = "day-off-column";
            td.classList.add(dayOff.kind === "holiday" ? "holiday" : "special");
            td.rowSpan = hoursPerDay;
            const label = document.createElement("div");
            label.className = "day-off-label";
            label.textContent = dayOff.label;
            td.append(label);
            tr.append(td);
          }
          continue;
        }

        if (skipByDay[dayIndex] > 0) {
          skipByDay[dayIndex] -= 1;
          continue;
        }

        const block = (dayBlockMap.get(dayIso) || new Map()).get(hour);
        if (block) {
          const td = document.createElement("td");
          td.className = "day-cell week-block-cell";
          if (block.rowSpan > 1) {
            td.rowSpan = block.rowSpan;
            skipByDay[dayIndex] = block.rowSpan - 1;
          }
          const inlineTopicLessonId = Number(this.inlineTopicLessonId || 0);
          const inlineEditing = Boolean(
            inlineTopicLessonId
            && block.selectable
            && !block.allCanceled
            && !block.isNoLesson
            && !block.isEntfall
            && !block.isWritten
            && block.lessons.some((entry) => entry.id === inlineTopicLessonId)
          );
          const chip = inlineEditing
            ? document.createElement("div")
            : document.createElement("button");
          if (!inlineEditing) {
            chip.type = "button";
          }
          chip.className = "lesson-block";
          chip.dataset.lessonId = String(block.firstLessonId);
          if (inlineEditing) {
            chip.classList.add("inline-editing");
            chip.title = "Thema bearbeiten · Enter: speichern · Strg/Cmd+Enter: Zeilenumbruch · Esc: abbrechen";
          } else if (block.selectable) {
            chip.title = "Linksklick: Thema bearbeiten / Rechtsklick: Weitere Aktionen";
          }
          chip.style.background = block.background;
          chip.style.color = "#000000";
          if (block.allCanceled) {
            chip.classList.add("canceled");
          }
          if (block.isNoLesson) {
            chip.classList.add("no-lesson");
          }
          if (block.isEntfall) {
            chip.classList.add("entfall");
          }
          if (block.isWritten) {
            chip.classList.add("written");
          }
          if (block.partialCanceled) {
            chip.classList.add("partial");
          }
          if (block.lessons.some((entry) => entry.id === this.selectedLessonId)) {
            chip.classList.add("selected");
          }
          chip.dataset.noLesson = block.isNoLesson ? "1" : "0";
          if (!block.selectable || inlineEditing) {
            chip.classList.add("not-selectable");
          }
          if (block.allCanceled && !inlineEditing) {
            chip.disabled = true;
          }
          const courseName = String(block.courseName || "").trim();
          const lines = String(block.displayText || "")
            .split("\n")
            .map((item) => String(item || "").trim())
            .filter(Boolean);
          const title = document.createElement("span");
          title.className = "title";
          title.textContent = courseName || lines[0] || "\u00a0";
          chip.append(title);
          if (inlineEditing) {
            const inlineTopicInput = document.createElement("textarea");
            inlineTopicInput.className = "week-inline-topic-input";
            inlineTopicInput.dataset.lessonId = String(inlineTopicLessonId);
            inlineTopicInput.maxLength = 240;
            inlineTopicInput.placeholder = "Thema";
            inlineTopicInput.rows = 2;
            inlineTopicInput.wrap = "soft";
            inlineTopicInput.value = String(this.inlineTopicDraft || "");
            inlineTopicInput.setAttribute("aria-label", "Stundentitel bearbeiten");
            chip.append(inlineTopicInput);
          } else {
            const topicText = courseName
              ? lines.join(" ")
              : lines.slice(1).join(" ");
            const shouldShowTopicLine = Boolean(topicText) && !(
              courseName
              && block.isNoLesson
              && topicText.toLowerCase() === courseName.toLowerCase()
            );
            if (shouldShowTopicLine) {
              const line = document.createElement("span");
              line.className = "line";
              line.textContent = topicText;
              chip.append(line);
            }
          }
          td.append(chip);
          tr.append(td);
          continue;
        }

        const td = document.createElement("td");
        td.className = "day-cell empty";
        td.dataset.day = String(dayIndex + 1);
        td.dataset.hour = String(hour);
        td.title = "Doppelklick: Unterrichtsstunde anlegen";
        tr.append(td);
      }

      tbody.append(tr);
    }

    this.refs.weekTable.append(thead, tbody);
    this.syncWeekLayoutScale();
    requestAnimationFrame(() => this.syncWeekLayoutScale());
  }

  renderLessonSection() {
    return;
  }

  _buildCourseTableBlocks(lessons) {
    const lessonsByDate = new Map();
    for (const lesson of lessons) {
      if (!lessonsByDate.has(lesson.lessonDate)) {
        lessonsByDate.set(lesson.lessonDate, []);
      }
      lessonsByDate.get(lesson.lessonDate).push(lesson);
    }

    const blocks = [];
    const orderedDates = [...lessonsByDate.keys()].sort((a, b) => a.localeCompare(b));
    for (const dateIso of orderedDates) {
      const dayLessons = lessonsByDate.get(dateIso).sort((a, b) => a.hour - b.hour);
      let currentBlock = [];
      let lastHour = null;

      for (const lesson of dayLessons) {
        if (lastHour === null || lesson.hour === lastHour + 1) {
          currentBlock.push(lesson);
        } else {
          blocks.push(currentBlock);
          currentBlock = [lesson];
        }
        lastHour = lesson.hour;
      }

      if (currentBlock.length > 0) {
        blocks.push(currentBlock);
      }
    }

    return blocks;
  }

  renderCourseTimeline() {
    const year = this.activeSchoolYear;
    const course = year
      ? this.store.listCourses(year.id).find((item) => item.id === this.selectedCourseId)
      : null;

    this.refs.courseTable.innerHTML = "";

    if (!year || !course) {
      this.refs.courseTitle.textContent = "";
      this.refs.courseTitle.style.color = "#000000";
      this.refs.courseTitle.style.background = "";
      this.refs.courseTitle.style.borderRadius = "";
      this.refs.courseTitle.style.padding = "0.34rem 1.35rem";
      this.refs.courseTitle.style.border = "1px solid transparent";
      return;
    }

    this.refs.courseTitle.textContent = course.name;
    this.refs.courseTitle.style.color = "#000000";
    this.refs.courseTitle.style.background = normalizeCourseColor(course.color, Boolean(course.noLesson));
    this.refs.courseTitle.style.borderRadius = "12px";
    this.refs.courseTitle.style.padding = "0.34rem 1.35rem";
    this.refs.courseTitle.style.border = "1px solid rgba(255, 255, 255, 0.25)";

    const lessons = this.store.listLessonsForWeek(year.id, year.startDate, year.endDate, course.id);
    const blocks = this._buildCourseTableBlocks(lessons);

    const thead = document.createElement("thead");
    thead.innerHTML = `
      <tr>
        <th>Datum</th>
        <th>Tag</th>
        <th>Dauer</th>
        <th>Thema</th>
      </tr>
    `;

    const tbody = document.createElement("tbody");
    const todayIso = toIsoDate(new Date());
    let nextLessonRow = null;

    for (const block of blocks) {
      const topLesson = block[0];
      const allCanceled = block.every((lesson) => lesson.canceled);
      const cancelLabel = allCanceled ? topLesson.cancelLabel || "Unterrichtsfrei" : "";
      const topics = new Set(block.map((lesson) => String(lesson.topic || "").trim()).filter(Boolean));
      let displayTopic = "";
      let rawTopic = "";
      if (allCanceled && cancelLabel) {
        displayTopic = cancelLabel;
      } else if (topics.size === 1) {
        rawTopic = [...topics][0];
        displayTopic = rawTopic;
      } else if (topics.size > 1) {
        displayTopic = "Mehrere Themen";
      }

      const isEntfall = block.some((lesson) => lesson.isEntfall);
      const isWritten = block.some((lesson) => lesson.isWrittenExam);
      if (!allCanceled && (isEntfall || isWritten)) {
        displayTopic = overrideTopicForFlags(displayTopic, isEntfall, isWritten);
        rawTopic = displayTopic;
      }

      const tr = document.createElement("tr");
      if (allCanceled) {
        tr.classList.add("course-row-canceled");
      }
      if (isEntfall) {
        tr.classList.add("course-row-entfall");
      }
      if (isWritten && !isEntfall) {
        tr.classList.add("course-row-written");
      }
      let isNextLesson = false;
      if (!nextLessonRow && !allCanceled && !isEntfall && topLesson.lessonDate > todayIso) {
        tr.classList.add("next-lesson-row");
        nextLessonRow = tr;
        isNextLesson = true;
      }
      const dateCell = document.createElement("td");
      const dateButton = document.createElement("button");
      dateButton.type = "button";
      dateButton.className = "course-date-link";
      dateButton.dataset.date = topLesson.lessonDate;
      dateButton.title = "Woche anzeigen";
      dateButton.textContent = formatDate(topLesson.lessonDate);
      dateCell.append(dateButton);
      const dayCell = document.createElement("td");
      dayCell.textContent = DAYS_SHORT[topLesson.dayOfWeek - 1];
      const durCell = document.createElement("td");
      durCell.textContent = String(block.length);
      durCell.style.textAlign = "center";
      const topicCell = document.createElement("td");

      const firstLessonId = topLesson.id;
      tr.dataset.lessonId = String(firstLessonId);
      const contentWrap = document.createElement("div");
      contentWrap.className = "course-topic-wrap";
      if (isNextLesson) {
        const arrow = document.createElement("span");
        arrow.className = "next-lesson-arrow";
        arrow.textContent = "➜";
        arrow.setAttribute("aria-hidden", "true");
        contentWrap.append(arrow);
      }

      if (allCanceled) {
        const text = document.createElement("span");
        text.className = "muted";
        const italic = document.createElement("em");
        italic.textContent = displayTopic;
        text.append(italic);
        contentWrap.append(text);
      } else {
        const input = document.createElement("input");
        input.className = "course-topic-input";
        input.type = "text";
        input.value = rawTopic;
        input.maxLength = 240;
        input.dataset.lessonId = String(firstLessonId);
        input.dataset.isEntfall = isEntfall ? "1" : "0";
        input.dataset.isWritten = isWritten ? "1" : "0";
        if (isEntfall || isWritten) {
          input.disabled = true;
        }
        contentWrap.append(input);
      }
      topicCell.append(contentWrap);

      tr.append(dateCell, dayCell, durCell, topicCell);
      tbody.append(tr);
    }

    this.refs.courseTable.append(thead, tbody);
    if (this.scrollCourseNextIntoView && nextLessonRow) {
      this.centerCourseRowInScrollPanel(nextLessonRow);
    }
    this.scrollCourseNextIntoView = false;
  }

  centerCourseRowInScrollPanel(row) {
    if (!row || !this.refs.courseTable) {
      return;
    }
    const panel = this.refs.courseTable.closest(".table-panel");
    if (!panel) {
      return;
    }
    const maxScrollTop = Math.max(0, panel.scrollHeight - panel.clientHeight);
    if (maxScrollTop <= 0) {
      return;
    }
    const panelRect = panel.getBoundingClientRect();
    const rowRect = row.getBoundingClientRect();
    const offsetWithinPanel = rowRect.top - panelRect.top;
    const targetTop = panel.scrollTop + offsetWithinPanel - ((panel.clientHeight - rowRect.height) / 2);
    panel.scrollTop = clamp(targetTop, 0, maxScrollTop);
  }

  resetSlotForm() {
    this.refs.slotId.value = "";
    this.refs.slotDay.value = "1";
    this.refs.slotHour.value = "1";
    this.refs.slotDuration.value = "1";
    this.refs.slotStart.value = "";
    this.refs.slotEnd.value = "";
    this.refs.slotParity.value = "0";
    this.refs.slotEditScope.value = "all";
    this.refs.slotEditFromDate.min = "";
    this.refs.slotEditFromDate.max = "";
    this.refs.slotEditFromDate.value = "";
    this.refs.slotDelete.hidden = true;
    this.syncSlotEditTools();
  }

}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    new PlannerApp();
  });
} else {
  new PlannerApp();
}

  </script>
</body>
</html>
